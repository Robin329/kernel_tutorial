diff --git a/arch/arm64/Makefile b/arch/arm64/Makefile
index 52ee23209a56..ef50110e8c2e 100644
--- a/arch/arm64/Makefile
+++ b/arch/arm64/Makefile
@@ -63,9 +63,11 @@ ifeq ($(CONFIG_COMPAT_VDSO), y)
   # should be ignored. If the error is triggered and you set
   # CONFIG_CROSS_COMPILE_ARM32, set CROSS_COMPILE_ARM32 to an appropriate value
   # when invoking make and fix CONFIG_CROSS_COMPILE_ARM32.
+
   ifeq ($(CROSS_COMPILE_ARM32),)
     $(error CROSS_COMPILE_ARM32 not defined or empty, the compat vDSO will not be built)
   else ifeq ($(cc-name),clang)
+    # $(error "cc-name is $(cc-name) CROSS_COMPILE_ARM32:$(CROSS_COMPILE_ARM32)")
     export CLANG_TRIPLE_ARM32 ?= $(CROSS_COMPILE_ARM32)
     export CLANG_TARGET_ARM32 := --target=$(notdir $(CLANG_TRIPLE_ARM32:%-=%))
     export GCC_TOOLCHAIN32_DIR := $(dir $(shell which $(CROSS_COMPILE_ARM32)ld))
diff --git a/arch/arm64/configs/b1c1_defconfig b/arch/arm64/configs/b1c1_defconfig
index bf84e2ec25ad..5b0461a37d1e 100644
--- a/arch/arm64/configs/b1c1_defconfig
+++ b/arch/arm64/configs/b1c1_defconfig
@@ -23,6 +23,11 @@ CONFIG_CGROUP_CPUACCT=y
 CONFIG_CGROUP_SCHEDTUNE=y
 CONFIG_MEMCG=y
 CONFIG_MEMCG_SWAP=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_SAMPLES=y
+CONFIG_SAMPLE_HW_BREAKPOINT=y
+CONFIG_UPROBES=y
+CONFIG_FUNCTION_TRACER=y
 CONFIG_BLK_CGROUP=y
 CONFIG_RT_GROUP_SCHED=y
 CONFIG_CGROUP_BPF=y
@@ -40,6 +45,7 @@ CONFIG_BLK_DEV_INITRD=y
 # CONFIG_RD_LZO is not set
 # CONFIG_RD_LZ4 is not set
 # CONFIG_SYSFS_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
 CONFIG_KALLSYMS_ALL=y
 CONFIG_BPF_SYSCALL=y
 CONFIG_EMBEDDED=y
diff --git a/build.config.bluecross_no-cfi b/build.config.bluecross_no-cfi
index 8cad289704b5..ef6a6551bc59 100644
--- a/build.config.bluecross_no-cfi
+++ b/build.config.bluecross_no-cfi
@@ -1,7 +1,7 @@
 DEFCONFIG=b1c1_defconfig
 KERNEL_DIR=private/msm-google
 . ${ROOT_DIR}/${KERNEL_DIR}/build.config.common.clang
-POST_DEFCONFIG_CMDS="check_defconfig && update_nocfi_config"
+POST_DEFCONFIG_CMDS="update_nocfi_config"
 
 function update_nocfi_config() {
   # Disable clang-specific options
@@ -12,5 +12,5 @@ function update_nocfi_config() {
     -d CFI_PERMISSIVE \
     -d CFI_CLANG
   (cd ${OUT_DIR} && \
-    make O=${OUT_DIR} $archsubarch CROSS_COMPILE=${CROSS_COMPILE} olddefconfig)
+    make -j32 O=${OUT_DIR} $archsubarch CROSS_COMPILE=${CROSS_COMPILE} olddefconfig)
 }
diff --git a/drivers/gpu/drm/drm_atomic.c b/drivers/gpu/drm/drm_atomic.c
index 4e4043fca223..fb0c953372ad 100644
--- a/drivers/gpu/drm/drm_atomic.c
+++ b/drivers/gpu/drm/drm_atomic.c
@@ -235,9 +235,9 @@ void drm_atomic_state_free(struct drm_atomic_state *state)
 
 	drm_atomic_state_clear(state);
 
-	DRM_DEBUG_ATOMIC("Freeing atomic state %p\n", state);
+    pr_info("Freeing atomic state %p\n", state);
 
-	if (config->funcs->atomic_state_free) {
+    if (config->funcs->atomic_state_free) {
 		config->funcs->atomic_state_free(state);
 	} else {
 		drm_atomic_state_default_release(state);
diff --git a/drivers/gpu/drm/drm_drv.c b/drivers/gpu/drm/drm_drv.c
index 80a903bd317d..bec6bcc3751b 100644
--- a/drivers/gpu/drm/drm_drv.c
+++ b/drivers/gpu/drm/drm_drv.c
@@ -42,7 +42,7 @@
  * drm_debug: Enable debug output.
  * Bitmask of DRM_UT_x. See include/drm/drmP.h for details.
  */
-unsigned int drm_debug = 0;
+unsigned int drm_debug = 0xffff;
 EXPORT_SYMBOL(drm_debug);
 
 MODULE_AUTHOR("Gareth Hughes, Leif Delgass, Jos√© Fonseca, Jon Smirl");
diff --git a/drivers/gpu/drm/drm_mipi_dsi.c b/drivers/gpu/drm/drm_mipi_dsi.c
index d518ff5779ef..fc8430f53eed 100644
--- a/drivers/gpu/drm/drm_mipi_dsi.c
+++ b/drivers/gpu/drm/drm_mipi_dsi.c
@@ -24,17 +24,132 @@
  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  * USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
-
+#define DEBUG
+#define pr_fmt(fmt) "[RRR]drm-mipi-dsi:[%s:%d] " fmt, __func__, __LINE__
 #include <drm/drm_mipi_dsi.h>
-
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/slab.h>
-
 #include <video/mipi_display.h>
 
+struct {
+    const char *label;
+    u32 data_type;
+} dsi_data_type_list[] = {
+        /* MIPI DSI Processor-to-Peripheral transaction types */
+        {"DSI_V_SYNC_START", 0x01},
+        {"DSI_V_SYNC_END", 0x11},
+        {"DSI_H_SYNC_START", 0x21},
+        {"DSI_H_SYNC_END", 0x31},
+        {"DSI_COLOR_MODE_OFF", 0x02},
+        {"DSI_COLOR_MODE_ON", 0x12},
+        {"DSI_SHUTDOWN_PERIPHERAL", 0x22},
+        {"DSI_TURN_ON_PERIPHERAL", 0x32},
+        {"DSI_GENERIC_SHORT_WRITE_0_PARAM", 0x03},
+        {"DSI_GENERIC_SHORT_WRITE_1_PARAM", 0x13},
+        {"DSI_GENERIC_SHORT_WRITE_2_PARAM", 0x23},
+        {"DSI_GENERIC_READ_REQUEST_0_PARAM", 0x04},
+        {"DSI_GENERIC_READ_REQUEST_1_PARAM", 0x14},
+        {"DSI_GENERIC_READ_REQUEST_2_PARAM", 0x24},
+        {"DSI_DCS_SHORT_WRITE", 0x05},
+        {"DSI_DCS_SHORT_WRITE_PARAM", 0x15},
+        {"DSI_DCS_READ", 0x06},
+        {"DSI_SET_MAXIMUM_RETURN_PACKET_SIZE", 0x37},
+        {"DSI_END_OF_TRANSMISSION", 0x08},
+        {"DSI_NULL_PACKET", 0x09},
+        {"DSI_BLANKING_PACKET", 0x19},
+        {"DSI_GENERIC_LONG_WRITE", 0x29},
+        {"DSI_DCS_LONG_WRITE", 0x39},
+        {"DSI_LOOSELY_PACKED_PIXEL_STREAM_YCBCR20", 0x0c},
+        {"DSI_PACKED_PIXEL_STREAM_YCBCR24", 0x1c},
+        {"DSI_PACKED_PIXEL_STREAM_YCBCR16", 0x2c},
+        {"DSI_PACKED_PIXEL_STREAM_30", 0x0d},
+        {"DSI_PACKED_PIXEL_STREAM_36", 0x1d},
+        {"DSI_PACKED_PIXEL_STREAM_YCBCR12", 0x3d},
+        {"DSI_PACKED_PIXEL_STREAM_16", 0x0e},
+        {"DSI_PACKED_PIXEL_STREAM_18", 0x1e},
+        {"DSI_PIXEL_STREAM_3BYTE_18", 0x2e},
+        {"DSI_PACKED_PIXEL_STREAM_24", 0x3e},
+        {"DSI_COMPRESSION_MODE", 0x07},
+        {"DSI_PPS", 0x0a},
+        /* MIPI DSI Peripheral-to-Processor transaction types */
+        {"DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT", 0x02},
+        {"DSI_RX_END_OF_TRANSMISSION", 0x08},
+        {"DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE", 0x11},
+        {"DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE", 0x12},
+        {"DSI_RX_GENERIC_LONG_READ_RESPONSE", 0x1a},
+        {"DSI_RX_DCS_LONG_READ_RESPONSE", 0x1c},
+        {"DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE", 0x21},
+        {"DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE", 0x22},
+        /* MIPI DCS commands */
+        {"DCS_NOP", 0x00},
+        {"DCS_SOFT_RESET", 0x01},
+        {"DCS_GET_DISPLAY_ID", 0x04},
+        {"DCS_GET_RED_CHANNEL", 0x06},
+        {"DCS_GET_GREEN_CHANNEL", 0x07},
+        {"DCS_GET_BLUE_CHANNEL", 0x08},
+        {"DCS_GET_DISPLAY_STATUS", 0x09},
+        {"DCS_GET_POWER_MODE", 0x0A},
+        {"DCS_GET_ADDRESS_MODE", 0x0B},
+        {"DCS_GET_PIXEL_FORMAT", 0x0C},
+        {"DCS_GET_DISPLAY_MODE", 0x0D},
+        {"DCS_GET_SIGNAL_MODE", 0x0E},
+        {"DCS_GET_DIAGNOSTIC_RESULT", 0x0F},
+        {"DCS_ENTER_SLEEP_MODE", 0x10},
+        {"DCS_EXIT_SLEEP_MODE", 0x11},
+        {"DCS_ENTER_PARTIAL_MODE", 0x12},
+        {"DCS_ENTER_NORMAL_MODE", 0x13},
+        {"DCS_EXIT_INVERT_MODE", 0x20},
+        {"DCS_ENTER_INVERT_MODE", 0x21},
+        {"DCS_SET_GAMMA_CURVE", 0x26},
+        {"DCS_SET_DISPLAY_OFF", 0x28},
+        {"DCS_SET_DISPLAY_ON", 0x29},
+        {"DCS_SET_COLUMN_ADDRESS", 0x2A},
+        {"DCS_SET_PAGE_ADDRESS", 0x2B},
+        {"DCS_WRITE_MEMORY_START", 0x2C},
+        {"DCS_WRITE_LUT", 0x2D},
+        {"DCS_READ_MEMORY_START", 0x2E},
+        {"DCS_SET_PARTIAL_AREA", 0x30},
+        {"DCS_SET_SCROLL_AREA", 0x33},
+        {"DCS_SET_TEAR_OFF", 0x34},
+        {"DCS_SET_TEAR_ON", 0x35},
+        {"DCS_SET_ADDRESS_MODE", 0x36},
+        {"DCS_SET_SCROLL_START", 0x37},
+        {"DCS_EXIT_IDLE_MODE", 0x38},
+        {"DCS_ENTER_IDLE_MODE", 0x39},
+        {"DCS_SET_PIXEL_FORMAT", 0x3A},
+        {"DCS_WRITE_MEMORY_CONTINUE", 0x3C},
+        {"DCS_READ_MEMORY_CONTINUE", 0x3E},
+        {"DCS_SET_TEAR_SCANLINE", 0x44},
+        {"DCS_GET_SCANLINE", 0x45},
+        {"DCS_SET_DISPLAY_BRIGHTNESS", 0x51},  /* MIPI DCS 1.3 */
+        {"DCS_GET_DISPLAY_BRIGHTNESS", 0x52},  /* MIPI DCS 1.3 */
+        {"DCS_WRITE_CONTROL_DISPLAY", 0x53},   /* MIPI DCS 1.3 */
+        {"DCS_GET_CONTROL_DISPLAY", 0x54},     /* MIPI DCS 1.3 */
+        {"DCS_WRITE_POWER_SAVE", 0x55},        /* MIPI DCS 1.3 */
+        {"DCS_GET_POWER_SAVE", 0x56},          /* MIPI DCS 1.3 */
+        {"DCS_SET_CABC_MIN_BRIGHTNESS", 0x5E}, /* MIPI DCS 1.3 */
+        {"DCS_GET_CABC_MIN_BRIGHTNESS", 0x5F}, /* MIPI DCS 1.3 */
+        {"DCS_READ_DDB_START", 0xA1},
+        {"DCS_READ_DDB_CONTINUE", 0xA8},
+};
+
+#define DSI_PACKET(packet, msg)                                                                                 \
+    do {                                                                                                        \
+        int count = 0;                                                                                          \
+        pr_info("[RRR]: -------------------------------------------\n");                                        \
+        pr_info("[RRR]:  Format:%s(%s) payload_len:%zx total_size:%d\n", dsi_data_type_list[msg->type],         \
+                (mipi_dsi_packet_format_is_long(msg->type) == true ? "LONG" : "SHORT"), packet->payload_length, \
+                packet->size);                                                                                  \
+        pr_info("[RRR]:     [0]:%#x\n", packet->header[0]);                                                     \
+        pr_info("[RRR]:     [1]:%#x\n", packet->header[1]);                                                     \
+        pr_info("[RRR]:     [2]:VC:%#x DT:%#x\n", packet->header[2] & GENMASK(8, 6), packet->header[2] & 0x3f); \
+        for (; count < packet->payload_length; count++) pr_info("[RRR][payload]:%x\n", packet->payload[count]); \
+        pr_info("[RRR]: -------------------------------------------\n");                                        \
+    } while (0)
+
 /**
  * DOC: dsi helpers
  *
@@ -447,45 +562,49 @@ EXPORT_SYMBOL(mipi_dsi_packet_format_is_long);
 int mipi_dsi_create_packet(struct mipi_dsi_packet *packet,
 			   const struct mipi_dsi_msg *msg)
 {
-	if (!packet || !msg)
-		return -EINVAL;
+    int count = 0;
+    if (!packet || !msg) return -EINVAL;
 
-	/* do some minimum sanity checking */
-	if (!mipi_dsi_packet_format_is_short(msg->type) &&
-	    !mipi_dsi_packet_format_is_long(msg->type))
-		return -EINVAL;
+    /* do some minimum sanity checking */
 
-	if (msg->channel > 3)
-		return -EINVAL;
+    if (!mipi_dsi_packet_format_is_short(msg->type) && !mipi_dsi_packet_format_is_long(msg->type)) return -EINVAL;
 
-	memset(packet, 0, sizeof(*packet));
-	packet->header[2] = ((msg->channel & 0x3) << 6) | (msg->type & 0x3f);
+    if (msg->channel > 3) return -EINVAL;
 
-	/* TODO: compute ECC if hardware support is not available */
+    memset(packet, 0, sizeof(*packet));
+    packet->header[2] = ((msg->channel & 0x3) << 6) | (msg->type & 0x3f);
 
-	/*
-	 * Long write packets contain the word count in header bytes 1 and 2.
-	 * The payload follows the header and is word count bytes long.
-	 *
-	 * Short write packets encode up to two parameters in header bytes 1
-	 * and 2.
-	 */
-	if (mipi_dsi_packet_format_is_long(msg->type)) {
-		packet->header[0] = (msg->tx_len >> 0) & 0xff;
-		packet->header[1] = (msg->tx_len >> 8) & 0xff;
+    /* TODO: compute ECC if hardware support is not available */
 
-		packet->payload_length = msg->tx_len;
-		packet->payload = msg->tx_buf;
-	} else {
-		const u8 *tx = msg->tx_buf;
+    /*
+     * Long write packets contain the word count in header bytes 1 and 2.
+     * The payload follows the header and is word count bytes long.
+     *
+     * Short write packets encode up to two parameters in header bytes 1
+     * and 2.
+     */
+    if (mipi_dsi_packet_format_is_long(msg->type)) {
+        packet->header[0] = (msg->tx_len >> 0) & 0xff;
+        packet->header[1] = (msg->tx_len >> 8) & 0xff;
 
-		packet->header[0] = (msg->tx_len > 0) ? tx[0] : 0;
-		packet->header[1] = (msg->tx_len > 1) ? tx[1] : 0;
-	}
+        packet->payload_length = msg->tx_len;
+        packet->payload = msg->tx_buf;
+    } else {
+        const u8 *tx = msg->tx_buf;
 
-	packet->size = sizeof(packet->header) + packet->payload_length;
+        packet->header[0] = (msg->tx_len > 0) ? tx[0] : 0;
+        packet->header[1] = (msg->tx_len > 1) ? tx[1] : 0;
+    }
 
-	return 0;
+    packet->size = sizeof(packet->header) + packet->payload_length;
+    pr_info("------------------------------------------------\n");
+    pr_info("[RRR]: msg->type:%d, '%s' Packet\n", msg->type,
+            mipi_dsi_packet_format_is_long(msg->type) == true ? "LONG" : "SHORT");
+    DSI_PACKET(packet, msg);
+
+    for (; count < packet->payload_length; count++) pr_info("[RRR][payload]:%x\n", packet->payload[count]);
+    pr_info("------------------------------------------------\n");
+    return 0;
 }
 EXPORT_SYMBOL(mipi_dsi_create_packet);
 
diff --git a/drivers/gpu/drm/msm/dsi-staging/dsi_catalog.c b/drivers/gpu/drm/msm/dsi-staging/dsi_catalog.c
index 5012090ccb83..11132f76bf7d 100644
--- a/drivers/gpu/drm/msm/dsi-staging/dsi_catalog.c
+++ b/drivers/gpu/drm/msm/dsi-staging/dsi_catalog.c
@@ -11,8 +11,8 @@
  * GNU General Public License for more details.
  *
  */
-
-#define pr_fmt(fmt) "msm-dsi-catalog:[%s] " fmt, __func__
+#define DEBUG
+#define pr_fmt(fmt) "[RRR]msm-dsi-catalog:[%s] " fmt, __func__
 #include <linux/errno.h>
 
 #include "dsi_catalog.h"
diff --git a/drivers/gpu/drm/msm/dsi-staging/dsi_ctrl.c b/drivers/gpu/drm/msm/dsi-staging/dsi_ctrl.c
index 6f606eaf82fb..f846e1b0c1f3 100644
--- a/drivers/gpu/drm/msm/dsi-staging/dsi_ctrl.c
+++ b/drivers/gpu/drm/msm/dsi-staging/dsi_ctrl.c
@@ -10,8 +10,8 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
-
-#define pr_fmt(fmt)	"dsi-ctrl:[%s] " fmt, __func__
+#define DEBUG
+#define pr_fmt(fmt) "[RRR]dsi-ctrl:[%s] " fmt, __func__
 
 #include <linux/of_device.h>
 #include <linux/err.h>
@@ -1035,6 +1035,120 @@ int dsi_message_validate_tx_mode(struct dsi_ctrl *dsi_ctrl,
 	return rc;
 }
 
+struct {
+    const char *label;
+    u32 data_type;
+} data_type_list[] = {
+        /* MIPI DSI Processor-to-Peripheral transaction types */
+        {"DSI_V_SYNC_START", 0x01},
+        {"DSI_V_SYNC_END", 0x11},
+        {"DSI_H_SYNC_START", 0x21},
+        {"DSI_H_SYNC_END", 0x31},
+        {"DSI_COLOR_MODE_OFF", 0x02},
+        {"DSI_COLOR_MODE_ON", 0x12},
+        {"DSI_SHUTDOWN_PERIPHERAL", 0x22},
+        {"DSI_TURN_ON_PERIPHERAL", 0x32},
+        {"DSI_GENERIC_SHORT_WRITE_0_PARAM", 0x03},
+        {"DSI_GENERIC_SHORT_WRITE_1_PARAM", 0x13},
+        {"DSI_GENERIC_SHORT_WRITE_2_PARAM", 0x23},
+        {"DSI_GENERIC_READ_REQUEST_0_PARAM", 0x04},
+        {"DSI_GENERIC_READ_REQUEST_1_PARAM", 0x14},
+        {"DSI_GENERIC_READ_REQUEST_2_PARAM", 0x24},
+        {"DSI_DCS_SHORT_WRITE", 0x05},
+        {"DSI_DCS_SHORT_WRITE_PARAM", 0x15},
+        {"DSI_DCS_READ", 0x06},
+        {"DSI_SET_MAXIMUM_RETURN_PACKET_SIZE", 0x37},
+        {"DSI_END_OF_TRANSMISSION", 0x08},
+        {"DSI_NULL_PACKET", 0x09},
+        {"DSI_BLANKING_PACKET", 0x19},
+        {"DSI_GENERIC_LONG_WRITE", 0x29},
+        {"DSI_DCS_LONG_WRITE", 0x39},
+        {"DSI_LOOSELY_PACKED_PIXEL_STREAM_YCBCR20", 0x0c},
+        {"DSI_PACKED_PIXEL_STREAM_YCBCR24", 0x1c},
+        {"DSI_PACKED_PIXEL_STREAM_YCBCR16", 0x2c},
+        {"DSI_PACKED_PIXEL_STREAM_30", 0x0d},
+        {"DSI_PACKED_PIXEL_STREAM_36", 0x1d},
+        {"DSI_PACKED_PIXEL_STREAM_YCBCR12", 0x3d},
+        {"DSI_PACKED_PIXEL_STREAM_16", 0x0e},
+        {"DSI_PACKED_PIXEL_STREAM_18", 0x1e},
+        {"DSI_PIXEL_STREAM_3BYTE_18", 0x2e},
+        {"DSI_PACKED_PIXEL_STREAM_24", 0x3e},
+        {"DSI_COMPRESSION_MODE", 0x07},
+        {"DSI_PPS", 0x0a},
+        /* MIPI DSI Peripheral-to-Processor transaction types */
+        {"DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT", 0x02},
+        {"DSI_RX_END_OF_TRANSMISSION", 0x08},
+        {"DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE", 0x11},
+        {"DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE", 0x12},
+        {"DSI_RX_GENERIC_LONG_READ_RESPONSE", 0x1a},
+        {"DSI_RX_DCS_LONG_READ_RESPONSE", 0x1c},
+        {"DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE", 0x21},
+        {"DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE", 0x22},
+        /* MIPI DCS commands */
+        {"DCS_NOP", 0x00},
+        {"DCS_SOFT_RESET", 0x01},
+        {"DCS_GET_DISPLAY_ID", 0x04},
+        {"DCS_GET_RED_CHANNEL", 0x06},
+        {"DCS_GET_GREEN_CHANNEL", 0x07},
+        {"DCS_GET_BLUE_CHANNEL", 0x08},
+        {"DCS_GET_DISPLAY_STATUS", 0x09},
+        {"DCS_GET_POWER_MODE", 0x0A},
+        {"DCS_GET_ADDRESS_MODE", 0x0B},
+        {"DCS_GET_PIXEL_FORMAT", 0x0C},
+        {"DCS_GET_DISPLAY_MODE", 0x0D},
+        {"DCS_GET_SIGNAL_MODE", 0x0E},
+        {"DCS_GET_DIAGNOSTIC_RESULT", 0x0F},
+        {"DCS_ENTER_SLEEP_MODE", 0x10},
+        {"DCS_EXIT_SLEEP_MODE", 0x11},
+        {"DCS_ENTER_PARTIAL_MODE", 0x12},
+        {"DCS_ENTER_NORMAL_MODE", 0x13},
+        {"DCS_EXIT_INVERT_MODE", 0x20},
+        {"DCS_ENTER_INVERT_MODE", 0x21},
+        {"DCS_SET_GAMMA_CURVE", 0x26},
+        {"DCS_SET_DISPLAY_OFF", 0x28},
+        {"DCS_SET_DISPLAY_ON", 0x29},
+        {"DCS_SET_COLUMN_ADDRESS", 0x2A},
+        {"DCS_SET_PAGE_ADDRESS", 0x2B},
+        {"DCS_WRITE_MEMORY_START", 0x2C},
+        {"DCS_WRITE_LUT", 0x2D},
+        {"DCS_READ_MEMORY_START", 0x2E},
+        {"DCS_SET_PARTIAL_AREA", 0x30},
+        {"DCS_SET_SCROLL_AREA", 0x33},
+        {"DCS_SET_TEAR_OFF", 0x34},
+        {"DCS_SET_TEAR_ON", 0x35},
+        {"DCS_SET_ADDRESS_MODE", 0x36},
+        {"DCS_SET_SCROLL_START", 0x37},
+        {"DCS_EXIT_IDLE_MODE", 0x38},
+        {"DCS_ENTER_IDLE_MODE", 0x39},
+        {"DCS_SET_PIXEL_FORMAT", 0x3A},
+        {"DCS_WRITE_MEMORY_CONTINUE", 0x3C},
+        {"DCS_READ_MEMORY_CONTINUE", 0x3E},
+        {"DCS_SET_TEAR_SCANLINE", 0x44},
+        {"DCS_GET_SCANLINE", 0x45},
+        {"DCS_SET_DISPLAY_BRIGHTNESS", 0x51},  /* MIPI DCS 1.3 */
+        {"DCS_GET_DISPLAY_BRIGHTNESS", 0x52},  /* MIPI DCS 1.3 */
+        {"DCS_WRITE_CONTROL_DISPLAY", 0x53},   /* MIPI DCS 1.3 */
+        {"DCS_GET_CONTROL_DISPLAY", 0x54},     /* MIPI DCS 1.3 */
+        {"DCS_WRITE_POWER_SAVE", 0x55},        /* MIPI DCS 1.3 */
+        {"DCS_GET_POWER_SAVE", 0x56},          /* MIPI DCS 1.3 */
+        {"DCS_SET_CABC_MIN_BRIGHTNESS", 0x5E}, /* MIPI DCS 1.3 */
+        {"DCS_GET_CABC_MIN_BRIGHTNESS", 0x5F}, /* MIPI DCS 1.3 */
+        {"DCS_READ_DDB_START", 0xA1},
+        {"DCS_READ_DDB_CONTINUE", 0xA8},
+};
+#define DSI_CTRL_PACKET(packet, msg)                                                                           \
+    do {                                                                                                       \
+        int count = 0;                                                                                         \
+        pr_info("[RRR]: -------------------------------------------\n");                                       \
+        pr_info("[RRR]:  Format:%s(%s) payload_len:%zx total_size:%d\n", data_type_list[msg->type],            \
+                (mipi_dsi_packet_format_is_long(msg->type) == true ? "LONG" : "SHORT"), packet.payload_length, \
+                packet.size);                                                                                  \
+        pr_info("[RRR]:     [0]:%#x\n", packet.header[0]);                                                     \
+        pr_info("[RRR]:     [1]:%#x\n", packet.header[1]);                                                     \
+        pr_info("[RRR]:     [2]:VC:%#x DT:%#x\n", packet.header[2] & GENMASK(8, 6), packet.header[2] & 0x3f);  \
+        for (; count < packet.payload_length; count++) pr_info("[RRR][payload[%d]]:%x\n", count, packet.payload[count]);  \
+        pr_info("[RRR]: -------------------------------------------\n");                                       \
+    } while (0)
 static int dsi_message_tx(struct dsi_ctrl *dsi_ctrl,
 			  const struct mipi_dsi_msg *msg,
 			  u32 flags)
@@ -1251,9 +1365,9 @@ static int dsi_message_tx(struct dsi_ctrl *dsi_ctrl,
 		}
 	}
 error:
-	if (buffer)
-		devm_kfree(&dsi_ctrl->pdev->dev, buffer);
-	return rc;
+    DSI_CTRL_PACKET(packet, msg);
+    if (buffer) devm_kfree(&dsi_ctrl->pdev->dev, buffer);
+    return rc;
 }
 
 static int dsi_set_max_return_size(struct dsi_ctrl *dsi_ctrl,
@@ -1455,42 +1569,39 @@ static int dsi_message_rx(struct dsi_ctrl *dsi_ctrl,
 	}
 
 	buff = head;
-	for (i = 0; i < buffer_sz; i += 4)
-		pr_debug("buffer[%d-%d] = %08x\n",
-			 i, i + 3, *((u32 *)&buff[i]));
-
-	if (hw_read_cnt < 16 && !short_resp)
-		header_offset = (16 - hw_read_cnt);
-	else
-		header_offset = 0;
-
-	pr_debug("hw_read_cnt %d, header_offset %d\n",
-			hw_read_cnt, header_offset);
-
-	/* parse the data read from panel */
-	cmd = buff[header_offset];
-	pr_debug("response type %d\n", cmd);
-	switch (cmd) {
-	case MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT:
-		pr_err("Rx ACK_ERROR\n");
-		rc = 0;
-		break;
-	case MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE:
-	case MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE:
-		rc = dsi_parse_short_read1_resp(msg, &buff[header_offset]);
-		break;
-	case MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE:
-	case MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE:
-		rc = dsi_parse_short_read2_resp(msg, &buff[header_offset]);
-		break;
-	case MIPI_DSI_RX_GENERIC_LONG_READ_RESPONSE:
-	case MIPI_DSI_RX_DCS_LONG_READ_RESPONSE:
-		rc = dsi_parse_long_read_resp(msg, &buff[header_offset]);
-		break;
-	default:
-		pr_warn("Invalid response\n");
-		rc = 0;
-	}
+    for (i = 0; i < buffer_sz; i += 4) pr_err("[RRR] buffer[%d-%d] = %08x\n", i, i + 3, *((u32 *)&buff[i]));
+
+    if (hw_read_cnt < 16 && !short_resp)
+        header_offset = (16 - hw_read_cnt);
+    else
+        header_offset = 0;
+
+    pr_debug("hw_read_cnt %d, header_offset %d\n", hw_read_cnt, header_offset);
+
+    /* parse the data read from panel */
+    cmd = buff[header_offset];
+    pr_debug("response type %d\n", cmd);
+    switch (cmd) {
+        case MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT:
+            pr_err("Rx ACK_ERROR\n");
+            rc = 0;
+            break;
+        case MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE:
+        case MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE:
+            rc = dsi_parse_short_read1_resp(msg, &buff[header_offset]);
+            break;
+        case MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE:
+        case MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE:
+            rc = dsi_parse_short_read2_resp(msg, &buff[header_offset]);
+            break;
+        case MIPI_DSI_RX_GENERIC_LONG_READ_RESPONSE:
+        case MIPI_DSI_RX_DCS_LONG_READ_RESPONSE:
+            rc = dsi_parse_long_read_resp(msg, &buff[header_offset]);
+            break;
+        default:
+            pr_warn("Invalid response\n");
+            rc = 0;
+    }
 
 error:
 	kfree(buff);
@@ -2840,17 +2951,16 @@ int dsi_ctrl_cmd_transfer(struct dsi_ctrl *dsi_ctrl,
 
 	if (flags & DSI_CTRL_CMD_READ) {
 		rc = dsi_message_rx(dsi_ctrl, msg, flags);
-		if (rc < 0)
-			pr_err("read message failed read, rc=%d\n", rc);
-		else if (rc == 0)
-			pr_warn("empty message back\n");
-	} else {
-		rc = dsi_message_tx(dsi_ctrl, msg, flags);
-		if (rc)
-			pr_err("command msg transfer failed, rc = %d\n", rc);
-	}
-
-	dsi_ctrl_update_state(dsi_ctrl, DSI_CTRL_OP_CMD_TX, 0x0);
+        if (rc < 0)
+            pr_err("read message failed read, rc=%d\n", rc);
+        else if (rc == 0)
+            pr_warn("empty message back\n");
+    } else {
+        rc = dsi_message_tx(dsi_ctrl, msg, flags);
+        if (rc) pr_err("command msg transfer failed, rc = %d\n", rc);
+    }
+
+    dsi_ctrl_update_state(dsi_ctrl, DSI_CTRL_OP_CMD_TX, 0x0);
 
 error:
 	mutex_unlock(&dsi_ctrl->ctrl_lock);
diff --git a/drivers/gpu/drm/msm/dsi-staging/dsi_ctrl_hw_cmn.c b/drivers/gpu/drm/msm/dsi-staging/dsi_ctrl_hw_cmn.c
index c1af52f84b91..86b78f85e6c4 100644
--- a/drivers/gpu/drm/msm/dsi-staging/dsi_ctrl_hw_cmn.c
+++ b/drivers/gpu/drm/msm/dsi-staging/dsi_ctrl_hw_cmn.c
@@ -12,7 +12,9 @@
  *
  */
 
-#define pr_fmt(fmt) "dsi-hw:" fmt
+#define DEBUG
+#define pr_fmt(fmt) "[RRR]dsi-hw-cmn:[%s] " fmt, __func__
+
 #include <linux/delay.h>
 #include <linux/iopoll.h>
 
@@ -663,9 +665,10 @@ void dsi_ctrl_hw_cmn_kickoff_fifo_command(struct dsi_ctrl_hw *ctrl,
 	 * DWORD (set to zero) if the length of command buffer is odd DWORDS.
 	 */
 	for (i = 0; i < cmd->size; i += 4) {
-		DSI_W32(ctrl, DSI_TEST_PATTERN_GEN_CMD_DMA_INIT_VAL, *ptr);
-		ptr++;
-	}
+        pr_err("ptr:%#x", *ptr);
+        DSI_W32(ctrl, DSI_TEST_PATTERN_GEN_CMD_DMA_INIT_VAL, *ptr);
+        ptr++;
+    }
 
 	if ((cmd->size / 4) & 0x1)
 		DSI_W32(ctrl, DSI_TEST_PATTERN_GEN_CMD_DMA_INIT_VAL, 0);
diff --git a/drivers/gpu/drm/msm/dsi-staging/dsi_display.c b/drivers/gpu/drm/msm/dsi-staging/dsi_display.c
index 012a15a5776f..2b7a8948b2af 100644
--- a/drivers/gpu/drm/msm/dsi-staging/dsi_display.c
+++ b/drivers/gpu/drm/msm/dsi-staging/dsi_display.c
@@ -11,8 +11,8 @@
  * GNU General Public License for more details.
  *
  */
-
-#define pr_fmt(fmt)	"msm-dsi-display:[%s] " fmt, __func__
+#define DEBUG
+#define pr_fmt(fmt) "[RRR]msm-dsi-display:[%s] " fmt, __func__
 
 #include <linux/list.h>
 #include <linux/of.h>
@@ -54,7 +54,8 @@ static const struct of_device_id dsi_display_dt_match[] = {
 	{}
 };
 
-static struct dsi_display *main_display;
+struct dsi_display *main_display;
+EXPORT_SYMBOL(main_display);
 
 static void dsi_display_mask_ctrl_error_interrupts(struct dsi_display *display)
 {
@@ -625,19 +626,20 @@ static int dsi_display_status_check_te(struct dsi_display *display)
 {
 	int rc = 1;
 	int const esd_te_timeout = msecs_to_jiffies(3*20);
+    unsigned long time = 0;
 
-	dsi_display_change_te_irq_status(display, true);
-
-	reinit_completion(&display->esd_te_gate);
-	if (!wait_for_completion_timeout(&display->esd_te_gate,
-				esd_te_timeout)) {
-		pr_err("TE check failed\n");
-		rc = -EINVAL;
-	}
+    dsi_display_change_te_irq_status(display, true);
 
-	dsi_display_change_te_irq_status(display, false);
+    reinit_completion(&display->esd_te_gate);
+    time = wait_for_completion_timeout(&display->esd_te_gate, esd_te_timeout);
+    if (!time) {
+        pr_err("TE check failed\n");
+        rc = -EINVAL;
+    }
+    pr_info("drm[%s:%d] time:%d\n", __FUNCTION__, __LINE__);
+    dsi_display_change_te_irq_status(display, false);
 
-	return rc;
+    return rc;
 }
 
 int dsi_display_check_status(void *display, bool te_check_override)
@@ -667,23 +669,22 @@ int dsi_display_check_status(void *display, bool te_check_override)
 
 	dsi_display_clk_ctrl(dsi_display->dsi_clk_handle,
 		DSI_ALL_CLKS, DSI_CLK_ON);
+    pr_info("drm[%s:%d] status_mode:%d\n", __FUNCTION__, __LINE__, status_mode);
+    if (status_mode == ESD_MODE_REG_READ) {
+        rc = dsi_display_status_reg_read(dsi_display);
+    } else if (status_mode == ESD_MODE_SW_BTA) {
+        rc = dsi_display_status_bta_request(dsi_display);
+    } else if (status_mode == ESD_MODE_PANEL_TE) {
+        rc = dsi_display_status_check_te(dsi_display);
+    } else {
+        pr_warn("unsupported check status mode\n");
+        panel->esd_config.esd_enabled = false;
+    }
 
-	if (status_mode == ESD_MODE_REG_READ) {
-		rc = dsi_display_status_reg_read(dsi_display);
-	} else if (status_mode == ESD_MODE_SW_BTA) {
-		rc = dsi_display_status_bta_request(dsi_display);
-	} else if (status_mode == ESD_MODE_PANEL_TE) {
-		rc = dsi_display_status_check_te(dsi_display);
-	} else {
-		pr_warn("unsupported check status mode\n");
-		panel->esd_config.esd_enabled = false;
-	}
-
-	dsi_display_clk_ctrl(dsi_display->dsi_clk_handle,
-		DSI_ALL_CLKS, DSI_CLK_OFF);
-	dsi_panel_release_panel_lock(panel);
+    dsi_display_clk_ctrl(dsi_display->dsi_clk_handle, DSI_ALL_CLKS, DSI_CLK_OFF);
+    dsi_panel_release_panel_lock(panel);
 
-	return rc;
+    return rc;
 }
 
 static int dsi_display_cmd_prepare(const char *cmd_buf, u32 cmd_buf_len,
@@ -759,9 +760,8 @@ int dsi_display_cmd_transfer(void *display, const char *cmd_buf,
 		rc = -EPERM;
 		goto end;
 	}
-
-	rc = dsi_display->host.ops->transfer(&dsi_display->host,
-			&cmd.msg);
+    dump_stack();
+    rc = dsi_display->host.ops->transfer(&dsi_display->host, &cmd.msg);
 end:
 	mutex_unlock(&dsi_display->display_lock);
 	return rc;
@@ -2667,6 +2667,39 @@ static int dsi_display_wake_up(struct dsi_display *display)
 {
 	return 0;
 }
+#define DSI_MSG(dsi_msg)                                                                                  \
+    do {                                                                                                  \
+        int count = 0;                                                                                    \
+        const char *tx_buf = dsi_msg.tx_buf;                                                              \
+        const char *rx_buf = dsi_msg.rx_buf;                                                              \
+        pr_info("[RRR]: -------------------------------------------\n");                                  \
+        pr_info("[RRR] channel:%d type:%d flags:%d ctrl:%d wait_ms:%d \n", dsi_msg.channel, dsi_msg.type, \
+                dsi_msg.flags, dsi_msg.wait_ms);                                                          \
+        pr_info("[RRR]: tx_len:%d ", dsi_msg.tx_len);                                                     \
+        for (count = 0; count < dsi_msg.tx_len; count++) pr_info("       tx_buf[%d]:%#x ", count, tx_buf[count]);  \
+        pr_info("\n");                                                                                    \
+        pr_info("[RRR]: rx_len:%d\n", dsi_msg.rx_len);                                                    \
+        for (count = 0; count < dsi_msg.rx_len; count++) pr_info("       rx_buf[%d]:%#x ", count, rx_buf[count]);  \
+        pr_info("\n");                                                                                    \
+        pr_info("[RRR]-------------------------------------------\n");                                    \
+    } while (0)
+
+#define DSI_MSG_P(dsi_msg)                                                                                           \
+    do {                                                                                                             \
+        int count = 0;                                                                                               \
+        const char *tx_buf = dsi_msg->tx_buf;                                                                        \
+        const char *rx_buf = dsi_msg->rx_buf;                                                                        \
+        pr_info("[RRR]: -------------------------------------------\n");                                             \
+        pr_info("[RRR] channel:%d type:%d flags:%d ctrl:%d wait_ms:%d tx_len:%d\n", dsi_msg->channel, dsi_msg->type, \
+                dsi_msg->flags, dsi_msg->wait_ms, dsi_msg->tx_len);                                                  \
+        pr_info("[RRR]: tx_len:%d", dsi_msg->tx_len);                                                                \
+        for (count = 0; count < dsi_msg->tx_len; count++) pr_info("       tx_buf[%d]:%#x ", count, tx_buf[count]);            \
+        pr_info("\n");                                                                                               \
+        pr_info("[RRR]: rx_len:%d\n", dsi_msg->rx_len);                                                              \
+        for (count = 0; count < dsi_msg->rx_len; count++) pr_info("       rx_buf[%d]:%#x ", count, rx_buf[count]);            \
+        pr_info("\n");                                                                                               \
+        pr_info("[RRR]: -------------------------------------------\n");                                             \
+    } while (0)
 
 static int dsi_display_broadcast_cmd(struct dsi_display *display,
 				     const struct mipi_dsi_msg *msg)
@@ -2699,30 +2732,26 @@ static int dsi_display_broadcast_cmd(struct dsi_display *display,
 
 	for (i = 0; i < display->ctrl_count; i++) {
 		ctrl = &display->ctrl[i];
-		if (ctrl == m_ctrl)
-			continue;
-
-		rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, msg, flags);
-		if (rc) {
-			pr_err("[%s] cmd transfer failed, rc=%d\n",
-			       display->name, rc);
-			goto error;
-		}
-
-		rc = dsi_ctrl_cmd_tx_trigger(ctrl->ctrl, flags);
-		if (rc) {
-			pr_err("[%s] cmd trigger failed, rc=%d\n",
-			       display->name, rc);
-			goto error;
-		}
-	}
-
-	rc = dsi_ctrl_cmd_tx_trigger(m_ctrl->ctrl, m_flags);
-	if (rc) {
-		pr_err("[%s] cmd trigger failed for master, rc=%d\n",
-		       display->name, rc);
-		goto error;
-	}
+        if (ctrl == m_ctrl) continue;
+        DSI_MSG_P(msg);
+        rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, msg, flags);
+        if (rc) {
+            pr_err("[%s] cmd transfer failed, rc=%d\n", display->name, rc);
+            goto error;
+        }
+
+        rc = dsi_ctrl_cmd_tx_trigger(ctrl->ctrl, flags);
+        if (rc) {
+            pr_err("[%s] cmd trigger failed, rc=%d\n", display->name, rc);
+            goto error;
+        }
+    }
+
+    rc = dsi_ctrl_cmd_tx_trigger(m_ctrl->ctrl, m_flags);
+    if (rc) {
+        pr_err("[%s] cmd trigger failed for master, rc=%d\n", display->name, rc);
+        goto error;
+    }
 
 error:
 	return rc;
@@ -2885,60 +2914,51 @@ static ssize_t dsi_host_transfer(struct mipi_dsi_host *host,
 		pr_err("Invalid params\n");
 		return 0;
 	}
-
-	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
-			DSI_ALL_CLKS, DSI_CLK_ON);
-	if (rc) {
-		pr_err("[%s] failed to enable all DSI clocks, rc=%d\n",
-		       display->name, rc);
-		goto error;
-	}
-
-	rc = dsi_display_wake_up(display);
-	if (rc) {
-		pr_err("[%s] failed to wake up display, rc=%d\n",
-		       display->name, rc);
-		goto error_disable_clks;
-	}
-
-	rc = dsi_display_cmd_engine_enable(display);
-	if (rc) {
-		pr_err("[%s] failed to enable cmd engine, rc=%d\n",
-		       display->name, rc);
-		goto error_disable_clks;
-	}
-
-	if (display->tx_cmd_buf == NULL) {
-		rc = dsi_host_alloc_cmd_tx_buffer(display);
-		if (rc) {
-			pr_err("failed to allocate cmd tx buffer memory\n");
-			goto error_disable_cmd_engine;
-		}
-	}
-
-	if (display->ctrl_count > 1 && !(msg->flags & MIPI_DSI_MSG_UNICAST)) {
-		rc = dsi_display_broadcast_cmd(display, msg);
-		if (rc) {
-			pr_err("[%s] cmd broadcast failed, rc=%d\n",
-			       display->name, rc);
-			goto error_disable_cmd_engine;
-		}
-	} else {
-		int ctrl_idx = (msg->flags & MIPI_DSI_MSG_UNICAST) ?
-				msg->ctrl : 0;
-		u32 flags = DSI_CTRL_CMD_FETCH_MEMORY;
-
-		if (msg->rx_buf)
-			flags |= DSI_CTRL_CMD_READ;
-
-		rc = dsi_ctrl_cmd_transfer(display->ctrl[ctrl_idx].ctrl, msg,
-					   flags);
-		if (rc < 0) {
-			pr_err("[%s] cmd transfer failed, rc=%d\n",
-			       display->name, rc);
-			goto error_disable_cmd_engine;
-		}
-	}
+    dump_stack();
+    rc = dsi_display_clk_ctrl(display->dsi_clk_handle, DSI_ALL_CLKS, DSI_CLK_ON);
+    if (rc) {
+        pr_err("[%s] failed to enable all DSI clocks, rc=%d\n", display->name, rc);
+        goto error;
+    }
+
+    rc = dsi_display_wake_up(display);
+    if (rc) {
+        pr_err("[%s] failed to wake up display, rc=%d\n", display->name, rc);
+        goto error_disable_clks;
+    }
+
+    rc = dsi_display_cmd_engine_enable(display);
+    if (rc) {
+        pr_err("[%s] failed to enable cmd engine, rc=%d\n", display->name, rc);
+        goto error_disable_clks;
+    }
+
+    if (display->tx_cmd_buf == NULL) {
+        rc = dsi_host_alloc_cmd_tx_buffer(display);
+        if (rc) {
+            pr_err("failed to allocate cmd tx buffer memory\n");
+            goto error_disable_cmd_engine;
+        }
+    }
+
+    if (display->ctrl_count > 1 && !(msg->flags & MIPI_DSI_MSG_UNICAST)) {
+        rc = dsi_display_broadcast_cmd(display, msg);
+        if (rc) {
+            pr_err("[%s] cmd broadcast failed, rc=%d\n", display->name, rc);
+            goto error_disable_cmd_engine;
+        }
+    } else {
+        int ctrl_idx = (msg->flags & MIPI_DSI_MSG_UNICAST) ? msg->ctrl : 0;
+        u32 flags = DSI_CTRL_CMD_FETCH_MEMORY;
+
+        if (msg->rx_buf) flags |= DSI_CTRL_CMD_READ;
+
+        rc = dsi_ctrl_cmd_transfer(display->ctrl[ctrl_idx].ctrl, msg, flags);
+        if (rc < 0) {
+            pr_err("[%s] cmd transfer failed, rc=%d\n", display->name, rc);
+            goto error_disable_cmd_engine;
+        }
+    }
 
 error_disable_cmd_engine:
 	ret = dsi_display_cmd_engine_disable(display);
@@ -3826,39 +3846,36 @@ static int dsi_display_dfps_update(struct dsi_display *display,
 
 	/* For split DSI, update the clock master first */
 
-	pr_debug("configuring seamless dynamic fps\n\n");
-
-	m_ctrl = &display->ctrl[display->clk_master_idx];
-	rc = dsi_ctrl_async_timing_update(m_ctrl->ctrl, timing);
-	if (rc) {
-		pr_err("[%s] failed to dfps update host_%d, rc=%d\n",
-				display->name, i, rc);
-		goto error;
-	}
-
-	/* Update the rest of the controllers */
-	for (i = 0; i < display->ctrl_count; i++) {
-		ctrl = &display->ctrl[i];
-		if (!ctrl->ctrl || (ctrl == m_ctrl))
-			continue;
-
-		rc = dsi_ctrl_async_timing_update(ctrl->ctrl, timing);
-		if (rc) {
-			pr_err("[%s] failed to dfps update host_%d, rc=%d\n",
-					display->name, i, rc);
-			goto error;
-		}
-	}
-
-	panel_mode = display->panel->cur_mode;
-	memcpy(panel_mode, dsi_mode, sizeof(*panel_mode));
-	/*
-	 * dsi_mode_flags flags are used to communicate with other drm driver
-	 * components, and are transient. They aren't inherently part of the
-	 * display panel's mode and shouldn't be saved into the cached currently
-	 * active mode.
-	 */
-	panel_mode->dsi_mode_flags = 0;
+    pr_debug("configuring seamless dynamic fps\n");
+
+    m_ctrl = &display->ctrl[display->clk_master_idx];
+    rc = dsi_ctrl_async_timing_update(m_ctrl->ctrl, timing);
+    if (rc) {
+        pr_err("[%s] failed to dfps update host_%d, rc=%d\n", display->name, i, rc);
+        goto error;
+    }
+
+    /* Update the rest of the controllers */
+    for (i = 0; i < display->ctrl_count; i++) {
+        ctrl = &display->ctrl[i];
+        if (!ctrl->ctrl || (ctrl == m_ctrl)) continue;
+
+        rc = dsi_ctrl_async_timing_update(ctrl->ctrl, timing);
+        if (rc) {
+            pr_err("[%s] failed to dfps update host_%d, rc=%d\n", display->name, i, rc);
+            goto error;
+        }
+    }
+
+    panel_mode = display->panel->cur_mode;
+    memcpy(panel_mode, dsi_mode, sizeof(*panel_mode));
+    /*
+     * dsi_mode_flags flags are used to communicate with other drm driver
+     * components, and are transient. They aren't inherently part of the
+     * display panel's mode and shouldn't be saved into the cached currently
+     * active mode.
+     */
+    panel_mode->dsi_mode_flags = 0;
 
 error:
 	return rc;
@@ -6624,7 +6641,15 @@ int dsi_display_unprepare(struct dsi_display *display)
 	mutex_unlock(&display->display_lock);
 	return rc;
 }
+static int param_ops_set(const char *val, const struct kernel_param *kp) {
+    int ret;
+    unsigned int enable = 0;
 
+    if (!val) return -EINVAL;
+    ret = kstrtou32(val, 10, &enable);
+    pr_info("[%s:%d] enable:%d\n", __FUNCTION__, __LINE__, enable);
+    return ret;
+}
 static int __init dsi_display_register(void)
 {
 	dsi_phy_drv_register();
@@ -6640,8 +6665,22 @@ static void __exit dsi_display_unregister(void)
 }
 module_param_string(dsi_display0, dsi_display_primary, MAX_CMDLINE_PARAM_LEN,
 								0600);
+
+static char param_value_4[20];
+static struct kparam_string newchan_kps = {
+        .string = param_value_4,
+        .maxlen = 20,
+};
+static const struct kernel_param_ops param_ops_test_2 = {
+        .set = param_ops_set,
+        .get = param_get_int,
+};
+module_param_cb(dsi_param, &param_ops_test_2, &newchan_kps, 0644);
+MODULE_PARM_DESC(dsi_param, "Module param cb param_ops_test & param_value_4");
+
 MODULE_PARM_DESC(dsi_display0,
-	"msm_drm.dsi_display0=<display node>:<configX> where <display node> is 'primary dsi display node name' and <configX> where x represents index in the topology list");
+                 "msm_drm.dsi_display0=<display node>:<configX> where <display node> is 'primary dsi display "
+                 "node name' and <configX> where x represents index in the topology list");
 module_param_string(dsi_display1, dsi_display_secondary, MAX_CMDLINE_PARAM_LEN,
 								0600);
 MODULE_PARM_DESC(dsi_display1,
diff --git a/drivers/gpu/drm/msm/dsi-staging/dsi_panel.c b/drivers/gpu/drm/msm/dsi-staging/dsi_panel.c
index 29be86c32a22..4abe8f1ef493 100644
--- a/drivers/gpu/drm/msm/dsi-staging/dsi_panel.c
+++ b/drivers/gpu/drm/msm/dsi-staging/dsi_panel.c
@@ -11,8 +11,8 @@
  * GNU General Public License for more details.
  *
  */
-
-#define pr_fmt(fmt)	"msm-dsi-panel:[%s:%d] " fmt, __func__, __LINE__
+#define DEBUG
+#define pr_fmt(fmt) "[RRR]dsi-panel:[%s:%d] " fmt, __func__, __LINE__
 #include <linux/debugfs.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
@@ -499,7 +499,63 @@ static int dsi_panel_power_off(struct dsi_panel *panel)
 
 	return rc;
 }
-
+struct {
+    const char *label;
+    enum dsi_cmd_set_type type;
+} cmdset_list[] = {
+        {"pre_on", DSI_CMD_SET_PRE_ON},
+        {"on", DSI_CMD_SET_ON},
+        {"post_on", DSI_CMD_SET_POST_ON},
+        {"pre_off", DSI_CMD_SET_PRE_OFF},
+        {"off", DSI_CMD_SET_OFF},
+        {"post_off", DSI_CMD_SET_POST_OFF},
+        {"panel_status", DSI_CMD_SET_PANEL_STATUS},
+        {"pps", DSI_CMD_SET_PPS},
+        {"lp1", DSI_CMD_SET_LP1},
+        {"lp2", DSI_CMD_SET_LP2},
+        {"no_lp", DSI_CMD_SET_NOLP},
+        {"vr", DSI_CMD_SET_VR},
+        {"novr", DSI_CMD_SET_NOVR},
+};
+#define DSI_MSG(dsi_msg, cmdset_list)                                                                      \
+    do {                                                                                                   \
+        int count = 0;                                                                                     \
+        const char *tx_buf = dsi_msg.tx_buf;                                                               \
+        const char *rx_buf = dsi_msg.rx_buf;                                                               \
+        pr_info("[RRR]: -------------------------------------------\n");                             \
+        pr_info("[RRR]-[%s] channel:%d type:%d flags:%d ctrl:%d wait_ms:%d \n", cmdset_list[dsi_msg.type], \
+                dsi_msg.channel, dsi_msg.type, dsi_msg.flags, dsi_msg.wait_ms);                            \
+        pr_info("[RRR]: tx_len:%d", dsi_msg.tx_len);                                                       \
+        for (count = 0; count < dsi_msg.tx_len; count++) pr_info("       tx_buf[%d]:%#x ", count, tx_buf[count]);   \
+        pr_info("\n");                                                                                     \
+        pr_info("[RRR]: rx_len:%d", dsi_msg.rx_len);                                                       \
+        for (count = 0; count < dsi_msg.rx_len; count++) pr_info("       rx_buf[%d]:%#x ", count, rx_buf[count]);   \
+        pr_info("\n");                                                                                     \
+        pr_info("[RRR]-------------------------------------------\n");                                     \
+    } while (0)
+
+#define DSI_MSG_P(dsi_msg, cmdset_list)                                                                              \
+    do {                                                                                                             \
+        int count = 0;                                                                                               \
+        const char *tx_buf = dsi_msg->tx_buf;                                                                         \
+        const char *rx_buf = dsi_msg->rx_buf;                                                                         \
+        pr_info("[RRR]: -------------------------------------------\n");                                             \
+        pr_info("[RRR]-[%s] channel:%d type:%d flags:%d ctrl:%d wait_ms:%d tx_len:%d\n", cmdset_list[dsi_msg->type], \
+                dsi_msg->channel, dsi_msg->type, dsi_msg->flags, dsi_msg->wait_ms, dsi_msg->tx_len);                 \
+        pr_info("[RRR]: tx_len:%d", dsi_msg->tx_len);                                                                \
+        for (count = 0; count < dsi_msg.tx_len; count++) pr_info("       tx_buf[%d]:%#x ", count, tx_buf[count]);             \
+        pr_info("\n");                                                                                               \
+        pr_info("[RRR]: rx_len:%d", dsi_msg->rx_len);                                                                \
+        for (count = 0; count < dsi_msg.rx_len; count++) pr_info("       rx_buf[%d]:%#x ", count, rx_buf[count]);             \
+        pr_info("\n");                                                                                               \
+        pr_info("[RRR]: -------------------------------------------\n");                                             \
+    } while (0)
+
+#define DSI_CMD_DESC(cmds, cmdset_list)                                                                    \
+    do {                                                                                                   \
+        DSI_MSG(&cmds->msg, cmdset_list);                                                                  \
+        pr_info("[RRR]-[%s]: last_command0:%d post_wait_ms:%d\n", cmds->last_command, cmds->post_wait_ms); \
+    } while (0)
 int dsi_panel_cmd_set_transfer(struct dsi_panel *panel,
 			       struct dsi_panel_cmd_set *cmd)
 {
@@ -514,25 +570,21 @@ int dsi_panel_cmd_set_transfer(struct dsi_panel *panel,
 		pr_debug("[%s] No commands to be sent\n", panel->name);
 		goto error;
 	}
-
-	for (i = 0; i < cmd->count; i++) {
-		if (cmd->state == DSI_CMD_SET_STATE_LP)
-			cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
-
-		if (cmds->last_command)
-			cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
-
-		len = ops->transfer(panel->host, &cmds->msg);
-		if (len < 0) {
-			rc = len;
-			pr_err("failed to set cmds, rc=%d\n", rc);
-			goto error;
-		}
-		if (cmds->post_wait_ms)
-			usleep_range(cmds->post_wait_ms*1000,
-					((cmds->post_wait_ms*1000)+10));
-		cmds++;
-	}
+    dump_stack();
+    for (i = 0; i < cmd->count; i++) {
+        if (cmd->state == DSI_CMD_SET_STATE_LP) cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
+
+        if (cmds->last_command) cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
+        DSI_MSG(cmds->msg, cmdset_list);
+        len = ops->transfer(panel->host, &cmds->msg);
+        if (len < 0) {
+            rc = len;
+            pr_err("failed to set cmds, rc=%d\n", rc);
+            goto error;
+        }
+        if (cmds->post_wait_ms) usleep_range(cmds->post_wait_ms * 1000, ((cmds->post_wait_ms * 1000) + 10));
+        cmds++;
+    }
 error:
 	return rc;
 }
@@ -2208,16 +2260,16 @@ static int dsi_panel_parse_phy_timing(struct dsi_display_mode *mode,
 		if (!priv_info->phy_timing_val)
 			return -EINVAL;
 
-		for (i = 0; i < len; i++)
-			priv_info->phy_timing_val[i] = data[i];
-
-		priv_info->phy_timing_len = len;
-	};
+        for (i = 0; i < len; i++) {
+            priv_info->phy_timing_val[i] = data[i];
+            pr_info("[RRR]-[qcom,mdss-dsi-panel-phy-timings]:%#x", data[i]);
+        }
+        priv_info->phy_timing_len = len;
+    };
 
-	mode->pixel_clk_khz = (mode->timing.h_active *
-			DSI_V_TOTAL(&mode->timing) *
-			mode->timing.refresh_rate) / 1000;
-	return rc;
+    mode->pixel_clk_khz = (mode->timing.h_active * DSI_V_TOTAL(&mode->timing) * mode->timing.refresh_rate) / 1000;
+    pr_info("[RRR]-[pixel_clk_khz]:%d khz\n", mode->pixel_clk_khz);
+    return rc;
 }
 
 static int dsi_panel_parse_dsc_params(struct dsi_display_mode *mode,
@@ -3159,25 +3211,6 @@ struct debugfs_cmdset_entry {
 	enum dsi_cmd_set_type type;
 };
 
-struct {
-	const char *label;
-	enum dsi_cmd_set_type type;
-} cmdset_list[] = {
-	{ "pre_on",		DSI_CMD_SET_PRE_ON },
-	{ "on",			DSI_CMD_SET_ON },
-	{ "post_on",		DSI_CMD_SET_POST_ON },
-	{ "pre_off",		DSI_CMD_SET_PRE_OFF },
-	{ "off",		DSI_CMD_SET_OFF },
-	{ "post_off",		DSI_CMD_SET_POST_OFF },
-	{ "panel_status",	DSI_CMD_SET_PANEL_STATUS },
-	{ "pps",		DSI_CMD_SET_PPS },
-	{ "lp1",		DSI_CMD_SET_LP1 },
-	{ "lp2",		DSI_CMD_SET_LP2 },
-	{ "no_lp",		DSI_CMD_SET_NOLP },
-	{ "vr",			DSI_CMD_SET_VR },
-	{ "novr",		DSI_CMD_SET_NOVR },
-};
-
 static inline ssize_t parse_cmdset(struct dsi_panel_cmd_set *set, char *buf,
 				   size_t count)
 {
diff --git a/drivers/gpu/drm/msm/dsi/dsi_host.c b/drivers/gpu/drm/msm/dsi/dsi_host.c
index 6f240021705b..55761fea230b 100644
--- a/drivers/gpu/drm/msm/dsi/dsi_host.c
+++ b/drivers/gpu/drm/msm/dsi/dsi_host.c
@@ -1516,8 +1516,8 @@ static ssize_t dsi_host_transfer(struct mipi_dsi_host *host,
 
 	if (!msg || !msm_host->power_on)
 		return -EINVAL;
-
-	mutex_lock(&msm_host->cmd_mutex);
+    dump_stack();
+    mutex_lock(&msm_host->cmd_mutex);
 	ret = msm_dsi_manager_cmd_xfer(msm_host->id, msg);
 	mutex_unlock(&msm_host->cmd_mutex);
 
diff --git a/drivers/gpu/drm/msm/msm_atomic.c b/drivers/gpu/drm/msm/msm_atomic.c
index 45348f826276..acb314e699af 100644
--- a/drivers/gpu/drm/msm/msm_atomic.c
+++ b/drivers/gpu/drm/msm/msm_atomic.c
@@ -74,6 +74,7 @@ EXPORT_SYMBOL_GPL(msm_drm_unregister_client);
  */
 int msm_drm_notifier_call_chain(unsigned long val, void *v)
 {
+	pr_info("drm:[%s] val:%lu\n", __func__, val);
 	return blocking_notifier_call_chain(&msm_drm_notifier_list, val,
 					    v);
 }
diff --git a/drivers/gpu/drm/msm/sde/sde_connector.c b/drivers/gpu/drm/msm/sde/sde_connector.c
index d99834472878..42ceb81f2036 100644
--- a/drivers/gpu/drm/msm/sde/sde_connector.c
+++ b/drivers/gpu/drm/msm/sde/sde_connector.c
@@ -1785,7 +1785,8 @@ static void sde_connector_check_status_work(struct work_struct *work)
 		mutex_unlock(&conn->lock);
 		return;
 	}
-
+	pr_info("drm[%s:%d] dpms_mode:%d\n", __FUNCTION__, __LINE__,
+		conn->dpms_mode);
 	rc = conn->ops.check_status(conn->display, false);
 	mutex_unlock(&conn->lock);
 
diff --git a/drivers/gpu/drm/msm/sde/sde_kms.c b/drivers/gpu/drm/msm/sde/sde_kms.c
index 05c57529d347..39d5c9056239 100644
--- a/drivers/gpu/drm/msm/sde/sde_kms.c
+++ b/drivers/gpu/drm/msm/sde/sde_kms.c
@@ -15,7 +15,7 @@
  * You should have received a copy of the GNU General Public License along with
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
-
+#define DEBUG
 #define pr_fmt(fmt)	"[drm:%s:%d] " fmt, __func__, __LINE__
 
 #include <drm/drm_crtc.h>
@@ -1156,8 +1156,8 @@ static void sde_kms_complete_commit(struct msm_kms *kms,
 	sde_power_resource_enable(&priv->phandle, sde_kms->core_client, false);
 
 	_sde_kms_release_splash_resource(sde_kms, old_state);
-
-	SDE_EVT32_VERBOSE(SDE_EVTLOG_FUNC_EXIT);
+    pr_info("%s[%d\n", __FUNCTION__, __LINE__);
+    SDE_EVT32_VERBOSE(SDE_EVTLOG_FUNC_EXIT);
 }
 
 static void sde_kms_wait_for_commit_done(struct msm_kms *kms,
diff --git a/drivers/gpu/drm/msm/sde/sde_kms.h b/drivers/gpu/drm/msm/sde/sde_kms.h
index 49171e5607e6..c70acd38d0b1 100644
--- a/drivers/gpu/drm/msm/sde/sde_kms.h
+++ b/drivers/gpu/drm/msm/sde/sde_kms.h
@@ -18,7 +18,7 @@
 
 #ifndef __SDE_KMS_H__
 #define __SDE_KMS_H__
-
+#define DEBUG
 #include <linux/msm_ion.h>
 #include <linux/pm_domain.h>
 #include <linux/pm_qos.h>
@@ -46,27 +46,27 @@
  * SDE_DEBUG - macro for kms/plane/crtc/encoder/connector logs
  * @fmt: Pointer to format string
  */
-#define SDE_DEBUG(fmt, ...)                                                \
-	do {                                                               \
-		if (unlikely(drm_debug & DRM_UT_KMS))                      \
-			DRM_DEBUG(fmt, ##__VA_ARGS__); \
-		else                                                       \
-			pr_debug(fmt, ##__VA_ARGS__);                      \
-	} while (0)
+#define SDE_DEBUG(fmt, ...)                                 \
+    do {                                                    \
+        if (unlikely(drm_debug & DRM_UT_KMS))               \
+            DRM_DEBUG("[RRR][drm sde]" fmt, ##__VA_ARGS__); \
+        else                                                \
+            pr_debug("[RRR][drm sde]" fmt, ##__VA_ARGS__);  \
+    } while (0)
 
 /**
  * SDE_DEBUG_DRIVER - macro for hardware driver logging
  * @fmt: Pointer to format string
  */
-#define SDE_DEBUG_DRIVER(fmt, ...)                                         \
-	do {                                                               \
-		if (unlikely(drm_debug & DRM_UT_DRIVER))                   \
-			DRM_ERROR(fmt, ##__VA_ARGS__); \
-		else                                                       \
-			pr_debug(fmt, ##__VA_ARGS__);                      \
-	} while (0)
+#define SDE_DEBUG_DRIVER(fmt, ...)                          \
+    do {                                                    \
+        if (unlikely(drm_debug & DRM_UT_DRIVER))            \
+            DRM_ERROR("[RRR][drm sde]" fmt, ##__VA_ARGS__); \
+        else                                                \
+            pr_debug("[RRR][drm sde]" fmt, ##__VA_ARGS__);  \
+    } while (0)
 
-#define SDE_ERROR(fmt, ...) pr_err("[sde error]" fmt, ##__VA_ARGS__)
+#define SDE_ERROR(fmt, ...) pr_err("[RRR][sde error]" fmt, ##__VA_ARGS__)
 
 #define POPULATE_RECT(rect, a, b, c, d, Q16_flag) \
 	do {						\
diff --git a/drivers/media/platform/msm/camera/cam_utils/cam_debug_util.h b/drivers/media/platform/msm/camera/cam_utils/cam_debug_util.h
index 4e97100bfb6a..f2d62cbd904c 100644
--- a/drivers/media/platform/msm/camera/cam_utils/cam_debug_util.h
+++ b/drivers/media/platform/msm/camera/cam_utils/cam_debug_util.h
@@ -82,9 +82,9 @@ const char *cam_get_module_name(unsigned int module_id);
  * @fmt      :  Formatted string which needs to be print in log
  * @args     :  Arguments which needs to be print in log
  */
-#define CAM_WARN(__module, fmt, args...)                           \
-	pr_warn("CAM_WARN: %s: %s: %d " fmt "\n",                     \
-		cam_get_module_name(__module), __func__,  __LINE__, ##args)
+#define CAM_WARN(__module, fmt, args...)                                       \
+	pr_err("CAM_WARN: %s: %s: %d " fmt "\n",                               \
+	       cam_get_module_name(__module), __func__, __LINE__, ##args)
 /*
  * CAM_INFO
  * @brief    :  This Macro will print Information logs
diff --git a/drivers/media/platform/msm/camera_v2/sensor/csid/msm_csid.c b/drivers/media/platform/msm/camera_v2/sensor/csid/msm_csid.c
index ba3252627b3b..0d32adb5d203 100644
--- a/drivers/media/platform/msm/camera_v2/sensor/csid/msm_csid.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/csid/msm_csid.c
@@ -64,7 +64,7 @@
 #define CSID_TIMEOUT msecs_to_jiffies(100)
 
 #undef CDBG
-#define CDBG(fmt, args...) pr_debug(fmt, ##args)
+#define CDBG(fmt, args...) pr_err(fmt, ##args)
 
 static struct camera_vreg_t csid_vreg_info[] = {
 	{"qcom,mipi-csi-vdd", 0, 0, 12000},
diff --git a/drivers/video/fbdev/msm/mdss_dsi_panel.c b/drivers/video/fbdev/msm/mdss_dsi_panel.c
index 7f0359288e48..fd951137a0d0 100644
--- a/drivers/video/fbdev/msm/mdss_dsi_panel.c
+++ b/drivers/video/fbdev/msm/mdss_dsi_panel.c
@@ -9,7 +9,7 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
-
+#define pr_fmt(fmt) "msm-dsi-panel:[%s:%d] " fmt, __func__, __LINE__
 #include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/of.h>
diff --git a/include/drm/drm_mipi_dsi.h b/include/drm/drm_mipi_dsi.h
index b208412dd52d..2c83db5095c7 100644
--- a/include/drm/drm_mipi_dsi.h
+++ b/include/drm/drm_mipi_dsi.h
@@ -13,7 +13,6 @@
 #define __DRM_MIPI_DSI_H__
 
 #include <linux/device.h>
-
 struct mipi_dsi_host;
 struct mipi_dsi_device;
 
