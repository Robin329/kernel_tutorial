diff --git a/build.sh b/build.sh
index 2222460fc1..0aa75fda2b 100755
--- a/build.sh
+++ b/build.sh
@@ -1,219 +1,3 @@
-#!/bin/bash
-usage()
-{
-   echo "USAGE: [-U] [-CK] [-A] [-p] [-o] [-u] [-v VERSION_NAME]  "
-    echo "No ARGS means use default build option                  "
-    echo "WHERE: -U = build uboot                                 "
-    echo "       -C = build kernel with Clang                     "
-    echo "       -K = build kernel                                "
-    echo "       -A = build android                               "
-    echo "       -p = will build packaging in IMAGE      "
-    echo "       -o = build OTA package                           "
-    echo "       -u = build update.img                            "
-    echo "       -v = build android with 'user' or 'userdebug'    "
-    echo "       -d = huild kernel dts name    "
-    echo "       -V = build version    "
-    echo "       -J = build jobs    "
-    exit 1
-}
-BUILD_UBOOT=false
-BUILD_KERNEL_WITH_CLANG=false
-BUILD_KERNEL=false
-BUILD_ANDROID=false
-BUILD_UPDATE_IMG=false
-BUILD_OTA=false
-BUILD_PACKING=false
-BUILD_VARIANT=userdebug
-KERNEL_DTS=""
-BUILD_VERSION=""
-BUILD_JOBS=16
-
-# check pass argument
-while getopts "UCKApouv:d:V:J:" arg
-do
-    case $arg in
-        U)
-            echo "will build u-boot"
-            BUILD_UBOOT=true
-            ;;
-        C)
-            echo "will build kernel with Clang"
-            BUILD_KERNEL_WITH_CLANG=true
-            ;;
-        K)
-            echo "will build kernel"
-            BUILD_KERNEL=true
-            ;;
-        A)
-            echo "will build android"
-            BUILD_ANDROID=true
-            ;;
-        p)
-            echo "will build packaging in IMAGE"
-            BUILD_PACKING=true
-            ;;
-        o)
-            echo "will build ota package"
-            BUILD_OTA=true
-            ;;
-        u)
-            echo "will build update.img"
-            BUILD_UPDATE_IMG=true
-            ;;
-        v)
-            BUILD_VARIANT=$OPTARG
-            ;;
-        V)
-            BUILD_VERSION=$OPTARG
-            ;;
-        d)
-            KERNEL_DTS=$OPTARG
-            ;;
-        J)
-            BUILD_JOBS=$OPTARG
-            ;;
-        ?)
-            usage ;;
-    esac
-done
-
-
-source build/envsetup.sh >/dev/null
-TARGET_PRODUCT=`get_build_var TARGET_PRODUCT`
-TARGET_BOARD_PLATFORM=`get_build_var TARGET_BOARD_PLATFORM`
-
-#set jdk version
-export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
-export PATH=$JAVA_HOME/bin:$PATH
-export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/lib/tools.jar
-# source environment and chose target product
-BUILD_NUMBER=`get_build_var BUILD_NUMBER`
-BUILD_ID=`get_build_var BUILD_ID`
-# only save the version code
-SDK_VERSION=`get_build_var CURRENT_SDK_VERSION`
-UBOOT_DEFCONFIG=`get_build_var PRODUCT_UBOOT_CONFIG`
-KERNEL_ARCH=`get_build_var PRODUCT_KERNEL_ARCH`
-KERNEL_DEFCONFIG=`get_build_var PRODUCT_KERNEL_CONFIG`
-if [ "$KERNEL_DTS" = "" ] ; then
-KERNEL_DTS=`get_build_var PRODUCT_KERNEL_DTS`
-fi
-echo "-------------------KERNEL_DTS:$KERNEL_DTS"
-PACK_TOOL_DIR=RKTools/linux/Linux_Pack_Firmware
-IMAGE_PATH=rockdev/Image-$TARGET_PRODUCT
-export PROJECT_TOP=`gettop`
-
-lunch $TARGET_PRODUCT-$BUILD_VARIANT
-
-DATE=$(date  +%Y%m%d.%H%M)
-STUB_PATH=Image/"$TARGET_PRODUCT"_"$BUILD_VARIANT"_"$BUILD_VERSION"_"$DATE"
-STUB_PATH="$(echo $STUB_PATH | tr '[:lower:]' '[:upper:]')"
-export STUB_PATH=$PROJECT_TOP/$STUB_PATH
-export STUB_PATCH_PATH=$STUB_PATH/PATCHES
-
-# build uboot
-if [ "$BUILD_UBOOT" = true ] ; then
-echo "start build uboot"
-cd u-boot && make clean &&  make mrproper &&  make distclean && ./make.sh $UBOOT_DEFCONFIG && cd -
-if [ $? -eq 0 ]; then
-    echo "Build uboot ok!"
-else
-    echo "Build uboot failed!"
-    exit 1
-fi
-fi
-
-if [ "$BUILD_KERNEL_WITH_CLANG" = true ] ; then
-ADDON_ARGS="CC=../prebuilts/clang/host/linux-x86/clang-r353983c/bin/clang"
-fi
-# build kernel
-if [ "$BUILD_KERNEL" = true ] ; then
-echo "Start build kernel"
-cd kernel && make clean && make $ADDON_ARGS ARCH=$KERNEL_ARCH $KERNEL_DEFCONFIG && make $ADDON_ARGS ARCH=$KERNEL_ARCH $KERNEL_DTS.img -j$BUILD_JOBS && cd -
-if [ $? -eq 0 ]; then
-    echo "Build kernel ok!"
-else
-    echo "Build kernel failed!"
-    exit 1
-fi
-fi
-
-echo "package resoure.img with charger images"
-cd u-boot && ./scripts/pack_resource.sh ../kernel/resource.img && cp resource.img ../kernel/resource.img && cd -
-
-# build android
-if [ "$BUILD_ANDROID" = true ] ; then
-echo "start build android"
-make installclean
-make -j$BUILD_JOBS
-if [ $? -eq 0 ]; then
-    echo "Build android ok!"
-else
-    echo "Build android failed!"
-    exit 1
-fi
-fi
-
-# mkimage.sh
-echo "make and copy android images"
-./mkimage.sh
-if [ $? -eq 0 ]; then
-    echo "Make image ok!"
-else
-    echo "Make image failed!"
-    exit 1
-fi
-
-if [ "$BUILD_OTA" = true ] ; then
-    INTERNAL_OTA_PACKAGE_OBJ_TARGET=obj/PACKAGING/target_files_intermediates/$TARGET_PRODUCT-target_files-*.zip
-    INTERNAL_OTA_PACKAGE_TARGET=$TARGET_PRODUCT-ota-*.zip
-    echo "generate ota package"
-    make otapackage -j$BUILD_JOBS
-    ./mkimage.sh ota
-    cp $OUT/$INTERNAL_OTA_PACKAGE_TARGET $IMAGE_PATH/
-    cp $OUT/$INTERNAL_OTA_PACKAGE_OBJ_TARGET $IMAGE_PATH/
-fi
-
-
-if [ "$BUILD_UPDATE_IMG" = true ] ; then
-    mkdir -p $PACK_TOOL_DIR/rockdev/Image/
-    cp -f $IMAGE_PATH/* $PACK_TOOL_DIR/rockdev/Image/
-
-    echo "Make update.img"
-    cd $PACK_TOOL_DIR/rockdev && ./mkupdate_$TARGET_BOARD_PLATFORM.sh
-    if [ $? -eq 0 ]; then
-        echo "Make update image ok!"
-    else
-        echo "Make update image failed!"
-        exit 1
-    fi
-    cd -
-    mv $PACK_TOOL_DIR/rockdev/update.img $IMAGE_PATH/ -f
-    rm $PACK_TOOL_DIR/rockdev/Image -rf
-fi
-
-if [ "$BUILD_PACKING" = true ] ; then
-echo "make and copy packaging in IMAGE "
-
-mkdir -p $STUB_PATH
-
-#Generate patches
-
-.repo/repo/repo forall  -c "$PROJECT_TOP/device/rockchip/common/gen_patches_body.sh"
-
-#Copy stubs
-cp out/commit_id.xml $STUB_PATH/manifest_${DATE}.xml
-
-mkdir -p $STUB_PATCH_PATH/kernel
-cp kernel/.config $STUB_PATCH_PATH/kernel
-cp kernel/vmlinux $STUB_PATCH_PATH/kernel
-
-mkdir -p $STUB_PATH/IMAGES/
-cp $IMAGE_PATH/* $STUB_PATH/IMAGES/
-cp build.sh $STUB_PATH/build.sh
-#Save build command info
-echo "uboot:   ./make.sh $UBOOT_DEFCONFIG"                                                           >> $STUB_PATH/build_cmd_info.txt
-echo "kernel:  make ARCH=$KERNEL_ARCH $KERNEL_DEFCONFIG && make ARCH=$KERNEL_ARCH $KERNEL_DTS.img"   >> $STUB_PATH/build_cmd_info.txt
-echo "android: lunch $TARGET_PRODUCT-$BUILD_VARIANT && make installclean && make"                    >> $STUB_PATH/build_cmd_info.txt
-echo "version: $SDK_VERSION"                                                                         >> $STUB_PATH/build_cmd_info.txt
-echo "finger:  $BUILD_ID/$BUILD_NUMBER/$BUILD_VARIANT"                                               >> $STUB_PATH/build_cmd_info.txt
-fi
+version https://git-lfs.github.com/spec/v1
+oid sha256:22d9a17b2939093e31f07777a4760332dcc73df4831126e40f938994d1255ed7
+size 6476
diff --git a/build/make/tools/releasetools/build_image.py b/build/make/tools/releasetools/build_image.py
index 4136ed432e..bdea819e87 100755
--- a/build/make/tools/releasetools/build_image.py
+++ b/build/make/tools/releasetools/build_image.py
@@ -1,791 +1,3 @@
-#!/usr/bin/env python
-#
-# Copyright (C) 2011 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-"""
-Builds output_image from the given input_directory, properties_file,
-and writes the image to target_output_directory.
-
-Usage:  build_image.py input_directory properties_file output_image \\
-            target_output_directory
-"""
-
-from __future__ import print_function
-
-import logging
-import os
-import os.path
-import re
-import shutil
-import sys
-
-import common
-import verity_utils
-
-logger = logging.getLogger(__name__)
-
-OPTIONS = common.OPTIONS
-BLOCK_SIZE = common.BLOCK_SIZE
-BYTES_IN_MB = 1024 * 1024
-
-
-class BuildImageError(Exception):
-  """An Exception raised during image building."""
-
-  def __init__(self, message):
-    Exception.__init__(self, message)
-
-
-def GetDiskUsage(path):
-  """Returns the number of bytes that "path" occupies on host.
-
-  Args:
-    path: The directory or file to calculate size on.
-
-  Returns:
-    The number of bytes based on a 1K block_size.
-  """
-  cmd = ["du", "-k", "-s", path]
-  output = common.RunAndCheckOutput(cmd, verbose=False)
-  return int(output.split()[0]) * 1024
-
-
-def GetInodeUsage(path):
-  """Returns the number of inodes that "path" occupies on host.
-
-  Args:
-    path: The directory or file to calculate inode number on.
-
-  Returns:
-    The number of inodes used.
-  """
-  cmd = ["find", path, "-print"]
-  output = common.RunAndCheckOutput(cmd, verbose=False)
-  # increase by > 4% as number of files and directories is not whole picture.
-  inodes = output.count('\n')
-  spare_inodes = inodes * 4 // 100
-  min_spare_inodes = 12
-  if spare_inodes < min_spare_inodes:
-    spare_inodes = min_spare_inodes
-  return inodes + spare_inodes
-
-
-def GetFilesystemCharacteristics(image_path, sparse_image=True):
-  """Returns various filesystem characteristics of "image_path".
-
-  Args:
-    image_path: The file to analyze.
-    sparse_image: Image is sparse
-
-  Returns:
-    The characteristics dictionary.
-  """
-  unsparse_image_path = image_path
-  if sparse_image:
-    unsparse_image_path = UnsparseImage(image_path, replace=False)
-
-  cmd = ["tune2fs", "-l", unsparse_image_path]
-  try:
-    output = common.RunAndCheckOutput(cmd, verbose=False)
-  finally:
-    if sparse_image:
-      os.remove(unsparse_image_path)
-  fs_dict = {}
-  for line in output.splitlines():
-    fields = line.split(":")
-    if len(fields) == 2:
-      fs_dict[fields[0].strip()] = fields[1].strip()
-  return fs_dict
-
-
-def UnsparseImage(sparse_image_path, replace=True):
-  img_dir = os.path.dirname(sparse_image_path)
-  unsparse_image_path = "unsparse_" + os.path.basename(sparse_image_path)
-  unsparse_image_path = os.path.join(img_dir, unsparse_image_path)
-  if os.path.exists(unsparse_image_path):
-    if replace:
-      os.unlink(unsparse_image_path)
-    else:
-      return unsparse_image_path
-  inflate_command = ["simg2img", sparse_image_path, unsparse_image_path]
-  try:
-    common.RunAndCheckOutput(inflate_command)
-  except:
-    os.remove(unsparse_image_path)
-    raise
-  return unsparse_image_path
-
-
-def ConvertBlockMapToBaseFs(block_map_file):
-  base_fs_file = common.MakeTempFile(prefix="script_gen_", suffix=".base_fs")
-  convert_command = ["blk_alloc_to_base_fs", block_map_file, base_fs_file]
-  common.RunAndCheckOutput(convert_command)
-  return base_fs_file
-
-
-def SetUpInDirAndFsConfig(origin_in, prop_dict):
-  """Returns the in_dir and fs_config that should be used for image building.
-
-  When building system.img for all targets, it creates and returns a staged dir
-  that combines the contents of /system (i.e. in the given in_dir) and root.
-
-  Args:
-    origin_in: Path to the input directory.
-    prop_dict: A property dict that contains info like partition size. Values
-        may be updated.
-
-  Returns:
-    A tuple of in_dir and fs_config that should be used to build the image.
-  """
-  fs_config = prop_dict.get("fs_config")
-
-  if prop_dict["mount_point"] == "system_other":
-    prop_dict["mount_point"] = "system"
-    return origin_in, fs_config
-
-  if prop_dict["mount_point"] != "system":
-    return origin_in, fs_config
-
-  if "first_pass" in prop_dict:
-    prop_dict["mount_point"] = "/"
-    return prop_dict["first_pass"]
-
-  # Construct a staging directory of the root file system.
-  in_dir = common.MakeTempDir()
-  root_dir = prop_dict.get("root_dir")
-  if root_dir:
-    shutil.rmtree(in_dir)
-    shutil.copytree(root_dir, in_dir, symlinks=True)
-  in_dir_system = os.path.join(in_dir, "system")
-  shutil.rmtree(in_dir_system, ignore_errors=True)
-  shutil.copytree(origin_in, in_dir_system, symlinks=True)
-
-  # Change the mount point to "/".
-  prop_dict["mount_point"] = "/"
-  if fs_config:
-    # We need to merge the fs_config files of system and root.
-    merged_fs_config = common.MakeTempFile(
-        prefix="merged_fs_config", suffix=".txt")
-    with open(merged_fs_config, "w") as fw:
-      if "root_fs_config" in prop_dict:
-        with open(prop_dict["root_fs_config"]) as fr:
-          fw.writelines(fr.readlines())
-      with open(fs_config) as fr:
-        fw.writelines(fr.readlines())
-    fs_config = merged_fs_config
-  prop_dict["first_pass"] = (in_dir, fs_config)
-  return in_dir, fs_config
-
-
-def CheckHeadroom(ext4fs_output, prop_dict):
-  """Checks if there's enough headroom space available.
-
-  Headroom is the reserved space on system image (via PRODUCT_SYSTEM_HEADROOM),
-  which is useful for devices with low disk space that have system image
-  variation between builds. The 'partition_headroom' in prop_dict is the size
-  in bytes, while the numbers in 'ext4fs_output' are for 4K-blocks.
-
-  Args:
-    ext4fs_output: The output string from mke2fs command.
-    prop_dict: The property dict.
-
-  Raises:
-    AssertionError: On invalid input.
-    BuildImageError: On check failure.
-  """
-  assert ext4fs_output is not None
-  assert prop_dict.get('fs_type', '').startswith('ext4')
-  assert 'partition_headroom' in prop_dict
-  assert 'mount_point' in prop_dict
-
-  ext4fs_stats = re.compile(
-      r'Created filesystem with .* (?P<used_blocks>[0-9]+)/'
-      r'(?P<total_blocks>[0-9]+) blocks')
-  last_line = ext4fs_output.strip().split('\n')[-1]
-  m = ext4fs_stats.match(last_line)
-  used_blocks = int(m.groupdict().get('used_blocks'))
-  total_blocks = int(m.groupdict().get('total_blocks'))
-  headroom_blocks = int(prop_dict['partition_headroom']) // BLOCK_SIZE
-  adjusted_blocks = total_blocks - headroom_blocks
-  if used_blocks > adjusted_blocks:
-    mount_point = prop_dict["mount_point"]
-    raise BuildImageError(
-        "Error: Not enough room on {} (total: {} blocks, used: {} blocks, "
-        "headroom: {} blocks, available: {} blocks)".format(
-            mount_point, total_blocks, used_blocks, headroom_blocks,
-            adjusted_blocks))
-
-
-def BuildImageMkfs(in_dir, prop_dict, out_file, target_out, fs_config):
-  """Builds a pure image for the files under in_dir and writes it to out_file.
-
-  Args:
-    in_dir: Path to input directory.
-    prop_dict: A property dict that contains info like partition size. Values
-        will be updated with computed values.
-    out_file: The output image file.
-    target_out: Path to the TARGET_OUT directory as in Makefile. It actually
-        points to the /system directory under PRODUCT_OUT. fs_config (the one
-        under system/core/libcutils) reads device specific FS config files from
-        there.
-    fs_config: The fs_config file that drives the prototype
-
-  Raises:
-    BuildImageError: On build image failures.
-  """
-  build_command = []
-  fs_type = prop_dict.get("fs_type", "")
-  run_e2fsck = False
-
-  if fs_type.startswith("ext"):
-    build_command = [prop_dict["ext_mkuserimg"]]
-    if "extfs_sparse_flag" in prop_dict:
-      build_command.append(prop_dict["extfs_sparse_flag"])
-      run_e2fsck = True
-    build_command.extend([in_dir, out_file, fs_type,
-                          prop_dict["mount_point"]])
-    build_command.append(prop_dict["image_size"])
-    if "journal_size" in prop_dict:
-      build_command.extend(["-j", prop_dict["journal_size"]])
-    if "timestamp" in prop_dict:
-      build_command.extend(["-T", str(prop_dict["timestamp"])])
-    if fs_config:
-      build_command.extend(["-C", fs_config])
-    if target_out:
-      build_command.extend(["-D", target_out])
-    if "block_list" in prop_dict:
-      build_command.extend(["-B", prop_dict["block_list"]])
-    if "base_fs_file" in prop_dict:
-      base_fs_file = ConvertBlockMapToBaseFs(prop_dict["base_fs_file"])
-      build_command.extend(["-d", base_fs_file])
-    build_command.extend(["-L", prop_dict["mount_point"]])
-    if "extfs_inode_count" in prop_dict:
-      build_command.extend(["-i", prop_dict["extfs_inode_count"]])
-    if "extfs_rsv_pct" in prop_dict:
-      build_command.extend(["-M", prop_dict["extfs_rsv_pct"]])
-    if "flash_erase_block_size" in prop_dict:
-      build_command.extend(["-e", prop_dict["flash_erase_block_size"]])
-    if "flash_logical_block_size" in prop_dict:
-      build_command.extend(["-o", prop_dict["flash_logical_block_size"]])
-    # Specify UUID and hash_seed if using mke2fs.
-    if prop_dict["ext_mkuserimg"] == "mkuserimg_mke2fs":
-      if "uuid" in prop_dict:
-        build_command.extend(["-U", prop_dict["uuid"]])
-      if "hash_seed" in prop_dict:
-        build_command.extend(["-S", prop_dict["hash_seed"]])
-    if "ext4_share_dup_blocks" in prop_dict:
-      build_command.append("-c")
-    build_command.extend(["--inode_size", "256"])
-    if "selinux_fc" in prop_dict:
-      build_command.append(prop_dict["selinux_fc"])
-  elif fs_type.startswith("squash"):
-    build_command = ["mksquashfsimage.sh"]
-    build_command.extend([in_dir, out_file])
-    if "squashfs_sparse_flag" in prop_dict:
-      build_command.extend([prop_dict["squashfs_sparse_flag"]])
-    build_command.extend(["-m", prop_dict["mount_point"]])
-    if target_out:
-      build_command.extend(["-d", target_out])
-    if fs_config:
-      build_command.extend(["-C", fs_config])
-    if "selinux_fc" in prop_dict:
-      build_command.extend(["-c", prop_dict["selinux_fc"]])
-    if "block_list" in prop_dict:
-      build_command.extend(["-B", prop_dict["block_list"]])
-    if "squashfs_block_size" in prop_dict:
-      build_command.extend(["-b", prop_dict["squashfs_block_size"]])
-    if "squashfs_compressor" in prop_dict:
-      build_command.extend(["-z", prop_dict["squashfs_compressor"]])
-    if "squashfs_compressor_opt" in prop_dict:
-      build_command.extend(["-zo", prop_dict["squashfs_compressor_opt"]])
-    if prop_dict.get("squashfs_disable_4k_align") == "true":
-      build_command.extend(["-a"])
-  elif fs_type.startswith("f2fs"):
-    build_command = ["mkf2fsuserimg.sh"]
-    build_command.extend([out_file, prop_dict["image_size"]])
-    if fs_config:
-      build_command.extend(["-C", fs_config])
-    build_command.extend(["-f", in_dir])
-    if target_out:
-      build_command.extend(["-D", target_out])
-    if "selinux_fc" in prop_dict:
-      build_command.extend(["-s", prop_dict["selinux_fc"]])
-    build_command.extend(["-t", prop_dict["mount_point"]])
-    if "timestamp" in prop_dict:
-      build_command.extend(["-T", str(prop_dict["timestamp"])])
-    build_command.extend(["-L", prop_dict["mount_point"]])
-  else:
-    raise BuildImageError(
-        "Error: unknown filesystem type: {}".format(fs_type))
-
-  try:
-    mkfs_output = common.RunAndCheckOutput(build_command)
-  except:
-    try:
-      du = GetDiskUsage(in_dir)
-      du_str = "{} bytes ({} MB)".format(du, du // BYTES_IN_MB)
-    # Suppress any errors from GetDiskUsage() to avoid hiding the real errors
-    # from common.RunAndCheckOutput().
-    except Exception:  # pylint: disable=broad-except
-      logger.exception("Failed to compute disk usage with du")
-      du_str = "unknown"
-    print(
-        "Out of space? Out of inodes? The tree size of {} is {}, "
-        "with reserved space of {} bytes ({} MB).".format(
-            in_dir, du_str,
-            int(prop_dict.get("partition_reserved_size", 0)),
-            int(prop_dict.get("partition_reserved_size", 0)) // BYTES_IN_MB))
-    print(
-        "The max image size for filesystem files is {} bytes ({} MB), out of a "
-        "total partition size of {} bytes ({} MB).".format(
-            int(prop_dict["image_size"]),
-            int(prop_dict["image_size"]) // BYTES_IN_MB,
-            int(prop_dict["partition_size"]),
-            int(prop_dict["partition_size"]) // BYTES_IN_MB))
-    raise
-
-  if run_e2fsck and prop_dict.get("skip_fsck") != "true":
-    unsparse_image = UnsparseImage(out_file, replace=False)
-
-    # Run e2fsck on the inflated image file
-    e2fsck_command = ["e2fsck", "-f", "-n", unsparse_image]
-    try:
-      common.RunAndCheckOutput(e2fsck_command)
-    finally:
-      os.remove(unsparse_image)
-
-  return mkfs_output
-
-
-def BuildImage(in_dir, prop_dict, out_file, target_out=None):
-  """Builds an image for the files under in_dir and writes it to out_file.
-
-  Args:
-    in_dir: Path to input directory.
-    prop_dict: A property dict that contains info like partition size. Values
-        will be updated with computed values.
-    out_file: The output image file.
-    target_out: Path to the TARGET_OUT directory as in Makefile. It actually
-        points to the /system directory under PRODUCT_OUT. fs_config (the one
-        under system/core/libcutils) reads device specific FS config files from
-        there.
-
-  Raises:
-    BuildImageError: On build image failures.
-  """
-  in_dir, fs_config = SetUpInDirAndFsConfig(in_dir, prop_dict)
-
-  build_command = []
-  fs_type = prop_dict.get("fs_type", "")
-
-  fs_spans_partition = True
-  if fs_type.startswith("squash"):
-    fs_spans_partition = False
-
-  # Get a builder for creating an image that's to be verified by Verified Boot,
-  # or None if not applicable.
-  verity_image_builder = verity_utils.CreateVerityImageBuilder(prop_dict)
-
-  if (prop_dict.get("use_dynamic_partition_size") == "true" and
-      "partition_size" not in prop_dict):
-    # If partition_size is not defined, use output of `du' + reserved_size.
-    size = GetDiskUsage(in_dir)
-    logger.info(
-        "The tree size of %s is %d MB.", in_dir, size // BYTES_IN_MB)
-    # If not specified, give us 16MB margin for GetDiskUsage error ...
-    reserved_size = int(prop_dict.get("partition_reserved_size", BYTES_IN_MB * 16))
-    partition_headroom = int(prop_dict.get("partition_headroom", 0))
-    if fs_type.startswith("ext4") and partition_headroom > reserved_size:
-      reserved_size = partition_headroom
-    size += reserved_size
-    # Round this up to a multiple of 4K so that avbtool works
-    size = common.RoundUpTo4K(size)
-    if fs_type.startswith("ext"):
-      prop_dict["partition_size"] = str(size)
-      prop_dict["image_size"] = str(size)
-      if "extfs_inode_count" not in prop_dict:
-        prop_dict["extfs_inode_count"] = str(GetInodeUsage(in_dir))
-      logger.info(
-          "First Pass based on estimates of %d MB and %s inodes.",
-          size // BYTES_IN_MB, prop_dict["extfs_inode_count"])
-      BuildImageMkfs(in_dir, prop_dict, out_file, target_out, fs_config)
-      sparse_image = False
-      if "extfs_sparse_flag" in prop_dict:
-        sparse_image = True
-      fs_dict = GetFilesystemCharacteristics(out_file, sparse_image)
-      os.remove(out_file)
-      block_size = int(fs_dict.get("Block size", "4096"))
-      free_size = int(fs_dict.get("Free blocks", "0")) * block_size
-      reserved_size = int(prop_dict.get("partition_reserved_size", 0))
-      partition_headroom = int(fs_dict.get("partition_headroom", 0))
-      if fs_type.startswith("ext4") and partition_headroom > reserved_size:
-        reserved_size = partition_headroom
-      if free_size <= reserved_size:
-        logger.info(
-            "Not worth reducing image %d <= %d.", free_size, reserved_size)
-      else:
-        size -= free_size
-        size += reserved_size
-        if reserved_size == 0:
-          # add .3% margin
-          size = size * 1003 // 1000
-        # Use a minimum size, otherwise we will fail to calculate an AVB footer
-        # or fail to construct an ext4 image.
-        size = max(size, 256 * 1024)
-        if block_size <= 4096:
-          size = common.RoundUpTo4K(size)
-        else:
-          size = ((size + block_size - 1) // block_size) * block_size
-      extfs_inode_count = prop_dict["extfs_inode_count"]
-      inodes = int(fs_dict.get("Inode count", extfs_inode_count))
-      inodes -= int(fs_dict.get("Free inodes", "0"))
-      # add .2% margin or 1 inode, whichever is greater
-      spare_inodes = inodes * 2 // 1000
-      min_spare_inodes = 1
-      if spare_inodes < min_spare_inodes:
-        spare_inodes = min_spare_inodes
-      inodes += spare_inodes
-      prop_dict["extfs_inode_count"] = str(inodes)
-      prop_dict["partition_size"] = str(size)
-      logger.info(
-          "Allocating %d Inodes for %s.", inodes, out_file)
-    if verity_image_builder:
-      size = verity_image_builder.CalculateDynamicPartitionSize(size)
-    prop_dict["partition_size"] = str(size)
-    logger.info(
-        "Allocating %d MB for %s.", size // BYTES_IN_MB, out_file)
-
-  prop_dict["image_size"] = prop_dict["partition_size"]
-
-  # Adjust the image size to make room for the hashes if this is to be verified.
-  if verity_image_builder:
-    max_image_size = verity_image_builder.CalculateMaxImageSize()
-    prop_dict["image_size"] = str(max_image_size)
-
-  mkfs_output = BuildImageMkfs(in_dir, prop_dict, out_file, target_out, fs_config)
-
-  # Check if there's enough headroom space available for ext4 image.
-  if "partition_headroom" in prop_dict and fs_type.startswith("ext4"):
-    CheckHeadroom(mkfs_output, prop_dict)
-
-  if not fs_spans_partition and verity_image_builder:
-    verity_image_builder.PadSparseImage(out_file)
-
-  # Create the verified image if this is to be verified.
-  if verity_image_builder:
-    verity_image_builder.Build(out_file)
-
-
-def ImagePropFromGlobalDict(glob_dict, mount_point):
-  """Build an image property dictionary from the global dictionary.
-
-  Args:
-    glob_dict: the global dictionary from the build system.
-    mount_point: such as "system", "data" etc.
-  """
-  d = {}
-
-  if "build.prop" in glob_dict:
-    bp = glob_dict["build.prop"]
-    if "ro.build.date.utc" in bp:
-      d["timestamp"] = bp["ro.build.date.utc"]
-
-  def copy_prop(src_p, dest_p):
-    """Copy a property from the global dictionary.
-
-    Args:
-      src_p: The source property in the global dictionary.
-      dest_p: The destination property.
-    Returns:
-      True if property was found and copied, False otherwise.
-    """
-    if src_p in glob_dict:
-      d[dest_p] = str(glob_dict[src_p])
-      return True
-    return False
-
-  common_props = (
-      "extfs_sparse_flag",
-      "squashfs_sparse_flag",
-      "selinux_fc",
-      "skip_fsck",
-      "ext_mkuserimg",
-      "verity",
-      "verity_key",
-      "verity_signer_cmd",
-      "verity_fec",
-      "verity_disable",
-      "avb_enable",
-      "avb_avbtool",
-      "avb_salt",
-      "use_dynamic_partition_size",
-  )
-  for p in common_props:
-    copy_prop(p, p)
-
-  d["mount_point"] = mount_point
-  if mount_point == "system":
-    copy_prop("avb_system_hashtree_enable", "avb_hashtree_enable")
-    copy_prop("avb_system_add_hashtree_footer_args",
-              "avb_add_hashtree_footer_args")
-    copy_prop("avb_system_key_path", "avb_key_path")
-    copy_prop("avb_system_algorithm", "avb_algorithm")
-    copy_prop("fs_type", "fs_type")
-    # Copy the generic system fs type first, override with specific one if
-    # available.
-    copy_prop("system_fs_type", "fs_type")
-    copy_prop("system_headroom", "partition_headroom")
-    copy_prop("system_size", "partition_size")
-    if not copy_prop("system_journal_size", "journal_size"):
-      d["journal_size"] = "0"
-    copy_prop("system_verity_block_device", "verity_block_device")
-    copy_prop("system_root_image", "system_root_image")
-    copy_prop("root_dir", "root_dir")
-    copy_prop("root_fs_config", "root_fs_config")
-    copy_prop("ext4_share_dup_blocks", "ext4_share_dup_blocks")
-    copy_prop("system_squashfs_compressor", "squashfs_compressor")
-    copy_prop("system_squashfs_compressor_opt", "squashfs_compressor_opt")
-    copy_prop("system_squashfs_block_size", "squashfs_block_size")
-    copy_prop("system_squashfs_disable_4k_align", "squashfs_disable_4k_align")
-    copy_prop("system_base_fs_file", "base_fs_file")
-    copy_prop("system_extfs_inode_count", "extfs_inode_count")
-    if not copy_prop("system_extfs_rsv_pct", "extfs_rsv_pct"):
-      d["extfs_rsv_pct"] = "0"
-    copy_prop("system_reserved_size", "partition_reserved_size")
-  elif mount_point == "system_other":
-    # We inherit the selinux policies of /system since we contain some of its
-    # files.
-    copy_prop("avb_system_other_hashtree_enable", "avb_hashtree_enable")
-    copy_prop("avb_system_other_add_hashtree_footer_args",
-              "avb_add_hashtree_footer_args")
-    copy_prop("avb_system_other_key_path", "avb_key_path")
-    copy_prop("avb_system_other_algorithm", "avb_algorithm")
-    copy_prop("fs_type", "fs_type")
-    copy_prop("system_fs_type", "fs_type")
-    copy_prop("system_other_size", "partition_size")
-    if not copy_prop("system_journal_size", "journal_size"):
-      d["journal_size"] = "0"
-    copy_prop("system_verity_block_device", "verity_block_device")
-    copy_prop("ext4_share_dup_blocks", "ext4_share_dup_blocks")
-    copy_prop("system_squashfs_compressor", "squashfs_compressor")
-    copy_prop("system_squashfs_compressor_opt", "squashfs_compressor_opt")
-    copy_prop("system_squashfs_block_size", "squashfs_block_size")
-    copy_prop("system_base_fs_file", "base_fs_file")
-    copy_prop("system_extfs_inode_count", "extfs_inode_count")
-    if not copy_prop("system_extfs_rsv_pct", "extfs_rsv_pct"):
-      d["extfs_rsv_pct"] = "0"
-    copy_prop("system_reserved_size", "partition_reserved_size")
-  elif mount_point == "data":
-    # Copy the generic fs type first, override with specific one if available.
-    copy_prop("fs_type", "fs_type")
-    copy_prop("userdata_fs_type", "fs_type")
-    copy_prop("userdata_size", "partition_size")
-    copy_prop("flash_logical_block_size", "flash_logical_block_size")
-    copy_prop("flash_erase_block_size", "flash_erase_block_size")
-  elif mount_point == "cache":
-    copy_prop("cache_fs_type", "fs_type")
-    copy_prop("cache_size", "partition_size")
-  elif mount_point == "vendor":
-    copy_prop("avb_vendor_hashtree_enable", "avb_hashtree_enable")
-    copy_prop("avb_vendor_add_hashtree_footer_args",
-              "avb_add_hashtree_footer_args")
-    copy_prop("avb_vendor_key_path", "avb_key_path")
-    copy_prop("avb_vendor_algorithm", "avb_algorithm")
-    copy_prop("vendor_fs_type", "fs_type")
-    copy_prop("vendor_size", "partition_size")
-    if not copy_prop("vendor_journal_size", "journal_size"):
-      d["journal_size"] = "0"
-    copy_prop("vendor_verity_block_device", "verity_block_device")
-    copy_prop("ext4_share_dup_blocks", "ext4_share_dup_blocks")
-    copy_prop("vendor_squashfs_compressor", "squashfs_compressor")
-    copy_prop("vendor_squashfs_compressor_opt", "squashfs_compressor_opt")
-    copy_prop("vendor_squashfs_block_size", "squashfs_block_size")
-    copy_prop("vendor_squashfs_disable_4k_align", "squashfs_disable_4k_align")
-    copy_prop("vendor_base_fs_file", "base_fs_file")
-    copy_prop("vendor_extfs_inode_count", "extfs_inode_count")
-    if not copy_prop("vendor_extfs_rsv_pct", "extfs_rsv_pct"):
-      d["extfs_rsv_pct"] = "0"
-    copy_prop("vendor_reserved_size", "partition_reserved_size")
-  elif mount_point == "product":
-    copy_prop("avb_product_hashtree_enable", "avb_hashtree_enable")
-    copy_prop("avb_product_add_hashtree_footer_args",
-              "avb_add_hashtree_footer_args")
-    copy_prop("avb_product_key_path", "avb_key_path")
-    copy_prop("avb_product_algorithm", "avb_algorithm")
-    copy_prop("product_fs_type", "fs_type")
-    copy_prop("product_size", "partition_size")
-    if not copy_prop("product_journal_size", "journal_size"):
-      d["journal_size"] = "0"
-    copy_prop("product_verity_block_device", "verity_block_device")
-    copy_prop("ext4_share_dup_blocks", "ext4_share_dup_blocks")
-    copy_prop("product_squashfs_compressor", "squashfs_compressor")
-    copy_prop("product_squashfs_compressor_opt", "squashfs_compressor_opt")
-    copy_prop("product_squashfs_block_size", "squashfs_block_size")
-    copy_prop("product_squashfs_disable_4k_align", "squashfs_disable_4k_align")
-    copy_prop("product_base_fs_file", "base_fs_file")
-    copy_prop("product_extfs_inode_count", "extfs_inode_count")
-    if not copy_prop("product_extfs_rsv_pct", "extfs_rsv_pct"):
-      d["extfs_rsv_pct"] = "0"
-    copy_prop("product_reserved_size", "partition_reserved_size")
-  elif mount_point == "product_services":
-    copy_prop("avb_product_services_hashtree_enable", "avb_hashtree_enable")
-    copy_prop("avb_product_services_add_hashtree_footer_args",
-              "avb_add_hashtree_footer_args")
-    copy_prop("avb_product_services_key_path", "avb_key_path")
-    copy_prop("avb_product_services_algorithm", "avb_algorithm")
-    copy_prop("product_services_fs_type", "fs_type")
-    copy_prop("product_services_size", "partition_size")
-    if not copy_prop("product_services_journal_size", "journal_size"):
-      d["journal_size"] = "0"
-    copy_prop("product_services_verity_block_device", "verity_block_device")
-    copy_prop("ext4_share_dup_blocks", "ext4_share_dup_blocks")
-    copy_prop("product_services_squashfs_compressor", "squashfs_compressor")
-    copy_prop("product_services_squashfs_compressor_opt",
-              "squashfs_compressor_opt")
-    copy_prop("product_services_squashfs_block_size", "squashfs_block_size")
-    copy_prop("product_services_squashfs_disable_4k_align",
-              "squashfs_disable_4k_align")
-    copy_prop("product_services_base_fs_file", "base_fs_file")
-    copy_prop("product_services_extfs_inode_count", "extfs_inode_count")
-    if not copy_prop("product_services_extfs_rsv_pct", "extfs_rsv_pct"):
-      d["extfs_rsv_pct"] = "0"
-    copy_prop("product_services_reserved_size", "partition_reserved_size")
-  elif mount_point == "odm":
-    copy_prop("avb_odm_hashtree_enable", "avb_hashtree_enable")
-    copy_prop("avb_odm_add_hashtree_footer_args",
-              "avb_add_hashtree_footer_args")
-    copy_prop("avb_odm_key_path", "avb_key_path")
-    copy_prop("avb_odm_algorithm", "avb_algorithm")
-    copy_prop("odm_fs_type", "fs_type")
-    copy_prop("odm_size", "partition_size")
-    if not copy_prop("odm_journal_size", "journal_size"):
-      d["journal_size"] = "0"
-    copy_prop("odm_verity_block_device", "verity_block_device")
-    copy_prop("ext4_share_dup_blocks", "ext4_share_dup_blocks")
-    copy_prop("odm_squashfs_compressor", "squashfs_compressor")
-    copy_prop("odm_squashfs_compressor_opt", "squashfs_compressor_opt")
-    copy_prop("odm_squashfs_block_size", "squashfs_block_size")
-    copy_prop("odm_squashfs_disable_4k_align", "squashfs_disable_4k_align")
-    copy_prop("odm_base_fs_file", "base_fs_file")
-    copy_prop("odm_extfs_inode_count", "extfs_inode_count")
-    if not copy_prop("odm_extfs_rsv_pct", "extfs_rsv_pct"):
-      d["extfs_rsv_pct"] = "0"
-    copy_prop("odm_reserved_size", "partition_reserved_size")
-  elif mount_point == "oem":
-    copy_prop("fs_type", "fs_type")
-    copy_prop("oem_size", "partition_size")
-    if not copy_prop("oem_journal_size", "journal_size"):
-      d["journal_size"] = "0"
-    copy_prop("oem_extfs_inode_count", "extfs_inode_count")
-    copy_prop("ext4_share_dup_blocks", "ext4_share_dup_blocks")
-    if not copy_prop("oem_extfs_rsv_pct", "extfs_rsv_pct"):
-      d["extfs_rsv_pct"] = "0"
-  d["partition_name"] = mount_point
-  return d
-
-
-def LoadGlobalDict(filename):
-  """Load "name=value" pairs from filename"""
-  d = {}
-  f = open(filename)
-  for line in f:
-    line = line.strip()
-    if not line or line.startswith("#"):
-      continue
-    k, v = line.split("=", 1)
-    d[k] = v
-  f.close()
-  return d
-
-
-def GlobalDictFromImageProp(image_prop, mount_point):
-  d = {}
-  def copy_prop(src_p, dest_p):
-    if src_p in image_prop:
-      d[dest_p] = image_prop[src_p]
-      return True
-    return False
-
-  if mount_point == "system":
-    copy_prop("partition_size", "system_size")
-  elif mount_point == "system_other":
-    copy_prop("partition_size", "system_other_size")
-  elif mount_point == "vendor":
-    copy_prop("partition_size", "vendor_size")
-  elif mount_point == "odm":
-    copy_prop("partition_size", "odm_size")
-  elif mount_point == "product":
-    copy_prop("partition_size", "product_size")
-  elif mount_point == "product_services":
-    copy_prop("partition_size", "product_services_size")
-  return d
-
-
-def main(argv):
-  if len(argv) != 4:
-    print(__doc__)
-    sys.exit(1)
-
-  common.InitLogging()
-
-  in_dir = argv[0]
-  glob_dict_file = argv[1]
-  out_file = argv[2]
-  target_out = argv[3]
-
-  glob_dict = LoadGlobalDict(glob_dict_file)
-  if "mount_point" in glob_dict:
-    # The caller knows the mount point and provides a dictionary needed by
-    # BuildImage().
-    image_properties = glob_dict
-  else:
-    image_filename = os.path.basename(out_file)
-    mount_point = ""
-    if image_filename == "system.img":
-      mount_point = "system"
-    elif image_filename == "system_other.img":
-      mount_point = "system_other"
-    elif image_filename == "userdata.img":
-      mount_point = "data"
-    elif image_filename == "cache.img":
-      mount_point = "cache"
-    elif image_filename == "vendor.img":
-      mount_point = "vendor"
-    elif image_filename == "odm.img":
-      mount_point = "odm"
-    elif image_filename == "oem.img":
-      mount_point = "oem"
-    elif image_filename == "product.img":
-      mount_point = "product"
-    elif image_filename == "product_services.img":
-      mount_point = "product_services"
-    else:
-      logger.error("Unknown image file name %s", image_filename)
-      sys.exit(1)
-
-    image_properties = ImagePropFromGlobalDict(glob_dict, mount_point)
-
-  try:
-    BuildImage(in_dir, image_properties, out_file, target_out)
-  except:
-    logger.error("Failed to build %s from %s", out_file, in_dir)
-    raise
-
-
-if __name__ == '__main__':
-  try:
-    main(sys.argv[1:])
-  finally:
-    common.Cleanup()
+version https://git-lfs.github.com/spec/v1
+oid sha256:f3fd9aef18b1b77afcffabd089c5a6d6d792e3cf4bc1884246ec5b7d4dc277d4
+size 30647
diff --git a/device/rockchip/rk3399/preinstall/Android.mk b/device/rockchip/rk3399/preinstall/Android.mk
index 8338432200..dd361b2856 100644
--- a/device/rockchip/rk3399/preinstall/Android.mk
+++ b/device/rockchip/rk3399/preinstall/Android.mk
@@ -1,2 +1,3 @@
-include $(call all-subdir-makefiles)
-
+version https://git-lfs.github.com/spec/v1
+oid sha256:4413c8da30de67c3455ffd9440f84eb37119c861c4cde5993e1f1b6fbace2b8e
+size 38
diff --git a/device/rockchip/rk3399/preinstall_del/Android.mk b/device/rockchip/rk3399/preinstall_del/Android.mk
index 8338432200..dd361b2856 100644
--- a/device/rockchip/rk3399/preinstall_del/Android.mk
+++ b/device/rockchip/rk3399/preinstall_del/Android.mk
@@ -1,2 +1,3 @@
-include $(call all-subdir-makefiles)
-
+version https://git-lfs.github.com/spec/v1
+oid sha256:4413c8da30de67c3455ffd9440f84eb37119c861c4cde5993e1f1b6fbace2b8e
+size 38
diff --git a/device/rockchip/rk3399/preinstall_del_forever/Android.mk b/device/rockchip/rk3399/preinstall_del_forever/Android.mk
index 8338432200..dd361b2856 100644
--- a/device/rockchip/rk3399/preinstall_del_forever/Android.mk
+++ b/device/rockchip/rk3399/preinstall_del_forever/Android.mk
@@ -1,2 +1,3 @@
-include $(call all-subdir-makefiles)
-
+version https://git-lfs.github.com/spec/v1
+oid sha256:4413c8da30de67c3455ffd9440f84eb37119c861c4cde5993e1f1b6fbace2b8e
+size 38
diff --git a/kernel/arch/arm64/configs/firefly_defconfig b/kernel/arch/arm64/configs/firefly_defconfig
index cd3a6de370..84928be55f 100644
--- a/kernel/arch/arm64/configs/firefly_defconfig
+++ b/kernel/arch/arm64/configs/firefly_defconfig
@@ -1,980 +1,3 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_AUDIT=y
-# CONFIG_AUDITSYSCALL is not set
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_PREEMPT=y
-CONFIG_IRQ_TIME_ACCOUNTING=y
-CONFIG_TASKSTATS=y
-CONFIG_TASK_DELAY_ACCT=y
-CONFIG_TASK_XACCT=y
-CONFIG_TASK_IO_ACCOUNTING=y
-CONFIG_PSI=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_IKHEADERS=m
-CONFIG_LOG_BUF_SHIFT=19
-CONFIG_CGROUPS=y
-CONFIG_ROCKCHIP_VENDOR_STORAGE_UPDATE_LOADER=y
-CONFIG_MEMCG=y
-CONFIG_MEMCG_SWAP=y
-CONFIG_BLK_CGROUP=y
-CONFIG_CGROUP_SCHED=y
-CONFIG_CGROUP_FREEZER=y
-CONFIG_CPUSETS=y
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_CGROUP_BPF=y
-CONFIG_NAMESPACES=y
-# CONFIG_PID_NS is not set
-CONFIG_SCHED_TUNE=y
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_RD_BZIP2 is not set
-# CONFIG_RD_LZMA is not set
-# CONFIG_RD_XZ is not set
-# CONFIG_RD_LZO is not set
-# CONFIG_RD_LZ4 is not set
-CONFIG_INITRD_ASYNC=y
-# CONFIG_ROCKCHIP_ONE_INITRD is not set
-# CONFIG_SYSFS_SYSCALL is not set
-# CONFIG_FHANDLE is not set
-CONFIG_KALLSYMS_ALL=y
-CONFIG_BPF_SYSCALL=y
-CONFIG_BPF_JIT_ALWAYS_ON=y
-CONFIG_EMBEDDED=y
-# CONFIG_SLUB_DEBUG is not set
-# CONFIG_COMPAT_BRK is not set
-CONFIG_PROFILING=y
-CONFIG_ARCH_ROCKCHIP=y
-CONFIG_PCI=y
-CONFIG_PCIEPORTBUS=y
-
-# CONFIG_PCIEASPM is not set
-CONFIG_PCIEASPM_POWERSAVE=y
-
-CONFIG_PCIE_ROCKCHIP_HOST=y
-CONFIG_PCIE_DW_ROCKCHIP=y
-# CONFIG_ARM64_ERRATUM_826319 is not set
-# CONFIG_ARM64_ERRATUM_827319 is not set
-# CONFIG_ARM64_ERRATUM_824069 is not set
-# CONFIG_ARM64_ERRATUM_819472 is not set
-# CONFIG_ARM64_ERRATUM_832075 is not set
-# CONFIG_CAVIUM_ERRATUM_22375 is not set
-# CONFIG_CAVIUM_ERRATUM_23154 is not set
-# CONFIG_CAVIUM_ERRATUM_27456 is not set
-# CONFIG_CAVIUM_ERRATUM_30115 is not set
-# CONFIG_QCOM_FALKOR_ERRATUM_1003 is not set
-# CONFIG_QCOM_FALKOR_ERRATUM_1009 is not set
-# CONFIG_QCOM_QDF2400_ERRATUM_0065 is not set
-# CONFIG_SOCIONEXT_SYNQUACER_PREITS is not set
-# CONFIG_HISILICON_ERRATUM_161600802 is not set
-# CONFIG_QCOM_FALKOR_ERRATUM_E1041 is not set
-CONFIG_SCHED_MC=y
-CONFIG_NR_CPUS=8
-CONFIG_HZ_300=y
-CONFIG_SECCOMP=y
-CONFIG_ARMV8_DEPRECATED=y
-CONFIG_SWP_EMULATION=y
-CONFIG_CP15_BARRIER_EMULATION=y
-CONFIG_SETEND_EMULATION=y
-CONFIG_ARM64_SW_TTBR0_PAN=y
-CONFIG_RANDOMIZE_BASE=y
-# CONFIG_EFI is not set
-CONFIG_COMPAT=y
-CONFIG_PM_WAKELOCKS=y
-CONFIG_PM_WAKELOCKS_LIMIT=0
-# CONFIG_PM_WAKELOCKS_GC is not set
-CONFIG_PM_DEBUG=y
-CONFIG_PM_ADVANCED_DEBUG=y
-CONFIG_ENERGY_MODEL=y
-CONFIG_CPU_IDLE=y
-CONFIG_ARM_CPUIDLE=y
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_STAT=y
-CONFIG_CPU_FREQ_TIMES=y
-CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
-CONFIG_CPU_FREQ_GOV_POWERSAVE=y
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
-CONFIG_CPU_FREQ_GOV_SCHEDUTIL=y
-CONFIG_CPUFREQ_DT=y
-CONFIG_ARM_ROCKCHIP_CPUFREQ=y
-CONFIG_ARM_SCMI_PROTOCOL=y
-CONFIG_ROCKCHIP_SIP=y
-CONFIG_ARM64_CRYPTO=y
-CONFIG_CRYPTO_SHA1_ARM64_CE=y
-CONFIG_CRYPTO_SHA2_ARM64_CE=y
-CONFIG_CRYPTO_GHASH_ARM64_CE=y
-CONFIG_CRYPTO_CRC32_ARM64_CE=y
-CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
-CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
-CONFIG_JUMP_LABEL=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODVERSIONS=y
-CONFIG_BLK_INLINE_ENCRYPTION=y
-CONFIG_BLK_INLINE_ENCRYPTION_FALLBACK=y
-CONFIG_PARTITION_ADVANCED=y
-CONFIG_CMDLINE_PARTITION=y
-# CONFIG_IOSCHED_DEADLINE is not set
-CONFIG_CFQ_GROUP_IOSCHED=y
-CONFIG_IOSCHED_BFQ=y
-CONFIG_BFQ_GROUP_IOSCHED=y
-# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
-CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
-CONFIG_CMA=y
-CONFIG_ZSMALLOC=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_XFRM_USER=y
-CONFIG_XFRM_INTERFACE=y
-CONFIG_XFRM_STATISTICS=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_IP_ROUTE_VERBOSE=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_NET_IPGRE_DEMUX=y
-CONFIG_SYN_COOKIES=y
-CONFIG_NET_IPVTI=y
-CONFIG_INET_AH=y
-CONFIG_INET_ESP=y
-CONFIG_INET_IPCOMP=y
-CONFIG_INET_UDP_DIAG=y
-CONFIG_INET_DIAG_DESTROY=y
-CONFIG_IPV6_ROUTER_PREF=y
-CONFIG_IPV6_ROUTE_INFO=y
-CONFIG_IPV6_OPTIMISTIC_DAD=y
-CONFIG_INET6_AH=y
-CONFIG_INET6_ESP=y
-CONFIG_INET6_IPCOMP=y
-CONFIG_IPV6_MIP6=y
-CONFIG_IPV6_VTI=y
-CONFIG_IPV6_MULTIPLE_TABLES=y
-CONFIG_IPV6_SUBTREES=y
-CONFIG_NETFILTER=y
-CONFIG_BRIDGE_NETFILTER=y
-CONFIG_NF_CONNTRACK=y
-CONFIG_NF_CONNTRACK_SECMARK=y
-CONFIG_NF_CONNTRACK_EVENTS=y
-CONFIG_NF_CONNTRACK_AMANDA=y
-CONFIG_NF_CONNTRACK_FTP=y
-CONFIG_NF_CONNTRACK_H323=y
-CONFIG_NF_CONNTRACK_IRC=y
-CONFIG_NF_CONNTRACK_NETBIOS_NS=y
-CONFIG_NF_CONNTRACK_PPTP=y
-CONFIG_NF_CONNTRACK_SANE=y
-CONFIG_NF_CONNTRACK_TFTP=y
-CONFIG_NF_CT_NETLINK=y
-CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
-CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
-CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
-CONFIG_NETFILTER_XT_TARGET_CT=y
-CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
-CONFIG_NETFILTER_XT_TARGET_LOG=y
-CONFIG_NETFILTER_XT_TARGET_MARK=y
-CONFIG_NETFILTER_XT_TARGET_NFLOG=y
-CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
-CONFIG_NETFILTER_XT_TARGET_TPROXY=y
-CONFIG_NETFILTER_XT_TARGET_TRACE=y
-CONFIG_NETFILTER_XT_TARGET_SECMARK=y
-CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_BPF=y
-CONFIG_NETFILTER_XT_MATCH_COMMENT=y
-CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
-CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
-CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_HELPER=y
-CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
-CONFIG_NETFILTER_XT_MATCH_LENGTH=y
-CONFIG_NETFILTER_XT_MATCH_LIMIT=y
-CONFIG_NETFILTER_XT_MATCH_MAC=y
-CONFIG_NETFILTER_XT_MATCH_MARK=y
-CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
-CONFIG_NETFILTER_XT_MATCH_OWNER=y
-CONFIG_NETFILTER_XT_MATCH_POLICY=y
-CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
-CONFIG_NETFILTER_XT_MATCH_SOCKET=y
-CONFIG_NETFILTER_XT_MATCH_STATE=y
-CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
-CONFIG_NETFILTER_XT_MATCH_STRING=y
-CONFIG_NETFILTER_XT_MATCH_TIME=y
-CONFIG_NETFILTER_XT_MATCH_U32=y
-CONFIG_IP_NF_IPTABLES=y
-CONFIG_IP_NF_MATCH_AH=y
-CONFIG_IP_NF_MATCH_ECN=y
-CONFIG_IP_NF_MATCH_RPFILTER=y
-CONFIG_IP_NF_MATCH_TTL=y
-CONFIG_IP_NF_FILTER=y
-CONFIG_IP_NF_TARGET_REJECT=y
-CONFIG_IP_NF_NAT=y
-CONFIG_IP_NF_TARGET_MASQUERADE=y
-CONFIG_IP_NF_TARGET_NETMAP=y
-CONFIG_IP_NF_TARGET_REDIRECT=y
-CONFIG_IP_NF_MANGLE=y
-CONFIG_IP_NF_RAW=y
-CONFIG_IP_NF_SECURITY=y
-CONFIG_IP_NF_ARPTABLES=y
-CONFIG_IP_NF_ARPFILTER=y
-CONFIG_IP_NF_ARP_MANGLE=y
-CONFIG_IP6_NF_IPTABLES=y
-CONFIG_IP6_NF_MATCH_RPFILTER=y
-CONFIG_IP6_NF_FILTER=y
-CONFIG_IP6_NF_TARGET_REJECT=y
-CONFIG_IP6_NF_MANGLE=y
-CONFIG_IP6_NF_RAW=y
-CONFIG_BRIDGE_NF_EBTABLES=y
-CONFIG_BRIDGE_EBT_BROUTE=y
-CONFIG_L2TP=y
-CONFIG_BRIDGE=y
-CONFIG_NET_SCHED=y
-CONFIG_NET_SCH_HTB=y
-CONFIG_NET_SCH_PRIO=y
-CONFIG_NET_SCH_NETEM=y
-CONFIG_NET_SCH_INGRESS=y
-CONFIG_NET_CLS_FW=y
-CONFIG_NET_CLS_U32=y
-CONFIG_CLS_U32_MARK=y
-CONFIG_NET_CLS_FLOW=y
-CONFIG_NET_CLS_BPF=y
-CONFIG_NET_EMATCH=y
-CONFIG_NET_EMATCH_CMP=y
-CONFIG_NET_EMATCH_NBYTE=y
-CONFIG_NET_EMATCH_U32=y
-CONFIG_NET_EMATCH_META=y
-CONFIG_NET_EMATCH_TEXT=y
-CONFIG_NET_CLS_ACT=y
-CONFIG_BPF_JIT=y
-CONFIG_BT=y
-CONFIG_BT_RFCOMM=y
-CONFIG_BT_RFCOMM_TTY=y
-CONFIG_BT_BNEP=y
-CONFIG_BT_BNEP_MC_FILTER=y
-CONFIG_BT_BNEP_PROTO_FILTER=y
-CONFIG_BT_HIDP=y
-CONFIG_BT_HCIUART=y
-CONFIG_BT_HCIUART_H4=y
-CONFIG_RFKILL=y
-CONFIG_DEVTMPFS=y
-CONFIG_FW_LOADER_USER_HELPER=y
-# CONFIG_FW_CACHE is not set
-CONFIG_MALI_MEMORY_GROUP_MANAGER=y
-CONFIG_DMA_CMA=y
-CONFIG_MTD=y
-
-CONFIG_MTD_SPI_NOR=y
-CONFIG_ZRAM=y
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_BLK_DEV_LOOP_MIN_COUNT=16
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=8192
-CONFIG_BLK_DEV_NVME=y
-CONFIG_SRAM=y
-CONFIG_UID_SYS_STATS=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_CHR_DEV_SG=y
-CONFIG_CHR_DEV_SCH=y
-CONFIG_SCSI_CONSTANTS=y
-CONFIG_SCSI_LOGGING=y
-CONFIG_SCSI_SCAN_ASYNC=y
-CONFIG_ATA=y
-CONFIG_SATA_AHCI=y
-CONFIG_SATA_AHCI_PLATFORM=y
-# CONFIG_ATA_SFF is not set
-CONFIG_MD=y
-CONFIG_BLK_DEV_DM=y
-CONFIG_DM_CRYPT=y
-CONFIG_DM_DEFAULT_KEY=y
-CONFIG_DM_SNAPSHOT=y
-CONFIG_DM_UEVENT=y
-CONFIG_DM_VERITY=y
-CONFIG_DM_VERITY_AVB=y
-CONFIG_DM_VERITY_FEC=y
-CONFIG_DM_BOW=y
-CONFIG_DM_ANDROID_VERITY_AT_MOST_ONCE_DEFAULT_ENABLED=y
-CONFIG_NETDEVICES=y
-CONFIG_DUMMY=y
-CONFIG_TUN=y
-CONFIG_VETH=y
-# CONFIG_NET_VENDOR_3COM is not set
-# CONFIG_NET_VENDOR_ADAPTEC is not set
-# CONFIG_NET_VENDOR_AGERE is not set
-# CONFIG_NET_VENDOR_ALACRITECH is not set
-# CONFIG_NET_VENDOR_ALTEON is not set
-# CONFIG_NET_VENDOR_AMAZON is not set
-# CONFIG_NET_VENDOR_AMD is not set
-# CONFIG_NET_VENDOR_AQUANTIA is not set
-# CONFIG_NET_VENDOR_ARC is not set
-# CONFIG_NET_VENDOR_ATHEROS is not set
-# CONFIG_NET_VENDOR_AURORA is not set
-# CONFIG_NET_VENDOR_BROADCOM is not set
-# CONFIG_NET_VENDOR_BROCADE is not set
-# CONFIG_NET_VENDOR_CADENCE is not set
-# CONFIG_NET_VENDOR_CAVIUM is not set
-# CONFIG_NET_VENDOR_CHELSIO is not set
-# CONFIG_NET_VENDOR_CISCO is not set
-# CONFIG_NET_VENDOR_CORTINA is not set
-# CONFIG_NET_VENDOR_DEC is not set
-# CONFIG_NET_VENDOR_DLINK is not set
-# CONFIG_NET_VENDOR_EMULEX is not set
-# CONFIG_NET_VENDOR_EZCHIP is not set
-# CONFIG_NET_VENDOR_HISILICON is not set
-# CONFIG_NET_VENDOR_HP is not set
-# CONFIG_NET_VENDOR_HUAWEI is not set
-# CONFIG_NET_VENDOR_INTEL is not set
-# CONFIG_NET_VENDOR_MARVELL is not set
-# CONFIG_NET_VENDOR_MELLANOX is not set
-# CONFIG_NET_VENDOR_MICREL is not set
-# CONFIG_NET_VENDOR_MICROCHIP is not set
-# CONFIG_NET_VENDOR_MICROSEMI is not set
-# CONFIG_NET_VENDOR_MYRI is not set
-# CONFIG_NET_VENDOR_NATSEMI is not set
-# CONFIG_NET_VENDOR_NETERION is not set
-# CONFIG_NET_VENDOR_NETRONOME is not set
-# CONFIG_NET_VENDOR_NI is not set
-# CONFIG_NET_VENDOR_NVIDIA is not set
-# CONFIG_NET_VENDOR_OKI is not set
-# CONFIG_NET_VENDOR_PACKET_ENGINES is not set
-# CONFIG_NET_VENDOR_QLOGIC is not set
-# CONFIG_NET_VENDOR_QUALCOMM is not set
-# CONFIG_NET_VENDOR_RDC is not set
-# CONFIG_NET_VENDOR_REALTEK is not set
-# CONFIG_NET_VENDOR_RENESAS is not set
-# CONFIG_NET_VENDOR_ROCKER is not set
-# CONFIG_NET_VENDOR_SAMSUNG is not set
-# CONFIG_NET_VENDOR_SEEQ is not set
-# CONFIG_NET_VENDOR_SOLARFLARE is not set
-# CONFIG_NET_VENDOR_SILAN is not set
-# CONFIG_NET_VENDOR_SIS is not set
-# CONFIG_NET_VENDOR_SMSC is not set
-# CONFIG_NET_VENDOR_SOCIONEXT is not set
-CONFIG_STMMAC_ETH=y
-# CONFIG_DWMAC_GENERIC is not set
-# CONFIG_NET_VENDOR_SUN is not set
-# CONFIG_NET_VENDOR_SYNOPSYS is not set
-# CONFIG_NET_VENDOR_TEHUTI is not set
-# CONFIG_NET_VENDOR_TI is not set
-# CONFIG_NET_VENDOR_VIA is not set
-# CONFIG_NET_VENDOR_WIZNET is not set
-CONFIG_ROCKCHIP_PHY=y
-CONFIG_PPP=y
-CONFIG_PPP_BSDCOMP=y
-CONFIG_PPP_DEFLATE=y
-CONFIG_PPP_FILTER=y
-CONFIG_PPP_MPPE=y
-CONFIG_PPP_MULTILINK=y
-CONFIG_PPPOE=y
-CONFIG_PPTP=y
-CONFIG_PPPOL2TP=y
-CONFIG_PPP_ASYNC=y
-CONFIG_PPP_SYNC_TTY=y
-CONFIG_SLIP=y
-CONFIG_SLIP_COMPRESSED=y
-CONFIG_SLIP_MODE_SLIP6=y
-CONFIG_USB_CATC=y
-CONFIG_USB_KAWETH=y
-CONFIG_USB_PEGASUS=y
-CONFIG_USB_RTL8150=y
-CONFIG_USB_RTL8152=y
-CONFIG_USB_USBNET=y
-CONFIG_USB_NET_CDC_EEM=y
-CONFIG_USB_NET_CDC_MBIM=y
-CONFIG_USB_NET_DM9601=y
-CONFIG_USB_NET_SMSC75XX=y
-CONFIG_USB_NET_SMSC95XX=y
-CONFIG_USB_NET_GL620A=y
-CONFIG_USB_NET_PLUSB=y
-CONFIG_USB_NET_MCS7830=y
-CONFIG_USB_NET_RNDIS_HOST=y
-CONFIG_USB_ALI_M5632=y
-CONFIG_USB_AN2720=y
-CONFIG_USB_EPSON2888=y
-CONFIG_USB_KC2190=y
-CONFIG_USB_NET_CX82310_ETH=y
-CONFIG_USB_NET_KALMIA=y
-CONFIG_USB_NET_QMI_WWAN=y
-CONFIG_USB_HSO=y
-CONFIG_USB_NET_INT51X1=y
-CONFIG_USB_IPHETH=y
-CONFIG_USB_SIERRA_NET=y
-# CONFIG_WLAN_VENDOR_ADMTEK is not set
-# CONFIG_WLAN_VENDOR_ATH is not set
-# CONFIG_WLAN_VENDOR_ATMEL is not set
-# CONFIG_WLAN_VENDOR_BROADCOM is not set
-# CONFIG_WLAN_VENDOR_CISCO is not set
-# CONFIG_WLAN_VENDOR_INTEL is not set
-# CONFIG_WLAN_VENDOR_INTERSIL is not set
-# CONFIG_WLAN_VENDOR_MARVELL is not set
-# CONFIG_WLAN_VENDOR_MEDIATEK is not set
-# CONFIG_WLAN_VENDOR_RALINK is not set
-# CONFIG_WLAN_VENDOR_REALTEK is not set
-# CONFIG_WLAN_VENDOR_RSI is not set
-# CONFIG_WLAN_VENDOR_ST is not set
-# CONFIG_WLAN_VENDOR_TI is not set
-# CONFIG_WLAN_VENDOR_ZYDAS is not set
-# CONFIG_WLAN_VENDOR_QUANTENNA is not set
-CONFIG_WL_ROCKCHIP=y
-CONFIG_WIFI_BUILD_MODULE=y
-CONFIG_AP6XXX=m
-CONFIG_RTL8723CS=m
-CONFIG_RTL8821CS=m
-CONFIG_RTL8822BS=m
-CONFIG_RTL8723DS=m
-CONFIG_RTL8723DU=m
-CONFIG_LTE=y
-CONFIG_LTE_RM310=y
-CONFIG_INPUT_EVDEV=y
-CONFIG_KEYBOARD_ADC=y
-# CONFIG_KEYBOARD_ATKBD is not set
-
-# CONFIG_INPUT_MOUSE is not set
-CONFIG_INPUT_JOYSTICK=y
-CONFIG_JOYSTICK_XPAD=y
-CONFIG_JOYSTICK_XPAD_FF=y
-CONFIG_JOYSTICK_XPAD_LEDS=y
-CONFIG_INPUT_TABLET=y
-CONFIG_TABLET_USB_ACECAD=y
-CONFIG_TABLET_USB_AIPTEK=y
-CONFIG_TABLET_USB_GTCO=y
-CONFIG_TABLET_USB_HANWANG=y
-CONFIG_TABLET_USB_KBTAB=y
-CONFIG_INPUT_TOUCHSCREEN=y
-
-CONFIG_TOUCHSCREEN_GSLX680_FIREFLY=y
-
-
-CONFIG_TOUCHSCREEN_GSL3673=y
-CONFIG_TOUCHSCREEN_GSL3673_800X1280=y
-CONFIG_TOUCHSCREEN_GSL3676=y
-CONFIG_TOUCHSCREEN_GT9XX=y
-CONFIG_TOUCHSCREEN_HYN_CST2XX=y
-CONFIG_TOUCHSCREEN_WACOM_W9013=y
-CONFIG_TOUCHSCREEN_GT1X=y
-
-CONFIG_TOUCHSCREEN_HX83102=y
-CONFIG_TOUCHSCREEN_ILITEX=y
-
-CONFIG_TOUCHSCREEN_FTS=y
-CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP5=y
-CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP5_DEVICETREE_SUPPORT=y
-CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP5_I2C=y
-CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP5_DEVICE_ACCESS=y
-CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP5_LOADER=y
-
-CONFIG_ROCKCHIP_REMOTECTL=y
-CONFIG_ROCKCHIP_REMOTECTL_PWM=y
-CONFIG_SENSOR_DEVICE=y
-CONFIG_GSENSOR_DEVICE=y
-CONFIG_GS_MMA8452=y
-CONFIG_MPU6880_ACC=y
-CONFIG_MPU6500_ACC=y
-CONFIG_GS_KXTJ9=y
-CONFIG_GS_LIS3DH=y
-CONFIG_GS_MMA7660=y
-CONFIG_GS_MC3230=y
-CONFIG_GS_SC7660=y
-CONFIG_GS_SC7A20=y
-CONFIG_GS_SC7A30=y
-CONFIG_GS_MXC6655XA=y
-CONFIG_GS_LSM303D=y
-CONFIG_LSM330_ACC=y
-CONFIG_BMA2XX_ACC=y
-CONFIG_GS_DA223=y
-CONFIG_COMPASS_DEVICE=y
-CONFIG_COMPASS_AK8975=y
-CONFIG_COMPASS_AK8963=y
-CONFIG_GYROSCOPE_DEVICE=y
-CONFIG_GYRO_L3G4200D=y
-CONFIG_GYRO_L3G20D=y
-CONFIG_GYRO_EWTSA=y
-CONFIG_GYRO_MPU6500=y
-CONFIG_GYRO_MPU6880=y
-CONFIG_GYRO_LSM330=y
-CONFIG_LIGHT_DEVICE=y
-CONFIG_LS_CM3217=y
-CONFIG_LS_CM3218=y
-CONFIG_LS_STK3410=y
-CONFIG_PROXIMITY_DEVICE=y
-CONFIG_PS_STK3410=y
-CONFIG_HALL_DEVICE=y
-CONFIG_HS_MH248=y
-CONFIG_INPUT_MISC=y
-CONFIG_INPUT_UINPUT=y
-CONFIG_INPUT_RK805_PWRKEY=y
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-# CONFIG_LEGACY_PTYS is not set
-CONFIG_SERIAL_8250=y
-# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
-CONFIG_SERIAL_8250_CONSOLE=y
-# CONFIG_SERIAL_8250_PCI is not set
-CONFIG_SERIAL_8250_NR_UARTS=10
-CONFIG_SERIAL_8250_RUNTIME_UARTS=10
-CONFIG_SERIAL_8250_DW=y
-CONFIG_HW_RANDOM=y
-# CONFIG_HW_RANDOM_CAVIUM is not set
-CONFIG_HW_RANDOM_ROCKCHIP=y
-# CONFIG_DEVPORT is not set
-CONFIG_I2C_CHARDEV=y
-CONFIG_I2C_GPIO=y
-CONFIG_I2C_RK3X=y
-CONFIG_SPI=y
-CONFIG_SPI_ROCKCHIP=y
-CONFIG_SPI_SPIDEV=y
-CONFIG_PINCTRL_RK805=y
-CONFIG_GPIO_SYSFS=y
-CONFIG_POWER_AVS=y
-CONFIG_ROCKCHIP_IODOMAIN=y
-CONFIG_POWER_RESET_GPIO=y
-CONFIG_SYSCON_REBOOT_MODE=y
-CONFIG_GPIO_WIEGAND_SEND=y
-CONFIG_GPIO_WIEGAND_RECEIVE=y
-CONFIG_GPIO_RADER=y
-CONFIG_TEST_POWER=y
-CONFIG_CHARGER_BQ25700=y
-CONFIG_BATTERY_CW2015=y
-CONFIG_BATTERY_RK817=y
-CONFIG_CHARGER_RK817=y
-CONFIG_BATTERY_RK818=y
-CONFIG_CHARGER_RK818=y
-CONFIG_THERMAL=y
-CONFIG_THERMAL_WRITABLE_TRIPS=y
-CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR=y
-CONFIG_THERMAL_GOV_FAIR_SHARE=y
-CONFIG_THERMAL_GOV_STEP_WISE=y
-CONFIG_THERMAL_GOV_USER_SPACE=y
-CONFIG_CPU_THERMAL=y
-CONFIG_DEVFREQ_THERMAL=y
-CONFIG_ROCKCHIP_THERMAL=y
-CONFIG_RK3368_THERMAL=y
-CONFIG_WATCHDOG=y
-
-
-CONFIG_DW_WATCHDOG=y
-
-CONFIG_MFD_RK618=y
-CONFIG_MFD_RK628=y
-CONFIG_MFD_RK630_I2C=y
-CONFIG_MFD_RK808=y
-CONFIG_FUSB_30X=y
-CONFIG_REGULATOR=y
-CONFIG_REGULATOR_FIXED_VOLTAGE=y
-CONFIG_REGULATOR_ACT8865=y
-CONFIG_REGULATOR_FAN53555=y
-CONFIG_REGULATOR_GPIO=y
-CONFIG_REGULATOR_LP8752=y
-CONFIG_REGULATOR_MP8865=y
-CONFIG_REGULATOR_PWM=y
-CONFIG_REGULATOR_RK808=y
-CONFIG_REGULATOR_TPS65132=y
-CONFIG_REGULATOR_XZ3216=y
-CONFIG_REGULATOR_DIO5632=y
-CONFIG_MEDIA_SUPPORT=y
-CONFIG_MEDIA_CAMERA_SUPPORT=y
-CONFIG_MEDIA_CEC_SUPPORT=y
-CONFIG_MEDIA_CONTROLLER=y
-CONFIG_VIDEO_V4L2_SUBDEV_API=y
-CONFIG_MEDIA_USB_SUPPORT=y
-CONFIG_USB_VIDEO_CLASS=y
-CONFIG_V4L_PLATFORM_DRIVERS=y
-CONFIG_VIDEO_ROCKCHIP_CIF=y
-CONFIG_VIDEO_ROCKCHIP_ISP1=y
-CONFIG_VIDEO_ROCKCHIP_ISP=y
-# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
-CONFIG_VIDEO_DW9714=y
-CONFIG_VIDEO_VM149C=y
-CONFIG_VIDEO_TC35874X=y
-CONFIG_VIDEO_RK628_CSI=y
-CONFIG_VIDEO_OV2680=y
-CONFIG_VIDEO_OV5648=y
-CONFIG_VIDEO_OV5695=y
-CONFIG_VIDEO_OV8858=y
-CONFIG_VIDEO_OV13850=y
-CONFIG_VIDEO_GC0312=y
-CONFIG_VIDEO_GC032A=y
-CONFIG_VIDEO_GC2145=y
-CONFIG_VIDEO_GC2355=y
-CONFIG_VIDEO_GC2385=y
-CONFIG_VIDEO_GC4C33=y
-CONFIG_VIDEO_GC8034=y
-CONFIG_VIDEO_SGM3784=y
-CONFIG_VIDEO_XC7160=y
-# CONFIG_VGA_ARB is not set
-CONFIG_DRM=y
-CONFIG_DRM_IGNORE_IOTCL_PERMIT=y
-CONFIG_DRM_LOAD_EDID_FIRMWARE=y
-CONFIG_DRM_ROCKCHIP=y
-CONFIG_ROCKCHIP_ANALOGIX_DP=y
-CONFIG_ROCKCHIP_CDN_DP=y
-CONFIG_ROCKCHIP_DW_HDMI=y
-CONFIG_ROCKCHIP_DW_MIPI_DSI=y
-CONFIG_ROCKCHIP_INNO_HDMI=y
-CONFIG_ROCKCHIP_LVDS=y
-CONFIG_ROCKCHIP_DRM_TVE=y
-CONFIG_ROCKCHIP_RGB=y
-CONFIG_DRM_ROCKCHIP_RK618=y
-CONFIG_DRM_ROCKCHIP_RK628=y
-CONFIG_DRM_PANEL_SIMPLE=y
-CONFIG_DRM_RK630_TVE=y
-CONFIG_DRM_RK1000_TVE=y
-CONFIG_DRM_SII902X=y
-CONFIG_DRM_DW_HDMI_I2S_AUDIO=y
-CONFIG_DRM_DW_HDMI_CEC=y
-CONFIG_MALI400=y
-CONFIG_MALI450=y
-# CONFIG_MALI400_PROFILING is not set
-CONFIG_MALI_SHARED_INTERRUPTS=y
-CONFIG_MALI_DT=y
-CONFIG_MALI_DEVFREQ=y
-CONFIG_MALI_MIDGARD=y
-CONFIG_MALI_EXPERT=y
-CONFIG_MALI_PLATFORM_THIRDPARTY=y
-CONFIG_MALI_PLATFORM_THIRDPARTY_NAME="rk"
-CONFIG_MALI_DEBUG=y
-CONFIG_MALI_PWRSOFT_765=y
-CONFIG_MALI_BIFROST=y
-CONFIG_MALI_BIFROST_DEVFREQ=y
-CONFIG_MALI_PLATFORM_NAME="rk"
-CONFIG_MALI_BIFROST_EXPERT=y
-CONFIG_MALI_BIFROST_DEBUG=y
-CONFIG_BACKLIGHT_LCD_SUPPORT=y
-# CONFIG_LCD_CLASS_DEVICE is not set
-CONFIG_BACKLIGHT_CLASS_DEVICE=y
-# CONFIG_BACKLIGHT_GENERIC is not set
-CONFIG_BACKLIGHT_PWM=y
-CONFIG_ROCKCHIP_RGA2=y
-CONFIG_IEP=y
-CONFIG_ROCKCHIP_MPP_SERVICE=y
-CONFIG_ROCKCHIP_MPP_RKVDEC=y
-CONFIG_ROCKCHIP_MPP_RKVDEC2=y
-CONFIG_ROCKCHIP_MPP_RKVENC=y
-CONFIG_ROCKCHIP_MPP_VDPU1=y
-CONFIG_ROCKCHIP_MPP_VEPU1=y
-CONFIG_ROCKCHIP_MPP_VDPU2=y
-CONFIG_ROCKCHIP_MPP_VEPU2=y
-CONFIG_ROCKCHIP_MPP_IEP2=y
-CONFIG_ROCKCHIP_MPP_JPGDEC=y
-CONFIG_SOUND=y
-CONFIG_SND=y
-CONFIG_SND_DYNAMIC_MINORS=y
-# CONFIG_SND_SUPPORT_OLD_API is not set
-CONFIG_SND_VERBOSE_PRINTK=y
-# CONFIG_SND_DRIVERS is not set
-# CONFIG_SND_PCI is not set
-# CONFIG_SND_SPI is not set
-CONFIG_SND_USB_AUDIO=y
-CONFIG_SND_SOC=y
-CONFIG_SND_SOC_ROCKCHIP=y
-CONFIG_SND_SOC_ROCKCHIP_I2S_TDM=y
-CONFIG_SND_SOC_ROCKCHIP_PDM=y
-CONFIG_SND_SOC_ROCKCHIP_SPDIF=y
-CONFIG_SND_SOC_ROCKCHIP_MULTICODECS=y
-CONFIG_SND_SOC_ROCKCHIP_RT5651=y
-CONFIG_SND_SOC_BT_SCO=y
-CONFIG_SND_SOC_CX2072X=y
-CONFIG_SND_SOC_DUMMY_CODEC=y
-CONFIG_SND_SOC_ES7202=y
-CONFIG_SND_SOC_ES7210=y
-CONFIG_SND_SOC_ES7243E=y
-CONFIG_SND_SOC_ES8311=y
-CONFIG_SND_SOC_ES8316=y
-CONFIG_SND_SOC_ES8396=y
-CONFIG_SND_SOC_RK3328=y
-CONFIG_SND_SOC_RK817=y
-CONFIG_SND_SOC_RK_CODEC_DIGITAL=y
-CONFIG_SND_SOC_RT5640=y
-CONFIG_SND_SOC_SPDIF=y
-CONFIG_SND_SIMPLE_CARD=y
-CONFIG_HIDRAW=y
-CONFIG_UHID=y
-CONFIG_HID_A4TECH=y
-CONFIG_HID_ACRUX=y
-CONFIG_HID_ACRUX_FF=y
-CONFIG_HID_APPLE=y
-CONFIG_HID_APPLEIR=y
-CONFIG_HID_AUREAL=y
-CONFIG_HID_BELKIN=y
-CONFIG_HID_CHERRY=y
-CONFIG_HID_CHICONY=y
-CONFIG_HID_PRODIKEYS=y
-CONFIG_HID_CYPRESS=y
-CONFIG_HID_DRAGONRISE=y
-CONFIG_DRAGONRISE_FF=y
-CONFIG_HID_EMS_FF=y
-CONFIG_HID_ELECOM=y
-CONFIG_HID_EZKEY=y
-CONFIG_HID_HOLTEK=y
-CONFIG_HID_KEYTOUCH=y
-CONFIG_HID_KYE=y
-CONFIG_HID_UCLOGIC=y
-CONFIG_HID_WALTOP=y
-CONFIG_HID_GYRATION=y
-CONFIG_HID_ICADE=y
-CONFIG_HID_TWINHAN=y
-CONFIG_HID_KENSINGTON=y
-CONFIG_HID_LCPOWER=y
-CONFIG_HID_LENOVO=y
-CONFIG_HID_LOGITECH=y
-CONFIG_HID_LOGITECH_DJ=y
-CONFIG_LOGITECH_FF=y
-CONFIG_LOGIRUMBLEPAD2_FF=y
-CONFIG_LOGIG940_FF=y
-CONFIG_HID_MAGICMOUSE=y
-CONFIG_HID_MICROSOFT=y
-CONFIG_HID_MONTEREY=y
-CONFIG_HID_MULTITOUCH=y
-CONFIG_HID_NINTENDO=y
-CONFIG_HID_NTRIG=y
-CONFIG_HID_ORTEK=y
-CONFIG_HID_PANTHERLORD=y
-CONFIG_PANTHERLORD_FF=y
-CONFIG_HID_PETALYNX=y
-CONFIG_HID_PICOLCD=y
-CONFIG_HID_PRIMAX=y
-CONFIG_HID_ROCCAT=y
-CONFIG_HID_SAITEK=y
-CONFIG_HID_SAMSUNG=y
-CONFIG_HID_SONY=y
-CONFIG_HID_SPEEDLINK=y
-CONFIG_HID_STEAM=y
-CONFIG_HID_STEELSERIES=y
-CONFIG_HID_SUNPLUS=y
-CONFIG_HID_GREENASIA=y
-CONFIG_GREENASIA_FF=y
-CONFIG_HID_SMARTJOYPLUS=y
-CONFIG_SMARTJOYPLUS_FF=y
-CONFIG_HID_TIVO=y
-CONFIG_HID_TOPSEED=y
-CONFIG_HID_THINGM=y
-CONFIG_HID_THRUSTMASTER=y
-CONFIG_HID_WACOM=y
-CONFIG_HID_WIIMOTE=y
-CONFIG_HID_ZEROPLUS=y
-CONFIG_HID_ZYDACRON=y
-CONFIG_HID_ALPS=y
-CONFIG_USB_HIDDEV=y
-CONFIG_I2C_HID=y
-CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
-CONFIG_USB_MON=y
-CONFIG_USB_XHCI_HCD=y
-CONFIG_USB_EHCI_HCD=y
-CONFIG_USB_EHCI_HCD_PLATFORM=y
-CONFIG_USB_OHCI_HCD=y
-# CONFIG_USB_OHCI_HCD_PCI is not set
-CONFIG_USB_OHCI_HCD_PLATFORM=y
-CONFIG_USB_ACM=y
-CONFIG_USB_PRINTER=y
-CONFIG_USB_STORAGE=y
-CONFIG_USB_STORAGE_DATAFAB=y
-CONFIG_USB_STORAGE_FREECOM=y
-CONFIG_USB_STORAGE_ISD200=y
-CONFIG_USB_STORAGE_USBAT=y
-CONFIG_USB_STORAGE_SDDR09=y
-CONFIG_USB_STORAGE_SDDR55=y
-CONFIG_USB_STORAGE_JUMPSHOT=y
-CONFIG_USB_STORAGE_ALAUDA=y
-CONFIG_USB_STORAGE_ONETOUCH=y
-CONFIG_USB_STORAGE_KARMA=y
-CONFIG_USB_STORAGE_CYPRESS_ATACB=y
-CONFIG_USB_STORAGE_ENE_UB6250=y
-CONFIG_USB_UAS=y
-CONFIG_USB_DWC3=y
-CONFIG_USB_DWC2=y
-CONFIG_USB_SERIAL=y
-CONFIG_USB_SERIAL_GENERIC=y
-CONFIG_USB_SERIAL_OPTION=y
-CONFIG_USB_TRANCEVIBRATOR=y
-CONFIG_USB_GADGET=y
-CONFIG_USB_GADGET_DEBUG_FILES=y
-CONFIG_USB_GADGET_VBUS_DRAW=500
-CONFIG_USB_CONFIGFS=y
-CONFIG_USB_CONFIGFS_UEVENT=y
-CONFIG_USB_CONFIGFS_ACM=y
-CONFIG_USB_CONFIGFS_RNDIS=y
-CONFIG_USB_CONFIGFS_MASS_STORAGE=y
-CONFIG_USB_CONFIGFS_F_FS=y
-CONFIG_USB_CONFIGFS_F_ACC=y
-CONFIG_USB_CONFIGFS_F_AUDIO_SRC=y
-CONFIG_USB_CONFIGFS_F_MIDI=y
-CONFIG_USB_CONFIGFS_F_UVC=y
-CONFIG_MMC=y
-CONFIG_MMC_BLOCK_MINORS=32
-CONFIG_MMC_CRYPTO=y
-CONFIG_SDIO_KEEPALIVE=y
-CONFIG_MMC_SDHCI=y
-CONFIG_MMC_SDHCI_PLTFM=y
-CONFIG_MMC_SDHCI_OF_ARASAN=y
-CONFIG_MMC_SDHCI_OF_DWCMSHC=y
-CONFIG_MMC_DW=y
-CONFIG_MMC_DW_ROCKCHIP=y
-CONFIG_LEDS_CLASS_FLASH=y
-CONFIG_LEDS_GPIO=y
-CONFIG_LEDS_RGB13H=y
-CONFIG_LEDS_TRIGGER_TIMER=y
-CONFIG_LEDS_TRIGGER_HEARTBEAT=y
-CONFIG_LEDS_TRIGGER_BACKLIGHT=y
-CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_RK808=y
-CONFIG_DMADEVICES=y
-CONFIG_PL330_DMA=y
-CONFIG_SW_SYNC=y
-CONFIG_STAGING=y
-CONFIG_ASHMEM=y
-CONFIG_ION=y
-CONFIG_ION_SYSTEM_HEAP=y
-CONFIG_ION_CMA_HEAP=y
-CONFIG_ION_FORCE_DMA_SYNC=y
-CONFIG_FIQ_DEBUGGER=y
-CONFIG_FIQ_DEBUGGER_NO_SLEEP=y
-CONFIG_FIQ_DEBUGGER_CONSOLE=y
-CONFIG_FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE=y
-CONFIG_FIQ_DEBUGGER_TRUST_ZONE=y
-CONFIG_RK_CONSOLE_THREAD=y
-CONFIG_POWERVR_ROGUE_N=y
-CONFIG_COMMON_CLK_RK808=y
-CONFIG_COMMON_CLK_SCMI=y
-# CONFIG_COMMON_CLK_XGENE is not set
-CONFIG_COMMON_CLK_PWM=y
-CONFIG_MAILBOX=y
-CONFIG_RK3368_MBOX=y
-CONFIG_RK3368_SCPI_PROTOCOL=y
-CONFIG_ROCKCHIP_IOMMU=y
-CONFIG_CPU_PX30=y
-CONFIG_CPU_RK3328=y
-CONFIG_CPU_RK3368=y
-CONFIG_CPU_RK3399=y
-CONFIG_CPU_RK3568=y
-CONFIG_ANDROID_VERSION=0x08000000
-CONFIG_ROCKCHIP_PM_DOMAINS=y
-CONFIG_ROCKCHIP_PVTM=y
-CONFIG_ROCKCHIP_SUSPEND_MODE=y
-CONFIG_ROCKCHIP_VENDOR_STORAGE_UPDATE_LOADER=y
-CONFIG_PM_DEVFREQ=y
-CONFIG_DEVFREQ_GOV_PERFORMANCE=y
-CONFIG_DEVFREQ_GOV_POWERSAVE=y
-CONFIG_DEVFREQ_GOV_USERSPACE=y
-CONFIG_ARM_ROCKCHIP_BUS_DEVFREQ=y
-CONFIG_ARM_ROCKCHIP_DMC_DEVFREQ=y
-CONFIG_ARM_ROCKCHIP_DMC_DEBUG=y
-CONFIG_DEVFREQ_EVENT_ROCKCHIP_NOCP=y
-CONFIG_IIO=y
-CONFIG_IIO_BUFFER=y
-CONFIG_IIO_BUFFER_CB=y
-CONFIG_IIO_KFIFO_BUF=y
-CONFIG_IIO_TRIGGER=y
-CONFIG_ROCKCHIP_SARADC=y
-CONFIG_PWM=y
-CONFIG_PWM_ROCKCHIP=y
-CONFIG_PHY_ROCKCHIP_CSI2_DPHY=y
-CONFIG_PHY_ROCKCHIP_EMMC=y
-CONFIG_PHY_ROCKCHIP_INNO_HDMI_PHY=y
-CONFIG_PHY_ROCKCHIP_INNO_MIPI_DPHY=y
-CONFIG_PHY_ROCKCHIP_INNO_USB2=y
-CONFIG_PHY_ROCKCHIP_INNO_USB3=y
-CONFIG_PHY_ROCKCHIP_INNO_VIDEO_COMBO_PHY=y
-CONFIG_PHY_ROCKCHIP_NANENG_COMBO_PHY=y
-CONFIG_PHY_ROCKCHIP_NANENG_EDP=y
-CONFIG_PHY_ROCKCHIP_PCIE=y
-CONFIG_PHY_ROCKCHIP_SNPS_PCIE3=y
-CONFIG_PHY_ROCKCHIP_TYPEC=y
-CONFIG_PHY_ROCKCHIP_USB=y
-CONFIG_ANDROID=y
-CONFIG_ANDROID_BINDER_IPC=y
-CONFIG_ROCKCHIP_EFUSE=y
-CONFIG_ROCKCHIP_OTP=y
-CONFIG_TEE=y
-CONFIG_OPTEE=y
-CONFIG_RK_NAND=y
-CONFIG_RK_HEADSET=y
-CONFIG_ROCKCHIP_RKNPU=y
-CONFIG_EXT4_FS=y
-CONFIG_EXT4_FS_POSIX_ACL=y
-CONFIG_EXT4_FS_SECURITY=y
-CONFIG_EXT4_ENCRYPTION=y
-CONFIG_F2FS_FS=y
-CONFIG_F2FS_FS_SECURITY=y
-CONFIG_F2FS_FS_ENCRYPTION=y
-CONFIG_FS_ENCRYPTION_INLINE_CRYPT=y
-CONFIG_FS_VERITY=y
-CONFIG_FS_VERITY_BUILTIN_SIGNATURES=y
-CONFIG_QUOTA=y
-CONFIG_QUOTA_NETLINK_INTERFACE=y
-CONFIG_QFMT_V2=y
-CONFIG_FUSE_FS=y
-CONFIG_OVERLAY_FS=y
-CONFIG_INCREMENTAL_FS=y
-CONFIG_ISO9660_FS=y
-CONFIG_JOLIET=y
-CONFIG_ZISOFS=y
-CONFIG_UDF_FS=y
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_TMPFS=y
-CONFIG_TMPFS_POSIX_ACL=y
-CONFIG_SDCARD_FS=y
-CONFIG_PSTORE=y
-CONFIG_PSTORE_CONSOLE=y
-CONFIG_PSTORE_PMSG=y
-CONFIG_PSTORE_RAM=y
-CONFIG_CIFS=y
-CONFIG_CIFS_XATTR=y
-CONFIG_CIFS_POSIX=y
-# CONFIG_CIFS_DEBUG is not set
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_ASCII=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_NLS_UTF8=y
-CONFIG_UNICODE=y
-CONFIG_SECURITY_PERF_EVENTS_RESTRICT=y
-CONFIG_SECURITY=y
-CONFIG_SECURITY_NETWORK=y
-CONFIG_LSM_MMAP_MIN_ADDR=4096
-CONFIG_HARDENED_USERCOPY=y
-CONFIG_STATIC_USERMODEHELPER=y
-CONFIG_STATIC_USERMODEHELPER_PATH=""
-CONFIG_SECURITY_SELINUX=y
-CONFIG_TEE_SUPPORT=y
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_LZ4=y
-CONFIG_CRYPTO_ANSI_CPRNG=y
-CONFIG_CRYPTO_DEV_ROCKCHIP=y
-CONFIG_PRINTK_TIME=y
-CONFIG_DEBUG_INFO=y
-CONFIG_DEBUG_FS=y
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_SOFTLOCKUP_DETECTOR=y
-CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=10
-CONFIG_PANIC_TIMEOUT=5
-CONFIG_SCHEDSTATS=y
-CONFIG_SCHED_STACK_END_CHECK=y
-# CONFIG_DEBUG_PREEMPT is not set
-CONFIG_ENABLE_DEFAULT_TRACERS=y
-CONFIG_BUG_ON_DATA_CORRUPTION=y
-
-
-CONFIG_SPI_WK2XXX=y
-CONFIG_MTD_M25P80=m
-CONFIG_GPIO_SUB_POSITION=y
-CONFIG_VIDEO_XC7022=y
-CONFIG_SND_SOC_ES8323=y
-CONFIG_KEYBOARD_ROCKCHIP=y
-CONFIG_KEYBOARD_RK_KEYS=y
-CONFIG_RTC_DRV_HYM8563=y
-CONFIG_SENSORS_NTC_THERMISTOR=y
-CONFIG_PC9202_WATCHDOG=y
-CONFIG_BT_RTKBTUSB=y
-
-CONFIG_SND_SOC_ROCKCHIP_HDMI_DP=y
-CONFIG_SND_SOC_ROCKCHIP_CDNDP=y
-CONFIG_PHY_ROCKCHIP_DP=y
-
-CONFIG_RK_IR_NO_DEEP_SLEEP=y
+version https://git-lfs.github.com/spec/v1
+oid sha256:43f80ea0663c548e9f35f772981087c1854a7ea6d9ab757b8ff960246c8ff54d
+size 25798
diff --git a/kernel/drivers/base/component.c b/kernel/drivers/base/component.c
index ee4d3b388f..a539a379c8 100644
--- a/kernel/drivers/base/component.c
+++ b/kernel/drivers/base/component.c
@@ -1,607 +1,3 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Componentized device handling.
- *
- * This is work in progress.  We gather up the component devices into a list,
- * and bind them when instructed.  At the moment, we're specific to the DRM
- * subsystem, and only handles one master device, but this doesn't have to be
- * the case.
- */
-#include <linux/component.h>
-#include <linux/device.h>
-#include <linux/kref.h>
-#include <linux/list.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/slab.h>
-#include <linux/debugfs.h>
-
-struct component;
-
-struct component_match_array {
-	void *data;
-	int (*compare)(struct device *, void *);
-	void (*release)(struct device *, void *);
-	struct component *component;
-	bool duplicate;
-};
-
-struct component_match {
-	size_t alloc;
-	size_t num;
-	struct component_match_array *compare;
-};
-
-struct master {
-	struct list_head node;
-	bool bound;
-
-	const struct component_master_ops *ops;
-	struct device *dev;
-	struct component_match *match;
-	struct dentry *dentry;
-};
-
-struct component {
-	struct list_head node;
-	struct master *master;
-	bool bound;
-
-	const struct component_ops *ops;
-	struct device *dev;
-};
-
-static DEFINE_MUTEX(component_mutex);
-static LIST_HEAD(component_list);
-static LIST_HEAD(masters);
-
-#ifdef CONFIG_DEBUG_FS
-
-static struct dentry *component_debugfs_dir;
-
-static int component_devices_show(struct seq_file *s, void *data)
-{
-	struct master *m = s->private;
-	struct component_match *match = m->match;
-	size_t i;
-
-	mutex_lock(&component_mutex);
-	seq_printf(s, "%-40s %20s\n", "master name", "status");
-	seq_puts(s, "-------------------------------------------------------------\n");
-	seq_printf(s, "%-40s %20s\n\n",
-		   dev_name(m->dev), m->bound ? "bound" : "not bound");
-
-	seq_printf(s, "%-40s %20s\n", "device name", "status");
-	seq_puts(s, "-------------------------------------------------------------\n");
-	for (i = 0; i < match->num; i++) {
-		struct component *component = match->compare[i].component;
-
-		seq_printf(s, "%-40s %20s\n",
-			   component ? dev_name(component->dev) : "(unknown)",
-			   component ? (component->bound ? "bound" : "not bound") : "not registered");
-	}
-	mutex_unlock(&component_mutex);
-
-	return 0;
-}
-
-static int component_devices_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, component_devices_show, inode->i_private);
-}
-
-static const struct file_operations component_devices_fops = {
-	.open = component_devices_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static int __init component_debug_init(void)
-{
-	component_debugfs_dir = debugfs_create_dir("device_component", NULL);
-
-	return 0;
-}
-
-core_initcall(component_debug_init);
-
-static void component_master_debugfs_add(struct master *m)
-{
-	m->dentry = debugfs_create_file(dev_name(m->dev), 0444,
-					component_debugfs_dir,
-					m, &component_devices_fops);
-}
-
-static void component_master_debugfs_del(struct master *m)
-{
-	debugfs_remove(m->dentry);
-	m->dentry = NULL;
-}
-
-#else
-
-static void component_master_debugfs_add(struct master *m)
-{ }
-
-static void component_master_debugfs_del(struct master *m)
-{ }
-
-#endif
-
-static struct master *__master_find(struct device *dev,
-	const struct component_master_ops *ops)
-{
-	struct master *m;
-
-	list_for_each_entry(m, &masters, node)
-		if (m->dev == dev && (!ops || m->ops == ops))
-			return m;
-
-	return NULL;
-}
-
-static struct component *find_component(struct master *master,
-	int (*compare)(struct device *, void *), void *compare_data)
-{
-	struct component *c;
-
-	list_for_each_entry(c, &component_list, node) {
-		if (c->master && c->master != master)
-			continue;
-
-		if (compare(c->dev, compare_data))
-			return c;
-	}
-
-	return NULL;
-}
-
-static int find_components(struct master *master)
-{
-	struct component_match *match = master->match;
-	size_t i;
-	int ret = 0;
-
-	/*
-	 * Scan the array of match functions and attach
-	 * any components which are found to this master.
-	 */
-	for (i = 0; i < match->num; i++) {
-		struct component_match_array *mc = &match->compare[i];
-		struct component *c;
-
-		dev_dbg(master->dev, "Looking for component %zu\n", i);
-
-		if (match->compare[i].component)
-			continue;
-
-		c = find_component(master, mc->compare, mc->data);
-		if (!c) {
-			ret = -ENXIO;
-			break;
-		}
-
-		dev_dbg(master->dev, "found component %s, duplicate %u\n", dev_name(c->dev), !!c->master);
-
-		/* Attach this component to the master */
-		match->compare[i].duplicate = !!c->master;
-		match->compare[i].component = c;
-		c->master = master;
-	}
-	return ret;
-}
-
-/* Detach component from associated master */
-static void remove_component(struct master *master, struct component *c)
-{
-	size_t i;
-
-	/* Detach the component from this master. */
-	for (i = 0; i < master->match->num; i++)
-		if (master->match->compare[i].component == c)
-			master->match->compare[i].component = NULL;
-}
-
-/*
- * Try to bring up a master.  If component is NULL, we're interested in
- * this master, otherwise it's a component which must be present to try
- * and bring up the master.
- *
- * Returns 1 for successful bringup, 0 if not ready, or -ve errno.
- */
-static int try_to_bring_up_master(struct master *master,
-	struct component *component)
-{
-	int ret;
-
-	dev_dbg(master->dev, "trying to bring up master\n");
-
-	if (find_components(master)) {
-		dev_dbg(master->dev, "master has incomplete components\n");
-		return 0;
-	}
-
-	if (component && component->master != master) {
-		dev_dbg(master->dev, "master is not for this component (%s)\n",
-			dev_name(component->dev));
-		return 0;
-	}
-
-	if (!devres_open_group(master->dev, NULL, GFP_KERNEL))
-		return -ENOMEM;
-
-	/* Found all components */
-	ret = master->ops->bind(master->dev);
-	if (ret < 0) {
-		devres_release_group(master->dev, NULL);
-		if (ret != -EPROBE_DEFER)
-			dev_info(master->dev, "master bind failed: %d\n", ret);
-		return ret;
-	}
-
-	master->bound = true;
-	return 1;
-}
-
-static int try_to_bring_up_masters(struct component *component)
-{
-	struct master *m;
-	int ret = 0;
-
-	list_for_each_entry(m, &masters, node) {
-		if (!m->bound) {
-			ret = try_to_bring_up_master(m, component);
-			if (ret != 0)
-				break;
-		}
-	}
-
-	return ret;
-}
-
-static void take_down_master(struct master *master)
-{
-	if (master->bound) {
-		master->ops->unbind(master->dev);
-		devres_release_group(master->dev, NULL);
-		master->bound = false;
-	}
-}
-
-static void component_match_release(struct device *master,
-	struct component_match *match)
-{
-	unsigned int i;
-
-	for (i = 0; i < match->num; i++) {
-		struct component_match_array *mc = &match->compare[i];
-
-		if (mc->release)
-			mc->release(master, mc->data);
-	}
-
-	kfree(match->compare);
-}
-
-static void devm_component_match_release(struct device *dev, void *res)
-{
-	component_match_release(dev, res);
-}
-
-static int component_match_realloc(struct device *dev,
-	struct component_match *match, size_t num)
-{
-	struct component_match_array *new;
-
-	if (match->alloc == num)
-		return 0;
-
-	new = kmalloc_array(num, sizeof(*new), GFP_KERNEL);
-	if (!new)
-		return -ENOMEM;
-
-	if (match->compare) {
-		memcpy(new, match->compare, sizeof(*new) *
-					    min(match->num, num));
-		kfree(match->compare);
-	}
-	match->compare = new;
-	match->alloc = num;
-
-	return 0;
-}
-
-/*
- * Add a component to be matched, with a release function.
- *
- * The match array is first created or extended if necessary.
- */
-void component_match_add_release(struct device *master,
-	struct component_match **matchptr,
-	void (*release)(struct device *, void *),
-	int (*compare)(struct device *, void *), void *compare_data)
-{
-	struct component_match *match = *matchptr;
-
-	if (IS_ERR(match))
-		return;
-
-	if (!match) {
-		match = devres_alloc(devm_component_match_release,
-				     sizeof(*match), GFP_KERNEL);
-		if (!match) {
-			*matchptr = ERR_PTR(-ENOMEM);
-			return;
-		}
-
-		devres_add(master, match);
-
-		*matchptr = match;
-	}
-
-	if (match->num == match->alloc) {
-		size_t new_size = match->alloc + 16;
-		int ret;
-
-		ret = component_match_realloc(master, match, new_size);
-		if (ret) {
-			*matchptr = ERR_PTR(ret);
-			return;
-		}
-	}
-
-	match->compare[match->num].compare = compare;
-	match->compare[match->num].release = release;
-	match->compare[match->num].data = compare_data;
-	match->compare[match->num].component = NULL;
-	match->num++;
-}
-EXPORT_SYMBOL(component_match_add_release);
-
-static void free_master(struct master *master)
-{
-	struct component_match *match = master->match;
-	int i;
-
-	component_master_debugfs_del(master);
-	list_del(&master->node);
-
-	if (match) {
-		for (i = 0; i < match->num; i++) {
-			struct component *c = match->compare[i].component;
-			if (c)
-				c->master = NULL;
-		}
-	}
-
-	kfree(master);
-}
-
-int component_master_add_with_match(struct device *dev,
-	const struct component_master_ops *ops,
-	struct component_match *match)
-{
-	struct master *master;
-	int ret;
-
-	/* Reallocate the match array for its true size */
-	ret = component_match_realloc(dev, match, match->num);
-	if (ret)
-		return ret;
-
-	master = kzalloc(sizeof(*master), GFP_KERNEL);
-	if (!master)
-		return -ENOMEM;
-
-	master->dev = dev;
-	master->ops = ops;
-	master->match = match;
-
-	component_master_debugfs_add(master);
-	/* Add to the list of available masters. */
-	mutex_lock(&component_mutex);
-	list_add(&master->node, &masters);
-
-	ret = try_to_bring_up_master(master, NULL);
-
-	if (ret < 0)
-		free_master(master);
-
-	mutex_unlock(&component_mutex);
-
-	return ret < 0 ? ret : 0;
-}
-EXPORT_SYMBOL_GPL(component_master_add_with_match);
-
-void component_master_del(struct device *dev,
-	const struct component_master_ops *ops)
-{
-	struct master *master;
-
-	mutex_lock(&component_mutex);
-	master = __master_find(dev, ops);
-	if (master) {
-		take_down_master(master);
-		free_master(master);
-	}
-	mutex_unlock(&component_mutex);
-}
-EXPORT_SYMBOL_GPL(component_master_del);
-
-static void component_unbind(struct component *component,
-	struct master *master, void *data)
-{
-	WARN_ON(!component->bound);
-
-	component->ops->unbind(component->dev, master->dev, data);
-	component->bound = false;
-
-	/* Release all resources claimed in the binding of this component */
-	devres_release_group(component->dev, component);
-}
-
-void component_unbind_all(struct device *master_dev, void *data)
-{
-	struct master *master;
-	struct component *c;
-	size_t i;
-
-	WARN_ON(!mutex_is_locked(&component_mutex));
-
-	master = __master_find(master_dev, NULL);
-	if (!master)
-		return;
-
-	/* Unbind components in reverse order */
-	for (i = master->match->num; i--; )
-		if (!master->match->compare[i].duplicate) {
-			c = master->match->compare[i].component;
-			component_unbind(c, master, data);
-		}
-}
-EXPORT_SYMBOL_GPL(component_unbind_all);
-
-static int component_bind(struct component *component, struct master *master,
-	void *data)
-{
-	int ret;
-
-	/*
-	 * Each component initialises inside its own devres group.
-	 * This allows us to roll-back a failed component without
-	 * affecting anything else.
-	 */
-	if (!devres_open_group(master->dev, NULL, GFP_KERNEL))
-		return -ENOMEM;
-
-	/*
-	 * Also open a group for the device itself: this allows us
-	 * to release the resources claimed against the sub-device
-	 * at the appropriate moment.
-	 */
-	if (!devres_open_group(component->dev, component, GFP_KERNEL)) {
-		devres_release_group(master->dev, NULL);
-		return -ENOMEM;
-	}
-
-	dev_dbg(master->dev, "binding %s (ops %ps)\n",
-		dev_name(component->dev), component->ops);
-
-	ret = component->ops->bind(component->dev, master->dev, data);
-	if (!ret) {
-		component->bound = true;
-
-		/*
-		 * Close the component device's group so that resources
-		 * allocated in the binding are encapsulated for removal
-		 * at unbind.  Remove the group on the DRM device as we
-		 * can clean those resources up independently.
-		 */
-		devres_close_group(component->dev, NULL);
-		devres_remove_group(master->dev, NULL);
-
-		dev_info(master->dev, "bound %s (ops %ps)\n",
-			 dev_name(component->dev), component->ops);
-	} else {
-		devres_release_group(component->dev, NULL);
-		devres_release_group(master->dev, NULL);
-
-		if (ret != -EPROBE_DEFER)
-			dev_err(master->dev, "failed to bind %s (ops %ps): %d\n",
-				dev_name(component->dev), component->ops, ret);
-	}
-
-	return ret;
-}
-
-int component_bind_all(struct device *master_dev, void *data)
-{
-	struct master *master;
-	struct component *c;
-	size_t i;
-	int ret = 0;
-
-	WARN_ON(!mutex_is_locked(&component_mutex));
-
-	master = __master_find(master_dev, NULL);
-	if (!master)
-		return -EINVAL;
-
-	/* Bind components in match order */
-	for (i = 0; i < master->match->num; i++)
-		if (!master->match->compare[i].duplicate) {
-			c = master->match->compare[i].component;
-			ret = component_bind(c, master, data);
-			if (ret)
-				break;
-		}
-
-	if (ret != 0) {
-		for (; i > 0; i--)
-			if (!master->match->compare[i - 1].duplicate) {
-				c = master->match->compare[i - 1].component;
-				component_unbind(c, master, data);
-			}
-	}
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(component_bind_all);
-
-int component_add(struct device *dev, const struct component_ops *ops)
-{
-	struct component *component;
-	int ret;
-
-	component = kzalloc(sizeof(*component), GFP_KERNEL);
-	if (!component)
-		return -ENOMEM;
-
-	component->ops = ops;
-	component->dev = dev;
-
-	dev_dbg(dev, "adding component (ops %ps)\n", ops);
-
-	mutex_lock(&component_mutex);
-	list_add_tail(&component->node, &component_list);
-
-	ret = try_to_bring_up_masters(component);
-	if (ret < 0) {
-		if (component->master)
-			remove_component(component->master, component);
-		list_del(&component->node);
-
-		kfree(component);
-	}
-	mutex_unlock(&component_mutex);
-
-	return ret < 0 ? ret : 0;
-}
-EXPORT_SYMBOL_GPL(component_add);
-
-void component_del(struct device *dev, const struct component_ops *ops)
-{
-	struct component *c, *component = NULL;
-
-	mutex_lock(&component_mutex);
-	list_for_each_entry(c, &component_list, node)
-		if (c->dev == dev && c->ops == ops) {
-			list_del(&c->node);
-			component = c;
-			break;
-		}
-
-	if (component && component->master) {
-		take_down_master(component->master);
-		remove_component(component->master, component);
-	}
-
-	mutex_unlock(&component_mutex);
-
-	WARN_ON(!component);
-	kfree(component);
-}
-EXPORT_SYMBOL_GPL(component_del);
-
-MODULE_LICENSE("GPL v2");
+version https://git-lfs.github.com/spec/v1
+oid sha256:38dbd004e0b3594ed3b5b0b3620ed34acbc5f49a629e069e936b49608e05c953
+size 13994
diff --git a/kernel/drivers/gpu/drm/panel/panel-simple.c b/kernel/drivers/gpu/drm/panel/panel-simple.c
index d411cf6b3b..c2fa56c755 100644
--- a/kernel/drivers/gpu/drm/panel/panel-simple.c
+++ b/kernel/drivers/gpu/drm/panel/panel-simple.c
@@ -1,3537 +1,3 @@
-/*
- * Copyright (C) 2013, NVIDIA Corporation.  All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sub license,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#include <linux/backlight.h>
-#include <linux/gpio/consumer.h>
-#include <linux/module.h>
-#include <linux/of_platform.h>
-#include <linux/platform_device.h>
-#include <linux/regulator/consumer.h>
-
-#include <drm/drmP.h>
-#include <drm/drm_crtc.h>
-#include <drm/drm_mipi_dsi.h>
-#include <drm/drm_panel.h>
-
-#include <video/display_timing.h>
-#include <video/mipi_display.h>
-#include <video/of_display_timing.h>
-#include <linux/of_graph.h>
-#include <video/videomode.h>
-
-#include "../rockchip/rockchip_drm_drv.h"
-
-struct panel_cmd_header {
-	u8 data_type;
-	u8 delay;
-	u8 payload_length;
-} __packed;
-
-struct panel_cmd_desc {
-	struct panel_cmd_header header;
-	u8 *payload;
-};
-
-struct panel_cmd_seq {
-	struct panel_cmd_desc *cmds;
-	unsigned int cmd_cnt;
-};
-
-struct panel_desc {
-	const struct drm_display_mode *modes;
-	unsigned int num_modes;
-	const struct display_timing *timings;
-	unsigned int num_timings;
-
-	unsigned int bpc;
-
-	/**
-	 * @width: width (in millimeters) of the panel's active display area
-	 * @height: height (in millimeters) of the panel's active display area
-	 */
-	struct {
-		unsigned int width;
-		unsigned int height;
-	} size;
-
-	/**
-	 * @prepare: the time (in milliseconds) that it takes for the panel to
-	 *           become ready and start receiving video data
-	 * @enable: the time (in milliseconds) that it takes for the panel to
-	 *          display the first valid frame after starting to receive
-	 *          video data
-	 * @disable: the time (in milliseconds) that it takes for the panel to
-	 *           turn the display off (no content is visible)
-	 * @unprepare: the time (in milliseconds) that it takes for the panel
-	 *             to power itself down completely
-	 * @reset: the time (in milliseconds) that it takes for the panel
-	 *         to reset itself completely
-	 * @init: the time (in milliseconds) that it takes for the panel to
-	 *	  send init command sequence after reset deassert
-	 */
-	struct {
-		unsigned int prepare;
-		unsigned int enable;
-		unsigned int disable;
-		unsigned int unprepare;
-		unsigned int reset;
-		unsigned int init;
-	} delay;
-
-	u32 bus_format;
-	u32 bus_flags;
-
-	struct panel_cmd_seq *init_seq;
-	struct panel_cmd_seq *exit_seq;
-};
-
-struct panel_simple {
-	struct drm_panel base;
-	struct mipi_dsi_device *dsi;
-	bool prepared;
-	bool enabled;
-	bool power_invert;
-	bool reset_always_high;
-
-	const struct panel_desc *desc;
-
-	struct backlight_device *backlight;
-	struct regulator *supply;
-	struct regulator_bulk_data supplies[2];
-	struct i2c_adapter *ddc;
-
-	struct gpio_desc *enable_gpio;
-	struct gpio_desc *reset_gpio;
-	struct gpio_desc *enable_5v_gpio;
-	struct gpio_desc *enable_tc_gpio;
-	int cmd_type;
-
-	struct gpio_desc *spi_sdi_gpio;
-	struct gpio_desc *spi_scl_gpio;
-	struct gpio_desc *spi_cs_gpio;
-	struct device_node *np_crtc;
-};
-
-enum rockchip_cmd_type {
-	CMD_TYPE_DEFAULT,
-	CMD_TYPE_SPI,
-	CMD_TYPE_MCU
-};
-
-enum MCU_IOCTL {
-	MCU_WRCMD = 0,
-	MCU_WRDATA,
-	MCU_SETBYPASS,
-};
-
-enum rockchip_spi_cmd_type {
-	SPI_3LINE_9BIT_MODE_CMD = 0,
-	SPI_3LINE_9BIT_MODE_DATA,
-	SPI_4LINE_8BIT_MODE,
-};
-
-static void panel_simple_sleep(unsigned int msec)
-{
-	if (msec > 20)
-		msleep(msec);
-	else
-		usleep_range(msec * 1000, (msec + 1) * 1000);
-}
-
-static inline int get_panel_cmd_type(const char *s)
-{
-	if (!s)
-		return -EINVAL;
-
-	if (strncmp(s, "spi", 3) == 0)
-		return CMD_TYPE_SPI;
-	else if (strncmp(s, "mcu", 3) == 0)
-		return CMD_TYPE_MCU;
-
-	return CMD_TYPE_DEFAULT;
-}
-
-static inline struct panel_simple *to_panel_simple(struct drm_panel *panel)
-{
-	return container_of(panel, struct panel_simple, base);
-}
-
-static int panel_simple_parse_cmd_seq(struct device *dev,
-				      const u8 *data, int length,
-				      struct panel_cmd_seq *seq)
-{
-	struct panel_cmd_header *header;
-	struct panel_cmd_desc *desc;
-	char *buf, *d;
-	unsigned int i, cnt, len;
-
-	if (!seq)
-		return -EINVAL;
-
-	buf = devm_kmemdup(dev, data, length, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	d = buf;
-	len = length;
-	cnt = 0;
-	while (len > sizeof(*header)) {
-		header = (struct panel_cmd_header *)d;
-
-		d += sizeof(*header);
-		len -= sizeof(*header);
-
-		if (header->payload_length > len)
-			return -EINVAL;
-
-		d += header->payload_length;
-		len -= header->payload_length;
-		cnt++;
-	}
-
-	if (len)
-		return -EINVAL;
-
-	seq->cmd_cnt = cnt;
-	seq->cmds = devm_kcalloc(dev, cnt, sizeof(*desc), GFP_KERNEL);
-	if (!seq->cmds)
-		return -ENOMEM;
-
-	d = buf;
-	len = length;
-	for (i = 0; i < cnt; i++) {
-		header = (struct panel_cmd_header *)d;
-		len -= sizeof(*header);
-		d += sizeof(*header);
-
-		desc = &seq->cmds[i];
-		desc->header = *header;
-		desc->payload = d;
-
-		d += header->payload_length;
-		len -= header->payload_length;
-	}
-
-	return 0;
-}
-
-static void panel_simple_spi_write_cmd(struct panel_simple *panel,
-				       u8 type, int value)
-{
-	int i;
-
-	gpiod_direction_output(panel->spi_cs_gpio, 0);
-
-	/**
-	 * send cmd or data flag for 3line 9bit serial data
-	 */
-	if (type == SPI_3LINE_9BIT_MODE_CMD) {
-		gpiod_direction_output(panel->spi_sdi_gpio, 0);
-		gpiod_direction_output(panel->spi_scl_gpio, 0);
-		udelay(10);
-		gpiod_direction_output(panel->spi_scl_gpio, 1);
-		udelay(10);
-	} else if (type == SPI_3LINE_9BIT_MODE_DATA) {
-		gpiod_direction_output(panel->spi_sdi_gpio, 1);
-		gpiod_direction_output(panel->spi_scl_gpio, 0);
-		udelay(10);
-		gpiod_direction_output(panel->spi_scl_gpio, 1);
-		udelay(10);
-	}
-
-	/**
-	 * send the 8bit value from the MSB
-	 */
-	for (i = 0; i < 8; i++) {
-		if (value & 0x80)
-			gpiod_direction_output(panel->spi_sdi_gpio, 1);
-		else
-			gpiod_direction_output(panel->spi_sdi_gpio, 0);
-
-		gpiod_direction_output(panel->spi_scl_gpio, 0);
-		udelay(10);
-		gpiod_direction_output(panel->spi_scl_gpio, 1);
-		value <<= 1;
-		udelay(10);
-	}
-
-	gpiod_direction_output(panel->spi_cs_gpio, 1);
-}
-
-static int panel_simple_xfer_mcu_cmd_seq(struct panel_simple *panel,
-				      struct panel_cmd_seq *cmds)
-{
-	int i;
-
-	if (!cmds)
-		return -EINVAL;
-
-	rockchip_drm_crtc_send_mcu_cmd(panel->base.drm,
-				       panel->np_crtc, MCU_SETBYPASS, 1);
-	for (i = 0; i < cmds->cmd_cnt; i++) {
-		struct panel_cmd_desc *cmd = &cmds->cmds[i];
-		u32 value = 0;
-
-		value = cmd->payload[0];
-		rockchip_drm_crtc_send_mcu_cmd(panel->base.drm, panel->np_crtc,
-					       cmd->header.data_type, value);
-		if (cmd->header.delay)
-			panel_simple_sleep(cmd->header.delay);
-	}
-	rockchip_drm_crtc_send_mcu_cmd(panel->base.drm,
-				       panel->np_crtc, MCU_SETBYPASS, 0);
-
-	return 0;
-}
-
-static int panel_simple_xfer_spi_cmd_seq(struct panel_simple *panel,
-					 struct panel_cmd_seq *cmds)
-{
-	int i;
-
-	if (!cmds)
-		return -EINVAL;
-
-	for (i = 0; i < cmds->cmd_cnt; i++) {
-		struct panel_cmd_desc *cmd = &cmds->cmds[i];
-		int value = 0;
-
-		if (cmd->header.payload_length == 2)
-			value = (cmd->payload[0] << 8) | cmd->payload[1];
-		else
-			value = cmd->payload[0];
-		panel_simple_spi_write_cmd(panel, cmd->header.data_type, value);
-
-		if (cmd->header.delay)
-			panel_simple_sleep(cmd->header.delay);
-	}
-
-	return 0;
-}
-
-#if IS_ENABLED(CONFIG_DRM_MIPI_DSI)
-static int panel_simple_xfer_dsi_cmd_seq(struct panel_simple *panel,
-				     struct panel_cmd_seq *seq)
-{
-	struct device *dev = panel->base.dev;
-	struct mipi_dsi_device *dsi = panel->dsi;
-	unsigned int i;
-	int err;
-
-	if (!seq)
-		return -EINVAL;
-
-	for (i = 0; i < seq->cmd_cnt; i++) {
-		struct panel_cmd_desc *cmd = &seq->cmds[i];
-
-		switch (cmd->header.data_type) {
-		case MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:
-		case MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:
-		case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:
-		case MIPI_DSI_GENERIC_LONG_WRITE:
-			err = mipi_dsi_generic_write(dsi, cmd->payload,
-						     cmd->header.payload_length);
-			break;
-		case MIPI_DSI_DCS_SHORT_WRITE:
-		case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
-		case MIPI_DSI_DCS_LONG_WRITE:
-			err = mipi_dsi_dcs_write_buffer(dsi, cmd->payload,
-							cmd->header.payload_length);
-			break;
-		default:
-			return -EINVAL;
-		}
-
-		if (err < 0)
-			dev_err(dev, "failed to write dcs cmd: %d\n", err);
-
-		if (cmd->header.delay)
-			panel_simple_sleep(cmd->header.delay);
-	}
-
-	return 0;
-}
-#else
-static inline int panel_simple_xfer_dsi_cmd_seq(struct panel_simple *panel,
-						struct panel_cmd_seq *seq)
-{
-	return -EINVAL;
-}
-#endif
-
-static int panel_simple_get_fixed_modes(struct panel_simple *panel)
-{
-	struct drm_connector *connector = panel->base.connector;
-	struct drm_device *drm = panel->base.drm;
-	struct drm_display_mode *mode;
-	unsigned int i, num = 0;
-
-	if (!panel->desc)
-		return 0;
-
-	for (i = 0; i < panel->desc->num_timings; i++) {
-		const struct display_timing *dt = &panel->desc->timings[i];
-		struct videomode vm;
-
-		videomode_from_timing(dt, &vm);
-		mode = drm_mode_create(drm);
-		if (!mode) {
-			dev_err(drm->dev, "failed to add mode %ux%u\n",
-				dt->hactive.typ, dt->vactive.typ);
-			continue;
-		}
-
-		drm_display_mode_from_videomode(&vm, mode);
-
-		mode->type |= DRM_MODE_TYPE_DRIVER;
-
-		if (panel->desc->num_timings == 1)
-			mode->type |= DRM_MODE_TYPE_PREFERRED;
-
-		drm_mode_probed_add(connector, mode);
-		num++;
-	}
-
-	for (i = 0; i < panel->desc->num_modes; i++) {
-		const struct drm_display_mode *m = &panel->desc->modes[i];
-
-		mode = drm_mode_duplicate(drm, m);
-		if (!mode) {
-			dev_err(drm->dev, "failed to add mode %ux%u@%u\n",
-				m->hdisplay, m->vdisplay, m->vrefresh);
-			continue;
-		}
-
-		mode->type |= DRM_MODE_TYPE_DRIVER;
-
-		if (panel->desc->num_modes == 1)
-			mode->type |= DRM_MODE_TYPE_PREFERRED;
-
-		drm_mode_set_name(mode);
-
-		drm_mode_probed_add(connector, mode);
-		num++;
-	}
-
-	if (panel->desc->bpc)
-		connector->display_info.bpc = panel->desc->bpc;
-	if (panel->desc->size.width)
-		connector->display_info.width_mm = panel->desc->size.width;
-	if (panel->desc->size.height)
-		connector->display_info.height_mm = panel->desc->size.height;
-	if (panel->desc->bus_format)
-		drm_display_info_set_bus_formats(&connector->display_info,
-						 &panel->desc->bus_format, 1);
-	if (panel->desc->bus_flags)
-		connector->display_info.bus_flags = panel->desc->bus_flags;
-
-	return num;
-}
-
-static int panel_simple_regulator_enable(struct panel_simple *p)
-{
-	int err;
-
-	err = regulator_bulk_enable(ARRAY_SIZE(p->supplies), p->supplies);
-	if (err < 0)
-		return err;
-
-	if (p->power_invert) {
-		if (regulator_is_enabled(p->supply) > 0)
-			regulator_disable(p->supply);
-	} else {
-		err = regulator_enable(p->supply);
-		if (err < 0)
-			return err;
-	}
-
-	return 0;
-}
-
-static int panel_simple_regulator_disable(struct panel_simple *p)
-{
-	int err;
-
-	if (p->power_invert) {
-		if (!regulator_is_enabled(p->supply)) {
-			err = regulator_enable(p->supply);
-			if (err < 0)
-				return err;
-		}
-	} else {
-		regulator_disable(p->supply);
-	}
-
-	regulator_bulk_disable(ARRAY_SIZE(p->supplies), p->supplies);
-
-	return 0;
-}
-
-static int panel_simple_loader_protect(struct drm_panel *panel, bool on)
-{
-	struct panel_simple *p = to_panel_simple(panel);
-	int err;
-
-	if (on) {
-		err = panel_simple_regulator_enable(p);
-		if (err < 0) {
-			dev_err(panel->dev, "failed to enable supply: %d\n",
-				err);
-			return err;
-		}
-
-		p->prepared = true;
-		p->enabled = true;
-	} else {
-		/* do nothing */
-	}
-
-	return 0;
-}
-
-static int panel_simple_disable(struct drm_panel *panel)
-{
-	struct panel_simple *p = to_panel_simple(panel);
-	int err = 0;
-
-	if (!p->enabled)
-		return 0;
-
-	if (p->backlight) {
-		p->backlight->props.power = FB_BLANK_POWERDOWN;
-		p->backlight->props.state |= BL_CORE_FBBLANK;
-		backlight_update_status(p->backlight);
-	}
-
-	if (p->desc->delay.disable)
-		panel_simple_sleep(p->desc->delay.disable);
-
-	if (p->cmd_type == CMD_TYPE_MCU) {
-		err = panel_simple_xfer_mcu_cmd_seq(p, p->desc->exit_seq);
-		if (err)
-			dev_err(panel->dev, "failed to send exit cmds seq\n");
-	}
-	p->enabled = false;
-
-	return 0;
-}
-
-static int panel_simple_unprepare(struct drm_panel *panel)
-{
-	struct panel_simple *p = to_panel_simple(panel);
-	int err = 0;
-
-	if (!p->prepared)
-		return 0;
-
-	if (p->desc->exit_seq) {
-		if (p->dsi)
-			panel_simple_xfer_dsi_cmd_seq(p, p->desc->exit_seq);
-		else if (p->cmd_type == CMD_TYPE_SPI)
-			err = panel_simple_xfer_spi_cmd_seq(p, p->desc->exit_seq);
-		if (err)
-			dev_err(panel->dev, "failed to send exit cmds seq\n");
-	}
-
-	gpiod_direction_output(p->reset_gpio, 1);
-
-	//gpiod_direction_output(p->enable_gpio, 0);
-	if (p->enable_tc_gpio)
-		gpiod_direction_output(p->enable_tc_gpio, 1);
-	panel_simple_regulator_disable(p);
-
-	if (p->desc->delay.unprepare)
-		panel_simple_sleep(p->desc->delay.unprepare);
-
-	p->prepared = false;
-
-	return 0;
-}
-
-static int panel_simple_prepare(struct drm_panel *panel)
-{
-	struct panel_simple *p = to_panel_simple(panel);
-	int err;
-
-	if (p->prepared)
-		return 0;
-
-	err = panel_simple_regulator_enable(p);
-	if (err < 0) {
-		dev_err(panel->dev, "failed to enable supply: %d\n", err);
-		return err;
-	}
-
-	if (p->enable_5v_gpio)
-		gpiod_direction_output(p->enable_5v_gpio, 1);
-	gpiod_direction_output(p->enable_gpio, 1);
-
-	if (p->desc->delay.prepare)
-		panel_simple_sleep(p->desc->delay.prepare);
-
-	if (p->enable_tc_gpio)
-		gpiod_direction_output(p->enable_tc_gpio, 1);
-
-	if(p->reset_always_high)
-	{
-		gpiod_direction_output(p->reset_gpio, 1);
-	}else
-	{
-		gpiod_direction_output(p->reset_gpio, 0);
-	}
-
-	if (p->desc->delay.reset){
-		panel_simple_sleep(p->desc->delay.reset);
-	}
-
-	gpiod_direction_output(p->reset_gpio, 1);
-
-	if (p->desc->delay.init)
-		panel_simple_sleep(p->desc->delay.init);
-
-	if (p->desc->init_seq) {
-		if (p->dsi)
-			panel_simple_xfer_dsi_cmd_seq(p, p->desc->init_seq);
-		else if (p->cmd_type == CMD_TYPE_SPI)
-			err = panel_simple_xfer_spi_cmd_seq(p, p->desc->init_seq);
-		if (err)
-			dev_err(panel->dev, "failed to send init cmds seq\n");
-	}
-
-	p->prepared = true;
-
-	return 0;
-}
-
-static int panel_simple_enable(struct drm_panel *panel)
-{
-	struct panel_simple *p = to_panel_simple(panel);
-	int err = 0;
-
-	if (p->enabled)
-		return 0;
-
-	if (p->cmd_type == CMD_TYPE_MCU) {
-		err = panel_simple_xfer_mcu_cmd_seq(p, p->desc->init_seq);
-		if (err)
-			dev_err(panel->dev, "failed to send init cmds seq\n");
-	}
-	if (p->desc->delay.enable)
-		panel_simple_sleep(p->desc->delay.enable);
-
-	if (p->backlight) {
-		p->backlight->props.state &= ~BL_CORE_FBBLANK;
-		p->backlight->props.power = FB_BLANK_UNBLANK;
-		backlight_update_status(p->backlight);
-	}
-
-	p->enabled = true;
-
-	return 0;
-}
-
-static int panel_simple_get_modes(struct drm_panel *panel)
-{
-	struct panel_simple *p = to_panel_simple(panel);
-	int num = 0;
-
-	/* probe EDID if a DDC bus is available */
-	if (p->ddc) {
-		struct edid *edid = drm_get_edid(panel->connector, p->ddc);
-		drm_connector_update_edid_property(panel->connector, edid);
-		if (edid) {
-			num += drm_add_edid_modes(panel->connector, edid);
-			kfree(edid);
-		}
-	}
-
-	/* add hard-coded panel modes */
-	num += panel_simple_get_fixed_modes(p);
-
-	return num;
-}
-
-static int panel_simple_get_timings(struct drm_panel *panel,
-				    unsigned int num_timings,
-				    struct display_timing *timings)
-{
-	struct panel_simple *p = to_panel_simple(panel);
-	unsigned int i;
-
-	if (p->desc->num_timings < num_timings)
-		num_timings = p->desc->num_timings;
-
-	if (timings)
-		for (i = 0; i < num_timings; i++)
-			timings[i] = p->desc->timings[i];
-
-	return p->desc->num_timings;
-}
-
-static const struct drm_panel_funcs panel_simple_funcs = {
-	.loader_protect = panel_simple_loader_protect,
-	.disable = panel_simple_disable,
-	.unprepare = panel_simple_unprepare,
-	.prepare = panel_simple_prepare,
-	.enable = panel_simple_enable,
-	.get_modes = panel_simple_get_modes,
-	.get_timings = panel_simple_get_timings,
-};
-
-static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
-{
-	struct device_node *backlight, *ddc;
-	struct panel_simple *panel;
-	const char *cmd_type;
-	int err;
-	
-	panel = devm_kzalloc(dev, sizeof(*panel), GFP_KERNEL);
-	if (!panel)
-		return -ENOMEM;
-
-	panel->enabled = false;
-	panel->prepared = false;
-	panel->desc = desc;
-
-	panel->supply = devm_regulator_get(dev, "power");
-	if (IS_ERR(panel->supply))
-		return PTR_ERR(panel->supply);
-
-	panel->supplies[0].supply = "vsp";
-	panel->supplies[1].supply = "vsn";
-
-	err = devm_regulator_bulk_get(dev, ARRAY_SIZE(panel->supplies),
-				      panel->supplies);
-	if (err)
-		return err;
-
-	panel->enable_gpio = devm_gpiod_get_optional(dev, "enable",
-						     GPIOD_ASIS);
-	if (IS_ERR(panel->enable_gpio)) {
-		err = PTR_ERR(panel->enable_gpio);
-		if (err != -EPROBE_DEFER)
-			dev_err(dev, "failed to get enable GPIO: %d\n", err);
-		return err;
-	}
-
-	panel->enable_5v_gpio = devm_gpiod_get_optional(dev, "enable-5v", 0);
-	if (IS_ERR(panel->enable_5v_gpio)) {
-		err = PTR_ERR(panel->enable_5v_gpio);
-		dev_err(dev, "failed to request enable 5v GPIO: %d\n", err);
-
-	}
-
-	panel->enable_tc_gpio = devm_gpiod_get_optional(dev, "enable-tc", 0);
-	if (IS_ERR(panel->enable_tc_gpio)) {
-		err = PTR_ERR(panel->enable_tc_gpio);
-		dev_err(dev, "failed to request enable tc GPIO: %d\n", err);
-
-	}
-	panel->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_ASIS);
-	if (IS_ERR(panel->reset_gpio)) {
-		err = PTR_ERR(panel->reset_gpio);
-		if (err != -EPROBE_DEFER)
-			dev_err(dev, "failed to get reset GPIO: %d\n", err);
-		return err;
-	}
-	panel->reset_always_high =
-			of_property_read_bool(dev->of_node, "reset_always_high");
-	
-	if (of_property_read_string(dev->of_node, "rockchip,cmd-type",
-				    &cmd_type))
-		panel->cmd_type = CMD_TYPE_DEFAULT;
-	else
-		panel->cmd_type = get_panel_cmd_type(cmd_type);
-
-	if (panel->cmd_type == CMD_TYPE_SPI) {
-		panel->spi_sdi_gpio =
-				devm_gpiod_get_optional(dev, "spi-sdi", 0);
-		if (IS_ERR(panel->spi_sdi_gpio)) {
-			err = PTR_ERR(panel->spi_sdi_gpio);
-			dev_err(dev, "failed to request spi_sdi: %d\n", err);
-			return err;
-		}
-
-		panel->spi_scl_gpio =
-				devm_gpiod_get_optional(dev, "spi-scl", 0);
-		if (IS_ERR(panel->spi_scl_gpio)) {
-			err = PTR_ERR(panel->spi_scl_gpio);
-			dev_err(dev, "failed to request spi_scl: %d\n", err);
-			return err;
-		}
-
-		panel->spi_cs_gpio = devm_gpiod_get_optional(dev, "spi-cs", 0);
-		if (IS_ERR(panel->spi_cs_gpio)) {
-			err = PTR_ERR(panel->spi_cs_gpio);
-			dev_err(dev, "failed to request spi_cs: %d\n", err);
-			return err;
-		}
-		gpiod_direction_output(panel->spi_cs_gpio, 1);
-		gpiod_direction_output(panel->spi_sdi_gpio, 1);
-		gpiod_direction_output(panel->spi_scl_gpio, 1);
-	} else if (panel->cmd_type == CMD_TYPE_MCU) {
-		struct device_node *port, *endpoint;
-		struct device_node *np;
-
-		port = of_graph_get_port_by_id(dev->of_node, 0);
-		if (port) {
-			endpoint = of_get_next_child(port, NULL);
-			/* get connect device node */
-			np = of_graph_get_remote_port_parent(endpoint);
-
-			port = of_graph_get_port_by_id(np, 0);
-			if (port) {
-				endpoint = of_get_next_child(port, NULL);
-				/* get crtc device node */
-				np = of_graph_get_remote_port_parent(endpoint);
-				panel->np_crtc = np;
-			}
-		}
-	}
-
-	panel->power_invert =
-			of_property_read_bool(dev->of_node, "power-invert");
-
-	backlight = of_parse_phandle(dev->of_node, "backlight", 0);
-	if (backlight) {
-		panel->backlight = of_find_backlight_by_node(backlight);
-		of_node_put(backlight);
-
-		if (!panel->backlight)
-			return -EPROBE_DEFER;
-	}
-
-	ddc = of_parse_phandle(dev->of_node, "ddc-i2c-bus", 0);
-	if (ddc) {
-		panel->ddc = of_find_i2c_adapter_by_node(ddc);
-		of_node_put(ddc);
-
-		if (!panel->ddc) {
-			err = -EPROBE_DEFER;
-			goto free_backlight;
-		}
-	}
-
-	drm_panel_init(&panel->base);
-	panel->base.dev = dev;
-	panel->base.funcs = &panel_simple_funcs;
-
-	err = drm_panel_add(&panel->base);
-	if (err < 0)
-		goto free_ddc;
-
-	dev_set_drvdata(dev, panel);
-
-	return 0;
-
-free_ddc:
-	if (panel->ddc)
-		put_device(&panel->ddc->dev);
-free_backlight:
-	if (panel->backlight)
-		put_device(&panel->backlight->dev);
-
-	return err;
-}
-
-static int panel_simple_remove(struct device *dev)
-{
-	struct panel_simple *panel = dev_get_drvdata(dev);
-
-	drm_panel_remove(&panel->base);
-
-	panel_simple_disable(&panel->base);
-	panel_simple_unprepare(&panel->base);
-
-	if (panel->ddc)
-		put_device(&panel->ddc->dev);
-
-	if (panel->backlight)
-		put_device(&panel->backlight->dev);
-
-	return 0;
-}
-
-static void panel_simple_shutdown(struct device *dev)
-{
-	struct panel_simple *panel = dev_get_drvdata(dev);
-
-	panel_simple_disable(&panel->base);
-
-	if (panel->prepared) {
-		gpiod_direction_output(panel->reset_gpio, 1);
-		gpiod_direction_output(panel->enable_gpio, 0);
-		gpiod_direction_output(panel->enable_tc_gpio, 0);
-		panel_simple_regulator_disable(panel);
-	}
-}
-
-static const struct drm_display_mode ampire_am_480272h3tmqw_t01h_mode = {
-	.clock = 9000,
-	.hdisplay = 480,
-	.hsync_start = 480 + 2,
-	.hsync_end = 480 + 2 + 41,
-	.htotal = 480 + 2 + 41 + 2,
-	.vdisplay = 272,
-	.vsync_start = 272 + 2,
-	.vsync_end = 272 + 2 + 10,
-	.vtotal = 272 + 2 + 10 + 2,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC,
-};
-
-static const struct panel_desc ampire_am_480272h3tmqw_t01h = {
-	.modes = &ampire_am_480272h3tmqw_t01h_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 105,
-		.height = 67,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
-};
-
-static const struct drm_display_mode ampire_am800480r3tmqwa1h_mode = {
-	.clock = 33333,
-	.hdisplay = 800,
-	.hsync_start = 800 + 0,
-	.hsync_end = 800 + 0 + 255,
-	.htotal = 800 + 0 + 255 + 0,
-	.vdisplay = 480,
-	.vsync_start = 480 + 2,
-	.vsync_end = 480 + 2 + 45,
-	.vtotal = 480 + 2 + 45 + 0,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC,
-};
-
-static const struct panel_desc ampire_am800480r3tmqwa1h = {
-	.modes = &ampire_am800480r3tmqwa1h_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 152,
-		.height = 91,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
-};
-
-static const struct display_timing santek_st0700i5y_rbslw_f_timing = {
-	.pixelclock = { 26400000, 33300000, 46800000 },
-	.hactive = { 800, 800, 800 },
-	.hfront_porch = { 16, 210, 354 },
-	.hback_porch = { 45, 36, 6 },
-	.hsync_len = { 1, 10, 40 },
-	.vactive = { 480, 480, 480 },
-	.vfront_porch = { 7, 22, 147 },
-	.vback_porch = { 22, 13, 3 },
-	.vsync_len = { 1, 10, 20 },
-	.flags = DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW |
-		DISPLAY_FLAGS_DE_HIGH | DISPLAY_FLAGS_PIXDATA_POSEDGE
-};
-
-static const struct panel_desc armadeus_st0700_adapt = {
-	.timings = &santek_st0700i5y_rbslw_f_timing,
-	.num_timings = 1,
-	.bpc = 6,
-	.size = {
-		.width = 154,
-		.height = 86,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
-	.bus_flags = DRM_BUS_FLAG_DE_HIGH | DRM_BUS_FLAG_PIXDATA_POSEDGE,
-};
-
-static const struct drm_display_mode auo_b101aw03_mode = {
-	.clock = 51450,
-	.hdisplay = 1024,
-	.hsync_start = 1024 + 156,
-	.hsync_end = 1024 + 156 + 8,
-	.htotal = 1024 + 156 + 8 + 156,
-	.vdisplay = 600,
-	.vsync_start = 600 + 16,
-	.vsync_end = 600 + 16 + 6,
-	.vtotal = 600 + 16 + 6 + 16,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc auo_b101aw03 = {
-	.modes = &auo_b101aw03_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 223,
-		.height = 125,
-	},
-};
-
-static const struct drm_display_mode auo_b101ean01_mode = {
-	.clock = 72500,
-	.hdisplay = 1280,
-	.hsync_start = 1280 + 119,
-	.hsync_end = 1280 + 119 + 32,
-	.htotal = 1280 + 119 + 32 + 21,
-	.vdisplay = 800,
-	.vsync_start = 800 + 4,
-	.vsync_end = 800 + 4 + 20,
-	.vtotal = 800 + 4 + 20 + 8,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc auo_b101ean01 = {
-	.modes = &auo_b101ean01_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 217,
-		.height = 136,
-	},
-};
-
-static const struct drm_display_mode auo_b101xtn01_mode = {
-	.clock = 72000,
-	.hdisplay = 1366,
-	.hsync_start = 1366 + 20,
-	.hsync_end = 1366 + 20 + 70,
-	.htotal = 1366 + 20 + 70,
-	.vdisplay = 768,
-	.vsync_start = 768 + 14,
-	.vsync_end = 768 + 14 + 42,
-	.vtotal = 768 + 14 + 42,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
-};
-
-static const struct panel_desc auo_b101xtn01 = {
-	.modes = &auo_b101xtn01_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 223,
-		.height = 125,
-	},
-};
-
-static const struct drm_display_mode auo_b116xw03_mode = {
-	.clock = 70589,
-	.hdisplay = 1366,
-	.hsync_start = 1366 + 40,
-	.hsync_end = 1366 + 40 + 40,
-	.htotal = 1366 + 40 + 40 + 32,
-	.vdisplay = 768,
-	.vsync_start = 768 + 10,
-	.vsync_end = 768 + 10 + 12,
-	.vtotal = 768 + 10 + 12 + 6,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc auo_b116xw03 = {
-	.modes = &auo_b116xw03_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 256,
-		.height = 144,
-	},
-};
-
-static const struct drm_display_mode auo_b133xtn01_mode = {
-	.clock = 69500,
-	.hdisplay = 1366,
-	.hsync_start = 1366 + 48,
-	.hsync_end = 1366 + 48 + 32,
-	.htotal = 1366 + 48 + 32 + 20,
-	.vdisplay = 768,
-	.vsync_start = 768 + 3,
-	.vsync_end = 768 + 3 + 6,
-	.vtotal = 768 + 3 + 6 + 13,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc auo_b133xtn01 = {
-	.modes = &auo_b133xtn01_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 293,
-		.height = 165,
-	},
-};
-
-static const struct drm_display_mode auo_b133htn01_mode = {
-	.clock = 150660,
-	.hdisplay = 1920,
-	.hsync_start = 1920 + 172,
-	.hsync_end = 1920 + 172 + 80,
-	.htotal = 1920 + 172 + 80 + 60,
-	.vdisplay = 1080,
-	.vsync_start = 1080 + 25,
-	.vsync_end = 1080 + 25 + 10,
-	.vtotal = 1080 + 25 + 10 + 10,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc auo_b133htn01 = {
-	.modes = &auo_b133htn01_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 293,
-		.height = 165,
-	},
-	.delay = {
-		.prepare = 105,
-		.enable = 20,
-		.unprepare = 50,
-	},
-};
-
-static const struct display_timing auo_g070vvn01_timings = {
-	.pixelclock = { 33300000, 34209000, 45000000 },
-	.hactive = { 800, 800, 800 },
-	.hfront_porch = { 20, 40, 200 },
-	.hback_porch = { 87, 40, 1 },
-	.hsync_len = { 1, 48, 87 },
-	.vactive = { 480, 480, 480 },
-	.vfront_porch = { 5, 13, 200 },
-	.vback_porch = { 31, 31, 29 },
-	.vsync_len = { 1, 1, 3 },
-};
-
-static const struct panel_desc auo_g070vvn01 = {
-	.timings = &auo_g070vvn01_timings,
-	.num_timings = 1,
-	.bpc = 8,
-	.size = {
-		.width = 152,
-		.height = 91,
-	},
-	.delay = {
-		.prepare = 200,
-		.enable = 50,
-		.disable = 50,
-		.unprepare = 1000,
-	},
-};
-
-static const struct drm_display_mode auo_g104sn02_mode = {
-	.clock = 40000,
-	.hdisplay = 800,
-	.hsync_start = 800 + 40,
-	.hsync_end = 800 + 40 + 216,
-	.htotal = 800 + 40 + 216 + 128,
-	.vdisplay = 600,
-	.vsync_start = 600 + 10,
-	.vsync_end = 600 + 10 + 35,
-	.vtotal = 600 + 10 + 35 + 2,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc auo_g104sn02 = {
-	.modes = &auo_g104sn02_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 211,
-		.height = 158,
-	},
-};
-
-static const struct display_timing auo_g133han01_timings = {
-	.pixelclock = { 134000000, 141200000, 149000000 },
-	.hactive = { 1920, 1920, 1920 },
-	.hfront_porch = { 39, 58, 77 },
-	.hback_porch = { 59, 88, 117 },
-	.hsync_len = { 28, 42, 56 },
-	.vactive = { 1080, 1080, 1080 },
-	.vfront_porch = { 3, 8, 11 },
-	.vback_porch = { 5, 14, 19 },
-	.vsync_len = { 4, 14, 19 },
-};
-
-static const struct panel_desc auo_g133han01 = {
-	.timings = &auo_g133han01_timings,
-	.num_timings = 1,
-	.bpc = 8,
-	.size = {
-		.width = 293,
-		.height = 165,
-	},
-	.delay = {
-		.prepare = 200,
-		.enable = 50,
-		.disable = 50,
-		.unprepare = 1000,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA,
-};
-
-static const struct display_timing auo_g185han01_timings = {
-	.pixelclock = { 120000000, 144000000, 175000000 },
-	.hactive = { 1920, 1920, 1920 },
-	.hfront_porch = { 36, 120, 148 },
-	.hback_porch = { 24, 88, 108 },
-	.hsync_len = { 20, 48, 64 },
-	.vactive = { 1080, 1080, 1080 },
-	.vfront_porch = { 6, 10, 40 },
-	.vback_porch = { 2, 5, 20 },
-	.vsync_len = { 2, 5, 20 },
-};
-
-static const struct panel_desc auo_g185han01 = {
-	.timings = &auo_g185han01_timings,
-	.num_timings = 1,
-	.bpc = 8,
-	.size = {
-		.width = 409,
-		.height = 230,
-	},
-	.delay = {
-		.prepare = 50,
-		.enable = 200,
-		.disable = 110,
-		.unprepare = 1000,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
-};
-
-static const struct display_timing auo_p320hvn03_timings = {
-	.pixelclock = { 106000000, 148500000, 164000000 },
-	.hactive = { 1920, 1920, 1920 },
-	.hfront_porch = { 25, 50, 130 },
-	.hback_porch = { 25, 50, 130 },
-	.hsync_len = { 20, 40, 105 },
-	.vactive = { 1080, 1080, 1080 },
-	.vfront_porch = { 8, 17, 150 },
-	.vback_porch = { 8, 17, 150 },
-	.vsync_len = { 4, 11, 100 },
-};
-
-static const struct panel_desc auo_p320hvn03 = {
-	.timings = &auo_p320hvn03_timings,
-	.num_timings = 1,
-	.bpc = 8,
-	.size = {
-		.width = 698,
-		.height = 393,
-	},
-	.delay = {
-		.prepare = 1,
-		.enable = 450,
-		.unprepare = 500,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
-};
-
-static const struct drm_display_mode auo_t215hvn01_mode = {
-	.clock = 148800,
-	.hdisplay = 1920,
-	.hsync_start = 1920 + 88,
-	.hsync_end = 1920 + 88 + 44,
-	.htotal = 1920 + 88 + 44 + 148,
-	.vdisplay = 1080,
-	.vsync_start = 1080 + 4,
-	.vsync_end = 1080 + 4 + 5,
-	.vtotal = 1080 + 4 + 5 + 36,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc auo_t215hvn01 = {
-	.modes = &auo_t215hvn01_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 430,
-		.height = 270,
-	},
-	.delay = {
-		.disable = 5,
-		.unprepare = 1000,
-	}
-};
-
-static const struct drm_display_mode avic_tm070ddh03_mode = {
-	.clock = 51200,
-	.hdisplay = 1024,
-	.hsync_start = 1024 + 160,
-	.hsync_end = 1024 + 160 + 4,
-	.htotal = 1024 + 160 + 4 + 156,
-	.vdisplay = 600,
-	.vsync_start = 600 + 17,
-	.vsync_end = 600 + 17 + 1,
-	.vtotal = 600 + 17 + 1 + 17,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc avic_tm070ddh03 = {
-	.modes = &avic_tm070ddh03_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 154,
-		.height = 90,
-	},
-	.delay = {
-		.prepare = 20,
-		.enable = 200,
-		.disable = 200,
-	},
-};
-
-static const struct drm_display_mode boe_hv070wsa_mode = {
-	.clock = 40800,
-	.hdisplay = 1024,
-	.hsync_start = 1024 + 90,
-	.hsync_end = 1024 + 90 + 90,
-	.htotal = 1024 + 90 + 90 + 90,
-	.vdisplay = 600,
-	.vsync_start = 600 + 3,
-	.vsync_end = 600 + 3 + 4,
-	.vtotal = 600 + 3 + 4 + 3,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc boe_hv070wsa = {
-	.modes = &boe_hv070wsa_mode,
-	.num_modes = 1,
-	.size = {
-		.width = 154,
-		.height = 90,
-	},
-};
-
-static const struct drm_display_mode boe_nv101wxmn51_modes[] = {
-	{
-		.clock = 71900,
-		.hdisplay = 1280,
-		.hsync_start = 1280 + 48,
-		.hsync_end = 1280 + 48 + 32,
-		.htotal = 1280 + 48 + 32 + 80,
-		.vdisplay = 800,
-		.vsync_start = 800 + 3,
-		.vsync_end = 800 + 3 + 5,
-		.vtotal = 800 + 3 + 5 + 24,
-		.vrefresh = 60,
-	},
-	{
-		.clock = 57500,
-		.hdisplay = 1280,
-		.hsync_start = 1280 + 48,
-		.hsync_end = 1280 + 48 + 32,
-		.htotal = 1280 + 48 + 32 + 80,
-		.vdisplay = 800,
-		.vsync_start = 800 + 3,
-		.vsync_end = 800 + 3 + 5,
-		.vtotal = 800 + 3 + 5 + 24,
-		.vrefresh = 48,
-	},
-};
-
-static const struct panel_desc boe_nv101wxmn51 = {
-	.modes = boe_nv101wxmn51_modes,
-	.num_modes = ARRAY_SIZE(boe_nv101wxmn51_modes),
-	.bpc = 8,
-	.size = {
-		.width = 217,
-		.height = 136,
-	},
-	.delay = {
-		.prepare = 210,
-		.enable = 50,
-		.unprepare = 160,
-	},
-};
-
-static const struct drm_display_mode chunghwa_claa070wp03xg_mode = {
-	.clock = 66770,
-	.hdisplay = 800,
-	.hsync_start = 800 + 49,
-	.hsync_end = 800 + 49 + 33,
-	.htotal = 800 + 49 + 33 + 17,
-	.vdisplay = 1280,
-	.vsync_start = 1280 + 1,
-	.vsync_end = 1280 + 1 + 7,
-	.vtotal = 1280 + 1 + 7 + 15,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
-};
-
-static const struct panel_desc chunghwa_claa070wp03xg = {
-	.modes = &chunghwa_claa070wp03xg_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 94,
-		.height = 150,
-	},
-};
-
-static const struct drm_display_mode chunghwa_claa101wa01a_mode = {
-	.clock = 72070,
-	.hdisplay = 1366,
-	.hsync_start = 1366 + 58,
-	.hsync_end = 1366 + 58 + 58,
-	.htotal = 1366 + 58 + 58 + 58,
-	.vdisplay = 768,
-	.vsync_start = 768 + 4,
-	.vsync_end = 768 + 4 + 4,
-	.vtotal = 768 + 4 + 4 + 4,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc chunghwa_claa101wa01a = {
-	.modes = &chunghwa_claa101wa01a_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 220,
-		.height = 120,
-	},
-};
-
-static const struct drm_display_mode chunghwa_claa101wb01_mode = {
-	.clock = 69300,
-	.hdisplay = 1366,
-	.hsync_start = 1366 + 48,
-	.hsync_end = 1366 + 48 + 32,
-	.htotal = 1366 + 48 + 32 + 20,
-	.vdisplay = 768,
-	.vsync_start = 768 + 16,
-	.vsync_end = 768 + 16 + 8,
-	.vtotal = 768 + 16 + 8 + 16,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc chunghwa_claa101wb01 = {
-	.modes = &chunghwa_claa101wb01_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 223,
-		.height = 125,
-	},
-};
-
-static const struct drm_display_mode dataimage_scf0700c48ggu18_mode = {
-	.clock = 33260,
-	.hdisplay = 800,
-	.hsync_start = 800 + 40,
-	.hsync_end = 800 + 40 + 128,
-	.htotal = 800 + 40 + 128 + 88,
-	.vdisplay = 480,
-	.vsync_start = 480 + 10,
-	.vsync_end = 480 + 10 + 2,
-	.vtotal = 480 + 10 + 2 + 33,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
-};
-
-static const struct panel_desc dataimage_scf0700c48ggu18 = {
-	.modes = &dataimage_scf0700c48ggu18_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 152,
-		.height = 91,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
-	.bus_flags = DRM_BUS_FLAG_DE_HIGH | DRM_BUS_FLAG_PIXDATA_POSEDGE,
-};
-
-static const struct display_timing dlc_dlc0700yzg_1_timing = {
-	.pixelclock = { 45000000, 51200000, 57000000 },
-	.hactive = { 1024, 1024, 1024 },
-	.hfront_porch = { 100, 106, 113 },
-	.hback_porch = { 100, 106, 113 },
-	.hsync_len = { 100, 108, 114 },
-	.vactive = { 600, 600, 600 },
-	.vfront_porch = { 8, 11, 15 },
-	.vback_porch = { 8, 11, 15 },
-	.vsync_len = { 9, 13, 15 },
-	.flags = DISPLAY_FLAGS_DE_HIGH,
-};
-
-static const struct panel_desc dlc_dlc0700yzg_1 = {
-	.timings = &dlc_dlc0700yzg_1_timing,
-	.num_timings = 1,
-	.bpc = 6,
-	.size = {
-		.width = 154,
-		.height = 86,
-	},
-	.delay = {
-		.prepare = 30,
-		.enable = 200,
-		.disable = 200,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X7X3_SPWG,
-};
-
-static const struct drm_display_mode edt_et057090dhu_mode = {
-	.clock = 25175,
-	.hdisplay = 640,
-	.hsync_start = 640 + 16,
-	.hsync_end = 640 + 16 + 30,
-	.htotal = 640 + 16 + 30 + 114,
-	.vdisplay = 480,
-	.vsync_start = 480 + 10,
-	.vsync_end = 480 + 10 + 3,
-	.vtotal = 480 + 10 + 3 + 32,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
-};
-
-static const struct panel_desc edt_et057090dhu = {
-	.modes = &edt_et057090dhu_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 115,
-		.height = 86,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
-	.bus_flags = DRM_BUS_FLAG_DE_HIGH | DRM_BUS_FLAG_PIXDATA_NEGEDGE,
-};
-
-static const struct drm_display_mode edt_etm0700g0dh6_mode = {
-	.clock = 33260,
-	.hdisplay = 800,
-	.hsync_start = 800 + 40,
-	.hsync_end = 800 + 40 + 128,
-	.htotal = 800 + 40 + 128 + 88,
-	.vdisplay = 480,
-	.vsync_start = 480 + 10,
-	.vsync_end = 480 + 10 + 2,
-	.vtotal = 480 + 10 + 2 + 33,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
-};
-
-static const struct panel_desc edt_etm0700g0dh6 = {
-	.modes = &edt_etm0700g0dh6_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 152,
-		.height = 91,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
-	.bus_flags = DRM_BUS_FLAG_DE_HIGH | DRM_BUS_FLAG_PIXDATA_NEGEDGE,
-};
-
-static const struct panel_desc edt_etm0700g0bdh6 = {
-	.modes = &edt_etm0700g0dh6_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 152,
-		.height = 91,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
-	.bus_flags = DRM_BUS_FLAG_DE_HIGH | DRM_BUS_FLAG_PIXDATA_POSEDGE,
-};
-
-static const struct drm_display_mode foxlink_fl500wvr00_a0t_mode = {
-	.clock = 32260,
-	.hdisplay = 800,
-	.hsync_start = 800 + 168,
-	.hsync_end = 800 + 168 + 64,
-	.htotal = 800 + 168 + 64 + 88,
-	.vdisplay = 480,
-	.vsync_start = 480 + 37,
-	.vsync_end = 480 + 37 + 2,
-	.vtotal = 480 + 37 + 2 + 8,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc foxlink_fl500wvr00_a0t = {
-	.modes = &foxlink_fl500wvr00_a0t_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 108,
-		.height = 65,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
-};
-
-static const struct drm_display_mode giantplus_gpg482739qs5_mode = {
-	.clock = 9000,
-	.hdisplay = 480,
-	.hsync_start = 480 + 5,
-	.hsync_end = 480 + 5 + 1,
-	.htotal = 480 + 5 + 1 + 40,
-	.vdisplay = 272,
-	.vsync_start = 272 + 8,
-	.vsync_end = 272 + 8 + 1,
-	.vtotal = 272 + 8 + 1 + 8,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc giantplus_gpg482739qs5 = {
-	.modes = &giantplus_gpg482739qs5_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 95,
-		.height = 54,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
-};
-
-static const struct display_timing hannstar_hsd070pww1_timing = {
-	.pixelclock = { 64300000, 71100000, 82000000 },
-	.hactive = { 1280, 1280, 1280 },
-	.hfront_porch = { 1, 1, 10 },
-	.hback_porch = { 1, 1, 10 },
-	/*
-	 * According to the data sheet, the minimum horizontal blanking interval
-	 * is 54 clocks (1 + 52 + 1), but tests with a Nitrogen6X have shown the
-	 * minimum working horizontal blanking interval to be 60 clocks.
-	 */
-	.hsync_len = { 58, 158, 661 },
-	.vactive = { 800, 800, 800 },
-	.vfront_porch = { 1, 1, 10 },
-	.vback_porch = { 1, 1, 10 },
-	.vsync_len = { 1, 21, 203 },
-	.flags = DISPLAY_FLAGS_DE_HIGH,
-};
-
-static const struct panel_desc hannstar_hsd070pww1 = {
-	.timings = &hannstar_hsd070pww1_timing,
-	.num_timings = 1,
-	.bpc = 6,
-	.size = {
-		.width = 151,
-		.height = 94,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X7X3_SPWG,
-};
-
-static const struct display_timing hannstar_hsd100pxn1_timing = {
-	.pixelclock = { 55000000, 65000000, 75000000 },
-	.hactive = { 1024, 1024, 1024 },
-	.hfront_porch = { 40, 40, 40 },
-	.hback_porch = { 220, 220, 220 },
-	.hsync_len = { 20, 60, 100 },
-	.vactive = { 768, 768, 768 },
-	.vfront_porch = { 7, 7, 7 },
-	.vback_porch = { 21, 21, 21 },
-	.vsync_len = { 10, 10, 10 },
-	.flags = DISPLAY_FLAGS_DE_HIGH,
-};
-
-static const struct panel_desc hannstar_hsd100pxn1 = {
-	.timings = &hannstar_hsd100pxn1_timing,
-	.num_timings = 1,
-	.bpc = 6,
-	.size = {
-		.width = 203,
-		.height = 152,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X7X3_SPWG,
-};
-
-static const struct drm_display_mode hitachi_tx23d38vm0caa_mode = {
-	.clock = 33333,
-	.hdisplay = 800,
-	.hsync_start = 800 + 85,
-	.hsync_end = 800 + 85 + 86,
-	.htotal = 800 + 85 + 86 + 85,
-	.vdisplay = 480,
-	.vsync_start = 480 + 16,
-	.vsync_end = 480 + 16 + 13,
-	.vtotal = 480 + 16 + 13 + 16,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc hitachi_tx23d38vm0caa = {
-	.modes = &hitachi_tx23d38vm0caa_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 195,
-		.height = 117,
-	},
-	.delay = {
-		.enable = 160,
-		.disable = 160,
-	},
-};
-
-static const struct drm_display_mode innolux_at043tn24_mode = {
-	.clock = 9000,
-	.hdisplay = 480,
-	.hsync_start = 480 + 2,
-	.hsync_end = 480 + 2 + 41,
-	.htotal = 480 + 2 + 41 + 2,
-	.vdisplay = 272,
-	.vsync_start = 272 + 2,
-	.vsync_end = 272 + 2 + 10,
-	.vtotal = 272 + 2 + 10 + 2,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
-};
-
-static const struct panel_desc innolux_at043tn24 = {
-	.modes = &innolux_at043tn24_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 95,
-		.height = 54,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
-	.bus_flags = DRM_BUS_FLAG_DE_HIGH | DRM_BUS_FLAG_PIXDATA_POSEDGE,
-};
-
-static const struct drm_display_mode innolux_at070tn92_mode = {
-	.clock = 33333,
-	.hdisplay = 800,
-	.hsync_start = 800 + 210,
-	.hsync_end = 800 + 210 + 20,
-	.htotal = 800 + 210 + 20 + 46,
-	.vdisplay = 480,
-	.vsync_start = 480 + 22,
-	.vsync_end = 480 + 22 + 10,
-	.vtotal = 480 + 22 + 23 + 10,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc innolux_at070tn92 = {
-	.modes = &innolux_at070tn92_mode,
-	.num_modes = 1,
-	.size = {
-		.width = 154,
-		.height = 86,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
-};
-
-static const struct display_timing innolux_g070y2_l01_timing = {
-	.pixelclock = { 28000000, 29500000, 32000000 },
-	.hactive = { 800, 800, 800 },
-	.hfront_porch = { 61, 91, 141 },
-	.hback_porch = { 60, 90, 140 },
-	.hsync_len = { 12, 12, 12 },
-	.vactive = { 480, 480, 480 },
-	.vfront_porch = { 4, 9, 30 },
-	.vback_porch = { 4, 8, 28 },
-	.vsync_len = { 2, 2, 2 },
-	.flags = DISPLAY_FLAGS_DE_HIGH,
-};
-
-static const struct panel_desc innolux_g070y2_l01 = {
-	.timings = &innolux_g070y2_l01_timing,
-	.num_timings = 1,
-	.bpc = 6,
-	.size = {
-		.width = 152,
-		.height = 91,
-	},
-	.delay = {
-		.prepare = 10,
-		.enable = 100,
-		.disable = 100,
-		.unprepare = 800,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
-};
-
-static const struct display_timing innolux_g101ice_l01_timing = {
-	.pixelclock = { 60400000, 71100000, 74700000 },
-	.hactive = { 1280, 1280, 1280 },
-	.hfront_porch = { 41, 80, 100 },
-	.hback_porch = { 40, 79, 99 },
-	.hsync_len = { 1, 1, 1 },
-	.vactive = { 800, 800, 800 },
-	.vfront_porch = { 5, 11, 14 },
-	.vback_porch = { 4, 11, 14 },
-	.vsync_len = { 1, 1, 1 },
-	.flags = DISPLAY_FLAGS_DE_HIGH,
-};
-
-static const struct panel_desc innolux_g101ice_l01 = {
-	.timings = &innolux_g101ice_l01_timing,
-	.num_timings = 1,
-	.bpc = 8,
-	.size = {
-		.width = 217,
-		.height = 135,
-	},
-	.delay = {
-		.enable = 200,
-		.disable = 200,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
-};
-
-static const struct display_timing innolux_g121i1_l01_timing = {
-	.pixelclock = { 67450000, 71000000, 74550000 },
-	.hactive = { 1280, 1280, 1280 },
-	.hfront_porch = { 40, 80, 160 },
-	.hback_porch = { 39, 79, 159 },
-	.hsync_len = { 1, 1, 1 },
-	.vactive = { 800, 800, 800 },
-	.vfront_porch = { 5, 11, 100 },
-	.vback_porch = { 4, 11, 99 },
-	.vsync_len = { 1, 1, 1 },
-};
-
-static const struct panel_desc innolux_g121i1_l01 = {
-	.timings = &innolux_g121i1_l01_timing,
-	.num_timings = 1,
-	.bpc = 6,
-	.size = {
-		.width = 261,
-		.height = 163,
-	},
-	.delay = {
-		.enable = 200,
-		.disable = 20,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
-};
-
-static const struct drm_display_mode innolux_g121x1_l03_mode = {
-	.clock = 65000,
-	.hdisplay = 1024,
-	.hsync_start = 1024 + 0,
-	.hsync_end = 1024 + 1,
-	.htotal = 1024 + 0 + 1 + 320,
-	.vdisplay = 768,
-	.vsync_start = 768 + 38,
-	.vsync_end = 768 + 38 + 1,
-	.vtotal = 768 + 38 + 1 + 0,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
-};
-
-static const struct panel_desc innolux_g121x1_l03 = {
-	.modes = &innolux_g121x1_l03_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 246,
-		.height = 185,
-	},
-	.delay = {
-		.enable = 200,
-		.unprepare = 200,
-		.disable = 400,
-	},
-};
-
-static const struct drm_display_mode innolux_n116bge_mode = {
-	.clock = 76420,
-	.hdisplay = 1366,
-	.hsync_start = 1366 + 136,
-	.hsync_end = 1366 + 136 + 30,
-	.htotal = 1366 + 136 + 30 + 60,
-	.vdisplay = 768,
-	.vsync_start = 768 + 8,
-	.vsync_end = 768 + 8 + 12,
-	.vtotal = 768 + 8 + 12 + 12,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
-};
-
-static const struct panel_desc innolux_n116bge = {
-	.modes = &innolux_n116bge_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 256,
-		.height = 144,
-	},
-};
-
-static const struct drm_display_mode innolux_n156bge_l21_mode = {
-	.clock = 69300,
-	.hdisplay = 1366,
-	.hsync_start = 1366 + 16,
-	.hsync_end = 1366 + 16 + 34,
-	.htotal = 1366 + 16 + 34 + 50,
-	.vdisplay = 768,
-	.vsync_start = 768 + 2,
-	.vsync_end = 768 + 2 + 6,
-	.vtotal = 768 + 2 + 6 + 12,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc innolux_n156bge_l21 = {
-	.modes = &innolux_n156bge_l21_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 344,
-		.height = 193,
-	},
-};
-
-static const struct drm_display_mode innolux_tv123wam_mode = {
-	.clock = 206016,
-	.hdisplay = 2160,
-	.hsync_start = 2160 + 48,
-	.hsync_end = 2160 + 48 + 32,
-	.htotal = 2160 + 48 + 32 + 80,
-	.vdisplay = 1440,
-	.vsync_start = 1440 + 3,
-	.vsync_end = 1440 + 3 + 10,
-	.vtotal = 1440 + 3 + 10 + 27,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC,
-};
-
-static const struct panel_desc innolux_tv123wam = {
-	.modes = &innolux_tv123wam_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 259,
-		.height = 173,
-	},
-	.delay = {
-		.unprepare = 500,
-	},
-};
-
-static const struct drm_display_mode innolux_zj070na_01p_mode = {
-	.clock = 51501,
-	.hdisplay = 1024,
-	.hsync_start = 1024 + 128,
-	.hsync_end = 1024 + 128 + 64,
-	.htotal = 1024 + 128 + 64 + 128,
-	.vdisplay = 600,
-	.vsync_start = 600 + 16,
-	.vsync_end = 600 + 16 + 4,
-	.vtotal = 600 + 16 + 4 + 16,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc innolux_zj070na_01p = {
-	.modes = &innolux_zj070na_01p_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 154,
-		.height = 90,
-	},
-};
-
-static const struct display_timing koe_tx31d200vm0baa_timing = {
-	.pixelclock = { 39600000, 43200000, 48000000 },
-	.hactive = { 1280, 1280, 1280 },
-	.hfront_porch = { 16, 36, 56 },
-	.hback_porch = { 16, 36, 56 },
-	.hsync_len = { 8, 8, 8 },
-	.vactive = { 480, 480, 480 },
-	.vfront_porch = { 6, 21, 33 },
-	.vback_porch = { 6, 21, 33 },
-	.vsync_len = { 8, 8, 8 },
-	.flags = DISPLAY_FLAGS_DE_HIGH,
-};
-
-static const struct panel_desc koe_tx31d200vm0baa = {
-	.timings = &koe_tx31d200vm0baa_timing,
-	.num_timings = 1,
-	.bpc = 6,
-	.size = {
-		.width = 292,
-		.height = 109,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X7X3_SPWG,
-};
-
-static const struct display_timing kyo_tcg121xglp_timing = {
-	.pixelclock = { 52000000, 65000000, 71000000 },
-	.hactive = { 1024, 1024, 1024 },
-	.hfront_porch = { 2, 2, 2 },
-	.hback_porch = { 2, 2, 2 },
-	.hsync_len = { 86, 124, 244 },
-	.vactive = { 768, 768, 768 },
-	.vfront_porch = { 2, 2, 2 },
-	.vback_porch = { 2, 2, 2 },
-	.vsync_len = { 6, 34, 73 },
-	.flags = DISPLAY_FLAGS_DE_HIGH,
-};
-
-static const struct panel_desc kyo_tcg121xglp = {
-	.timings = &kyo_tcg121xglp_timing,
-	.num_timings = 1,
-	.bpc = 8,
-	.size = {
-		.width = 246,
-		.height = 184,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
-};
-
-static const struct drm_display_mode lg_lb070wv8_mode = {
-	.clock = 33246,
-	.hdisplay = 800,
-	.hsync_start = 800 + 88,
-	.hsync_end = 800 + 88 + 80,
-	.htotal = 800 + 88 + 80 + 88,
-	.vdisplay = 480,
-	.vsync_start = 480 + 10,
-	.vsync_end = 480 + 10 + 25,
-	.vtotal = 480 + 10 + 25 + 10,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc lg_lb070wv8 = {
-	.modes = &lg_lb070wv8_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 151,
-		.height = 91,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
-};
-
-static const struct drm_display_mode lg_lp079qx1_sp0v_mode = {
-	.clock = 200000,
-	.hdisplay = 1536,
-	.hsync_start = 1536 + 12,
-	.hsync_end = 1536 + 12 + 16,
-	.htotal = 1536 + 12 + 16 + 48,
-	.vdisplay = 2048,
-	.vsync_start = 2048 + 8,
-	.vsync_end = 2048 + 8 + 4,
-	.vtotal = 2048 + 8 + 4 + 8,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
-};
-
-static const struct panel_desc lg_lp079qx1_sp0v = {
-	.modes = &lg_lp079qx1_sp0v_mode,
-	.num_modes = 1,
-	.size = {
-		.width = 129,
-		.height = 171,
-	},
-};
-
-static const struct drm_display_mode lg_lp097qx1_spa1_mode = {
-	.clock = 205210,
-	.hdisplay = 2048,
-	.hsync_start = 2048 + 150,
-	.hsync_end = 2048 + 150 + 5,
-	.htotal = 2048 + 150 + 5 + 5,
-	.vdisplay = 1536,
-	.vsync_start = 1536 + 3,
-	.vsync_end = 1536 + 3 + 1,
-	.vtotal = 1536 + 3 + 1 + 9,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc lg_lp097qx1_spa1 = {
-	.modes = &lg_lp097qx1_spa1_mode,
-	.num_modes = 1,
-	.size = {
-		.width = 208,
-		.height = 147,
-	},
-};
-
-static const struct drm_display_mode lg_lp120up1_mode = {
-	.clock = 162300,
-	.hdisplay = 1920,
-	.hsync_start = 1920 + 40,
-	.hsync_end = 1920 + 40 + 40,
-	.htotal = 1920 + 40 + 40+ 80,
-	.vdisplay = 1280,
-	.vsync_start = 1280 + 4,
-	.vsync_end = 1280 + 4 + 4,
-	.vtotal = 1280 + 4 + 4 + 12,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc lg_lp120up1 = {
-	.modes = &lg_lp120up1_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 267,
-		.height = 183,
-	},
-};
-
-static const struct drm_display_mode lg_lp129qe_mode = {
-	.clock = 285250,
-	.hdisplay = 2560,
-	.hsync_start = 2560 + 48,
-	.hsync_end = 2560 + 48 + 32,
-	.htotal = 2560 + 48 + 32 + 80,
-	.vdisplay = 1700,
-	.vsync_start = 1700 + 3,
-	.vsync_end = 1700 + 3 + 10,
-	.vtotal = 1700 + 3 + 10 + 36,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc lg_lp129qe = {
-	.modes = &lg_lp129qe_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 272,
-		.height = 181,
-	},
-};
-
-static const struct drm_display_mode mitsubishi_aa070mc01_mode = {
-	.clock = 30400,
-	.hdisplay = 800,
-	.hsync_start = 800 + 0,
-	.hsync_end = 800 + 1,
-	.htotal = 800 + 0 + 1 + 160,
-	.vdisplay = 480,
-	.vsync_start = 480 + 0,
-	.vsync_end = 480 + 48 + 1,
-	.vtotal = 480 + 48 + 1 + 0,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
-};
-
-static const struct panel_desc mitsubishi_aa070mc01 = {
-	.modes = &mitsubishi_aa070mc01_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 152,
-		.height = 91,
-	},
-
-	.delay = {
-		.enable = 200,
-		.unprepare = 200,
-		.disable = 400,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
-	.bus_flags = DRM_BUS_FLAG_DE_HIGH,
-};
-
-static const struct display_timing nec_nl12880bc20_05_timing = {
-	.pixelclock = { 67000000, 71000000, 75000000 },
-	.hactive = { 1280, 1280, 1280 },
-	.hfront_porch = { 2, 30, 30 },
-	.hback_porch = { 6, 100, 100 },
-	.hsync_len = { 2, 30, 30 },
-	.vactive = { 800, 800, 800 },
-	.vfront_porch = { 5, 5, 5 },
-	.vback_porch = { 11, 11, 11 },
-	.vsync_len = { 7, 7, 7 },
-};
-
-static const struct panel_desc nec_nl12880bc20_05 = {
-	.timings = &nec_nl12880bc20_05_timing,
-	.num_timings = 1,
-	.bpc = 8,
-	.size = {
-		.width = 261,
-		.height = 163,
-	},
-	.delay = {
-		.enable = 50,
-		.disable = 50,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
-};
-
-static const struct drm_display_mode nec_nl4827hc19_05b_mode = {
-	.clock = 10870,
-	.hdisplay = 480,
-	.hsync_start = 480 + 2,
-	.hsync_end = 480 + 2 + 41,
-	.htotal = 480 + 2 + 41 + 2,
-	.vdisplay = 272,
-	.vsync_start = 272 + 2,
-	.vsync_end = 272 + 2 + 4,
-	.vtotal = 272 + 2 + 4 + 2,
-	.vrefresh = 74,
-	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
-};
-
-static const struct panel_desc nec_nl4827hc19_05b = {
-	.modes = &nec_nl4827hc19_05b_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 95,
-		.height = 54,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
-	.bus_flags = DRM_BUS_FLAG_PIXDATA_POSEDGE,
-};
-
-static const struct drm_display_mode netron_dy_e231732_mode = {
-	.clock = 66000,
-	.hdisplay = 1024,
-	.hsync_start = 1024 + 160,
-	.hsync_end = 1024 + 160 + 70,
-	.htotal = 1024 + 160 + 70 + 90,
-	.vdisplay = 600,
-	.vsync_start = 600 + 127,
-	.vsync_end = 600 + 127 + 20,
-	.vtotal = 600 + 127 + 20 + 3,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc netron_dy_e231732 = {
-	.modes = &netron_dy_e231732_mode,
-	.num_modes = 1,
-	.size = {
-		.width = 154,
-		.height = 87,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
-};
-
-static const struct drm_display_mode newhaven_nhd_43_480272ef_atxl_mode = {
-	.clock = 9000,
-	.hdisplay = 480,
-	.hsync_start = 480 + 2,
-	.hsync_end = 480 + 2 + 41,
-	.htotal = 480 + 2 + 41 + 2,
-	.vdisplay = 272,
-	.vsync_start = 272 + 2,
-	.vsync_end = 272 + 2 + 10,
-	.vtotal = 272 + 2 + 10 + 2,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
-};
-
-static const struct panel_desc newhaven_nhd_43_480272ef_atxl = {
-	.modes = &newhaven_nhd_43_480272ef_atxl_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 95,
-		.height = 54,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
-	.bus_flags = DRM_BUS_FLAG_DE_HIGH | DRM_BUS_FLAG_PIXDATA_POSEDGE |
-		     DRM_BUS_FLAG_SYNC_POSEDGE,
-};
-
-static const struct display_timing nlt_nl192108ac18_02d_timing = {
-	.pixelclock = { 130000000, 148350000, 163000000 },
-	.hactive = { 1920, 1920, 1920 },
-	.hfront_porch = { 80, 100, 100 },
-	.hback_porch = { 100, 120, 120 },
-	.hsync_len = { 50, 60, 60 },
-	.vactive = { 1080, 1080, 1080 },
-	.vfront_porch = { 12, 30, 30 },
-	.vback_porch = { 4, 10, 10 },
-	.vsync_len = { 4, 5, 5 },
-};
-
-static const struct panel_desc nlt_nl192108ac18_02d = {
-	.timings = &nlt_nl192108ac18_02d_timing,
-	.num_timings = 1,
-	.bpc = 8,
-	.size = {
-		.width = 344,
-		.height = 194,
-	},
-	.delay = {
-		.unprepare = 500,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
-};
-
-static const struct drm_display_mode nvd_9128_mode = {
-	.clock = 29500,
-	.hdisplay = 800,
-	.hsync_start = 800 + 130,
-	.hsync_end = 800 + 130 + 98,
-	.htotal = 800 + 0 + 130 + 98,
-	.vdisplay = 480,
-	.vsync_start = 480 + 10,
-	.vsync_end = 480 + 10 + 50,
-	.vtotal = 480 + 0 + 10 + 50,
-};
-
-static const struct panel_desc nvd_9128 = {
-	.modes = &nvd_9128_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 156,
-		.height = 88,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
-};
-
-static const struct display_timing okaya_rs800480t_7x0gp_timing = {
-	.pixelclock = { 30000000, 30000000, 40000000 },
-	.hactive = { 800, 800, 800 },
-	.hfront_porch = { 40, 40, 40 },
-	.hback_porch = { 40, 40, 40 },
-	.hsync_len = { 1, 48, 48 },
-	.vactive = { 480, 480, 480 },
-	.vfront_porch = { 13, 13, 13 },
-	.vback_porch = { 29, 29, 29 },
-	.vsync_len = { 3, 3, 3 },
-	.flags = DISPLAY_FLAGS_DE_HIGH,
-};
-
-static const struct panel_desc okaya_rs800480t_7x0gp = {
-	.timings = &okaya_rs800480t_7x0gp_timing,
-	.num_timings = 1,
-	.bpc = 6,
-	.size = {
-		.width = 154,
-		.height = 87,
-	},
-	.delay = {
-		.prepare = 41,
-		.enable = 50,
-		.unprepare = 41,
-		.disable = 50,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
-};
-
-static const struct drm_display_mode olimex_lcd_olinuxino_43ts_mode = {
-	.clock = 9000,
-	.hdisplay = 480,
-	.hsync_start = 480 + 5,
-	.hsync_end = 480 + 5 + 30,
-	.htotal = 480 + 5 + 30 + 10,
-	.vdisplay = 272,
-	.vsync_start = 272 + 8,
-	.vsync_end = 272 + 8 + 5,
-	.vtotal = 272 + 8 + 5 + 3,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc olimex_lcd_olinuxino_43ts = {
-	.modes = &olimex_lcd_olinuxino_43ts_mode,
-	.num_modes = 1,
-	.size = {
-		.width = 95,
-		.height = 54,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
-};
-
-/*
- * 800x480 CVT. The panel appears to be quite accepting, at least as far as
- * pixel clocks, but this is the timing that was being used in the Adafruit
- * installation instructions.
- */
-static const struct drm_display_mode ontat_yx700wv03_mode = {
-	.clock = 29500,
-	.hdisplay = 800,
-	.hsync_start = 824,
-	.hsync_end = 896,
-	.htotal = 992,
-	.vdisplay = 480,
-	.vsync_start = 483,
-	.vsync_end = 493,
-	.vtotal = 500,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
-};
-
-/*
- * Specification at:
- * https://www.adafruit.com/images/product-files/2406/c3163.pdf
- */
-static const struct panel_desc ontat_yx700wv03 = {
-	.modes = &ontat_yx700wv03_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 154,
-		.height = 83,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
-};
-
-static const struct drm_display_mode ortustech_com43h4m85ulc_mode  = {
-	.clock = 25000,
-	.hdisplay = 480,
-	.hsync_start = 480 + 10,
-	.hsync_end = 480 + 10 + 10,
-	.htotal = 480 + 10 + 10 + 15,
-	.vdisplay = 800,
-	.vsync_start = 800 + 3,
-	.vsync_end = 800 + 3 + 3,
-	.vtotal = 800 + 3 + 3 + 3,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc ortustech_com43h4m85ulc = {
-	.modes = &ortustech_com43h4m85ulc_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 56,
-		.height = 93,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
-	.bus_flags = DRM_BUS_FLAG_DE_HIGH | DRM_BUS_FLAG_PIXDATA_POSEDGE,
-};
-
-static const struct drm_display_mode qd43003c0_40_mode = {
-	.clock = 9000,
-	.hdisplay = 480,
-	.hsync_start = 480 + 8,
-	.hsync_end = 480 + 8 + 4,
-	.htotal = 480 + 8 + 4 + 39,
-	.vdisplay = 272,
-	.vsync_start = 272 + 4,
-	.vsync_end = 272 + 4 + 10,
-	.vtotal = 272 + 4 + 10 + 2,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc qd43003c0_40 = {
-	.modes = &qd43003c0_40_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 95,
-		.height = 53,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
-};
-
-static const struct display_timing rocktech_rk070er9427_timing = {
-	.pixelclock = { 26400000, 33300000, 46800000 },
-	.hactive = { 800, 800, 800 },
-	.hfront_porch = { 16, 210, 354 },
-	.hback_porch = { 46, 46, 46 },
-	.hsync_len = { 1, 1, 1 },
-	.vactive = { 480, 480, 480 },
-	.vfront_porch = { 7, 22, 147 },
-	.vback_porch = { 23, 23, 23 },
-	.vsync_len = { 1, 1, 1 },
-	.flags = DISPLAY_FLAGS_DE_HIGH,
-};
-
-static const struct panel_desc rocktech_rk070er9427 = {
-	.timings = &rocktech_rk070er9427_timing,
-	.num_timings = 1,
-	.bpc = 6,
-	.size = {
-		.width = 154,
-		.height = 86,
-	},
-	.delay = {
-		.prepare = 41,
-		.enable = 50,
-		.unprepare = 41,
-		.disable = 50,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
-};
-
-static const struct drm_display_mode samsung_lsn122dl01_c01_mode = {
-	.clock = 271560,
-	.hdisplay = 2560,
-	.hsync_start = 2560 + 48,
-	.hsync_end = 2560 + 48 + 32,
-	.htotal = 2560 + 48 + 32 + 80,
-	.vdisplay = 1600,
-	.vsync_start = 1600 + 2,
-	.vsync_end = 1600 + 2 + 5,
-	.vtotal = 1600 + 2 + 5 + 57,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc samsung_lsn122dl01_c01 = {
-	.modes = &samsung_lsn122dl01_c01_mode,
-	.num_modes = 1,
-	.size = {
-		.width = 263,
-		.height = 164,
-	},
-};
-
-static const struct drm_display_mode samsung_ltn101nt05_mode = {
-	.clock = 54030,
-	.hdisplay = 1024,
-	.hsync_start = 1024 + 24,
-	.hsync_end = 1024 + 24 + 136,
-	.htotal = 1024 + 24 + 136 + 160,
-	.vdisplay = 600,
-	.vsync_start = 600 + 3,
-	.vsync_end = 600 + 3 + 6,
-	.vtotal = 600 + 3 + 6 + 61,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc samsung_ltn101nt05 = {
-	.modes = &samsung_ltn101nt05_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 223,
-		.height = 125,
-	},
-};
-
-static const struct drm_display_mode samsung_ltn140at29_301_mode = {
-	.clock = 76300,
-	.hdisplay = 1366,
-	.hsync_start = 1366 + 64,
-	.hsync_end = 1366 + 64 + 48,
-	.htotal = 1366 + 64 + 48 + 128,
-	.vdisplay = 768,
-	.vsync_start = 768 + 2,
-	.vsync_end = 768 + 2 + 5,
-	.vtotal = 768 + 2 + 5 + 17,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc samsung_ltn140at29_301 = {
-	.modes = &samsung_ltn140at29_301_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 320,
-		.height = 187,
-	},
-};
-
-static const struct drm_display_mode sharp_lq035q7db03_mode = {
-	.clock = 5500,
-	.hdisplay = 240,
-	.hsync_start = 240 + 16,
-	.hsync_end = 240 + 16 + 7,
-	.htotal = 240 + 16 + 7 + 5,
-	.vdisplay = 320,
-	.vsync_start = 320 + 9,
-	.vsync_end = 320 + 9 + 1,
-	.vtotal = 320 + 9 + 1 + 7,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc sharp_lq035q7db03 = {
-	.modes = &sharp_lq035q7db03_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 54,
-		.height = 72,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
-};
-
-static const struct display_timing sharp_lq101k1ly04_timing = {
-	.pixelclock = { 60000000, 65000000, 80000000 },
-	.hactive = { 1280, 1280, 1280 },
-	.hfront_porch = { 20, 20, 20 },
-	.hback_porch = { 20, 20, 20 },
-	.hsync_len = { 10, 10, 10 },
-	.vactive = { 800, 800, 800 },
-	.vfront_porch = { 4, 4, 4 },
-	.vback_porch = { 4, 4, 4 },
-	.vsync_len = { 4, 4, 4 },
-	.flags = DISPLAY_FLAGS_PIXDATA_POSEDGE,
-};
-
-static const struct panel_desc sharp_lq101k1ly04 = {
-	.timings = &sharp_lq101k1ly04_timing,
-	.num_timings = 1,
-	.bpc = 8,
-	.size = {
-		.width = 217,
-		.height = 136,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA,
-};
-
-static const struct display_timing sharp_lq123p1jx31_timing = {
-	.pixelclock = { 252750000, 252750000, 266604720 },
-	.hactive = { 2400, 2400, 2400 },
-	.hfront_porch = { 48, 48, 48 },
-	.hback_porch = { 80, 80, 84 },
-	.hsync_len = { 32, 32, 32 },
-	.vactive = { 1600, 1600, 1600 },
-	.vfront_porch = { 3, 3, 3 },
-	.vback_porch = { 33, 33, 120 },
-	.vsync_len = { 10, 10, 10 },
-	.flags = DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_HSYNC_LOW,
-};
-
-static const struct panel_desc sharp_lq123p1jx31 = {
-	.timings = &sharp_lq123p1jx31_timing,
-	.num_timings = 1,
-	.bpc = 8,
-	.size = {
-		.width = 259,
-		.height = 173,
-	},
-	.delay = {
-		.prepare = 110,
-		.enable = 50,
-		.unprepare = 550,
-	},
-};
-
-static const struct drm_display_mode sharp_lq150x1lg11_mode = {
-	.clock = 71100,
-	.hdisplay = 1024,
-	.hsync_start = 1024 + 168,
-	.hsync_end = 1024 + 168 + 64,
-	.htotal = 1024 + 168 + 64 + 88,
-	.vdisplay = 768,
-	.vsync_start = 768 + 37,
-	.vsync_end = 768 + 37 + 2,
-	.vtotal = 768 + 37 + 2 + 8,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc sharp_lq150x1lg11 = {
-	.modes = &sharp_lq150x1lg11_mode,
-	.num_modes = 1,
-	.bpc = 6,
-	.size = {
-		.width = 304,
-		.height = 228,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB565_1X16,
-};
-
-static const struct drm_display_mode shelly_sca07010_bfn_lnn_mode = {
-	.clock = 33300,
-	.hdisplay = 800,
-	.hsync_start = 800 + 1,
-	.hsync_end = 800 + 1 + 64,
-	.htotal = 800 + 1 + 64 + 64,
-	.vdisplay = 480,
-	.vsync_start = 480 + 1,
-	.vsync_end = 480 + 1 + 23,
-	.vtotal = 480 + 1 + 23 + 22,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc shelly_sca07010_bfn_lnn = {
-	.modes = &shelly_sca07010_bfn_lnn_mode,
-	.num_modes = 1,
-	.size = {
-		.width = 152,
-		.height = 91,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
-};
-
-static const struct drm_display_mode starry_kr122ea0sra_mode = {
-	.clock = 147000,
-	.hdisplay = 1920,
-	.hsync_start = 1920 + 16,
-	.hsync_end = 1920 + 16 + 16,
-	.htotal = 1920 + 16 + 16 + 32,
-	.vdisplay = 1200,
-	.vsync_start = 1200 + 15,
-	.vsync_end = 1200 + 15 + 2,
-	.vtotal = 1200 + 15 + 2 + 18,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
-};
-
-static const struct panel_desc starry_kr122ea0sra = {
-	.modes = &starry_kr122ea0sra_mode,
-	.num_modes = 1,
-	.size = {
-		.width = 263,
-		.height = 164,
-	},
-	.delay = {
-		.prepare = 10 + 200,
-		.enable = 50,
-		.unprepare = 10 + 500,
-	},
-};
-
-static const struct display_timing tianma_tm070jdhg30_timing = {
-	.pixelclock = { 62600000, 68200000, 78100000 },
-	.hactive = { 1280, 1280, 1280 },
-	.hfront_porch = { 15, 64, 159 },
-	.hback_porch = { 5, 5, 5 },
-	.hsync_len = { 1, 1, 256 },
-	.vactive = { 800, 800, 800 },
-	.vfront_porch = { 3, 40, 99 },
-	.vback_porch = { 2, 2, 2 },
-	.vsync_len = { 1, 1, 128 },
-	.flags = DISPLAY_FLAGS_DE_HIGH,
-};
-
-static const struct panel_desc tianma_tm070jdhg30 = {
-	.timings = &tianma_tm070jdhg30_timing,
-	.num_timings = 1,
-	.bpc = 8,
-	.size = {
-		.width = 151,
-		.height = 95,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
-};
-
-static const struct display_timing tianma_tm070rvhg71_timing = {
-	.pixelclock = { 27700000, 29200000, 39600000 },
-	.hactive = { 800, 800, 800 },
-	.hfront_porch = { 12, 40, 212 },
-	.hback_porch = { 88, 88, 88 },
-	.hsync_len = { 1, 1, 40 },
-	.vactive = { 480, 480, 480 },
-	.vfront_porch = { 1, 13, 88 },
-	.vback_porch = { 32, 32, 32 },
-	.vsync_len = { 1, 1, 3 },
-	.flags = DISPLAY_FLAGS_DE_HIGH,
-};
-
-static const struct panel_desc tianma_tm070rvhg71 = {
-	.timings = &tianma_tm070rvhg71_timing,
-	.num_timings = 1,
-	.bpc = 8,
-	.size = {
-		.width = 154,
-		.height = 86,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
-};
-
-static const struct drm_display_mode toshiba_lt089ac29000_mode = {
-	.clock = 79500,
-	.hdisplay = 1280,
-	.hsync_start = 1280 + 192,
-	.hsync_end = 1280 + 192 + 128,
-	.htotal = 1280 + 192 + 128 + 64,
-	.vdisplay = 768,
-	.vsync_start = 768 + 20,
-	.vsync_end = 768 + 20 + 7,
-	.vtotal = 768 + 20 + 7 + 3,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc toshiba_lt089ac29000 = {
-	.modes = &toshiba_lt089ac29000_mode,
-	.num_modes = 1,
-	.size = {
-		.width = 194,
-		.height = 116,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
-	.bus_flags = DRM_BUS_FLAG_DE_HIGH | DRM_BUS_FLAG_PIXDATA_POSEDGE,
-};
-
-static const struct drm_display_mode tpk_f07a_0102_mode = {
-	.clock = 33260,
-	.hdisplay = 800,
-	.hsync_start = 800 + 40,
-	.hsync_end = 800 + 40 + 128,
-	.htotal = 800 + 40 + 128 + 88,
-	.vdisplay = 480,
-	.vsync_start = 480 + 10,
-	.vsync_end = 480 + 10 + 2,
-	.vtotal = 480 + 10 + 2 + 33,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc tpk_f07a_0102 = {
-	.modes = &tpk_f07a_0102_mode,
-	.num_modes = 1,
-	.size = {
-		.width = 152,
-		.height = 91,
-	},
-	.bus_flags = DRM_BUS_FLAG_PIXDATA_POSEDGE,
-};
-
-static const struct drm_display_mode tpk_f10a_0102_mode = {
-	.clock = 45000,
-	.hdisplay = 1024,
-	.hsync_start = 1024 + 176,
-	.hsync_end = 1024 + 176 + 5,
-	.htotal = 1024 + 176 + 5 + 88,
-	.vdisplay = 600,
-	.vsync_start = 600 + 20,
-	.vsync_end = 600 + 20 + 5,
-	.vtotal = 600 + 20 + 5 + 25,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc tpk_f10a_0102 = {
-	.modes = &tpk_f10a_0102_mode,
-	.num_modes = 1,
-	.size = {
-		.width = 223,
-		.height = 125,
-	},
-};
-
-static const struct display_timing urt_umsh_8596md_timing = {
-	.pixelclock = { 33260000, 33260000, 33260000 },
-	.hactive = { 800, 800, 800 },
-	.hfront_porch = { 41, 41, 41 },
-	.hback_porch = { 216 - 128, 216 - 128, 216 - 128 },
-	.hsync_len = { 71, 128, 128 },
-	.vactive = { 480, 480, 480 },
-	.vfront_porch = { 10, 10, 10 },
-	.vback_porch = { 35 - 2, 35 - 2, 35 - 2 },
-	.vsync_len = { 2, 2, 2 },
-	.flags = DISPLAY_FLAGS_DE_HIGH | DISPLAY_FLAGS_PIXDATA_NEGEDGE |
-		DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW,
-};
-
-static const struct panel_desc urt_umsh_8596md_lvds = {
-	.timings = &urt_umsh_8596md_timing,
-	.num_timings = 1,
-	.bpc = 6,
-	.size = {
-		.width = 152,
-		.height = 91,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X7X3_SPWG,
-};
-
-static const struct panel_desc urt_umsh_8596md_parallel = {
-	.timings = &urt_umsh_8596md_timing,
-	.num_timings = 1,
-	.bpc = 6,
-	.size = {
-		.width = 152,
-		.height = 91,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
-};
-
-static const struct drm_display_mode winstar_wf35ltiacd_mode = {
-	.clock = 6410,
-	.hdisplay = 320,
-	.hsync_start = 320 + 20,
-	.hsync_end = 320 + 20 + 30,
-	.htotal = 320 + 20 + 30 + 38,
-	.vdisplay = 240,
-	.vsync_start = 240 + 4,
-	.vsync_end = 240 + 4 + 3,
-	.vtotal = 240 + 4 + 3 + 15,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
-};
-
-static const struct panel_desc winstar_wf35ltiacd = {
-	.modes = &winstar_wf35ltiacd_mode,
-	.num_modes = 1,
-	.bpc = 8,
-	.size = {
-		.width = 70,
-		.height = 53,
-	},
-	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
-};
-
-static const struct of_device_id platform_of_match[] = {
-	{
-		.compatible = "simple-panel",
-		.data = NULL,
-#ifndef CONFIG_DRM_PANEL_SIMPLE_OF_ONLY
-	}, {
-		.compatible = "ampire,am-480272h3tmqw-t01h",
-		.data = &ampire_am_480272h3tmqw_t01h,
-	}, {
-		.compatible = "ampire,am800480r3tmqwa1h",
-		.data = &ampire_am800480r3tmqwa1h,
-	}, {
-		.compatible = "armadeus,st0700-adapt",
-		.data = &armadeus_st0700_adapt,
-	}, {
-		.compatible = "auo,b101aw03",
-		.data = &auo_b101aw03,
-	}, {
-		.compatible = "auo,b101ean01",
-		.data = &auo_b101ean01,
-	}, {
-		.compatible = "auo,b101xtn01",
-		.data = &auo_b101xtn01,
-	}, {
-		.compatible = "auo,b116xw03",
-		.data = &auo_b116xw03,
-	}, {
-		.compatible = "auo,b133htn01",
-		.data = &auo_b133htn01,
-	}, {
-		.compatible = "auo,b133xtn01",
-		.data = &auo_b133xtn01,
-	}, {
-		.compatible = "auo,g070vvn01",
-		.data = &auo_g070vvn01,
-	}, {
-		.compatible = "auo,g104sn02",
-		.data = &auo_g104sn02,
-	}, {
-		.compatible = "auo,g133han01",
-		.data = &auo_g133han01,
-	}, {
-		.compatible = "auo,g185han01",
-		.data = &auo_g185han01,
-	}, {
-		.compatible = "auo,p320hvn03",
-		.data = &auo_p320hvn03,
-	}, {
-		.compatible = "auo,t215hvn01",
-		.data = &auo_t215hvn01,
-	}, {
-		.compatible = "avic,tm070ddh03",
-		.data = &avic_tm070ddh03,
-	}, {
-		.compatible = "boe,hv070wsa-100",
-		.data = &boe_hv070wsa
-	}, {
-		.compatible = "boe,nv101wxmn51",
-		.data = &boe_nv101wxmn51,
-	}, {
-		.compatible = "chunghwa,claa070wp03xg",
-		.data = &chunghwa_claa070wp03xg,
-	}, {
-		.compatible = "chunghwa,claa101wa01a",
-		.data = &chunghwa_claa101wa01a
-	}, {
-		.compatible = "chunghwa,claa101wb01",
-		.data = &chunghwa_claa101wb01
-	}, {
-		.compatible = "dataimage,scf0700c48ggu18",
-		.data = &dataimage_scf0700c48ggu18,
-	}, {
-		.compatible = "dlc,dlc0700yzg-1",
-		.data = &dlc_dlc0700yzg_1,
-	}, {
-		.compatible = "edt,et057090dhu",
-		.data = &edt_et057090dhu,
-	}, {
-		.compatible = "edt,et070080dh6",
-		.data = &edt_etm0700g0dh6,
-	}, {
-		.compatible = "edt,etm0700g0dh6",
-		.data = &edt_etm0700g0dh6,
-	}, {
-		.compatible = "edt,etm0700g0bdh6",
-		.data = &edt_etm0700g0bdh6,
-	}, {
-		.compatible = "edt,etm0700g0edh6",
-		.data = &edt_etm0700g0bdh6,
-	}, {
-		.compatible = "foxlink,fl500wvr00-a0t",
-		.data = &foxlink_fl500wvr00_a0t,
-	}, {
-		.compatible = "giantplus,gpg482739qs5",
-		.data = &giantplus_gpg482739qs5
-	}, {
-		.compatible = "hannstar,hsd070pww1",
-		.data = &hannstar_hsd070pww1,
-	}, {
-		.compatible = "hannstar,hsd100pxn1",
-		.data = &hannstar_hsd100pxn1,
-	}, {
-		.compatible = "hit,tx23d38vm0caa",
-		.data = &hitachi_tx23d38vm0caa
-	}, {
-		.compatible = "innolux,at043tn24",
-		.data = &innolux_at043tn24,
-	}, {
-		.compatible = "innolux,at070tn92",
-		.data = &innolux_at070tn92,
-	}, {
-		.compatible = "innolux,g070y2-l01",
-		.data = &innolux_g070y2_l01,
-	}, {
-		.compatible = "innolux,g101ice-l01",
-		.data = &innolux_g101ice_l01
-	}, {
-		.compatible = "innolux,g121i1-l01",
-		.data = &innolux_g121i1_l01
-	}, {
-		.compatible = "innolux,g121x1-l03",
-		.data = &innolux_g121x1_l03,
-	}, {
-		.compatible = "innolux,n116bge",
-		.data = &innolux_n116bge,
-	}, {
-		.compatible = "innolux,n156bge-l21",
-		.data = &innolux_n156bge_l21,
-	}, {
-		.compatible = "innolux,tv123wam",
-		.data = &innolux_tv123wam,
-	}, {
-		.compatible = "innolux,zj070na-01p",
-		.data = &innolux_zj070na_01p,
-	}, {
-		.compatible = "koe,tx31d200vm0baa",
-		.data = &koe_tx31d200vm0baa,
-	}, {
-		.compatible = "kyo,tcg121xglp",
-		.data = &kyo_tcg121xglp,
-	}, {
-		.compatible = "lg,lb070wv8",
-		.data = &lg_lb070wv8,
-	}, {
-		.compatible = "lg,lp079qx1-sp0v",
-		.data = &lg_lp079qx1_sp0v,
-	}, {
-		.compatible = "lg,lp097qx1-spa1",
-		.data = &lg_lp097qx1_spa1,
-	}, {
-		.compatible = "lg,lp120up1",
-		.data = &lg_lp120up1,
-	}, {
-		.compatible = "lg,lp129qe",
-		.data = &lg_lp129qe,
-	}, {
-		.compatible = "mitsubishi,aa070mc01-ca1",
-		.data = &mitsubishi_aa070mc01,
-	}, {
-		.compatible = "nec,nl12880bc20-05",
-		.data = &nec_nl12880bc20_05,
-	}, {
-		.compatible = "nec,nl4827hc19-05b",
-		.data = &nec_nl4827hc19_05b,
-	}, {
-		.compatible = "netron-dy,e231732",
-		.data = &netron_dy_e231732,
-	}, {
-		.compatible = "newhaven,nhd-4.3-480272ef-atxl",
-		.data = &newhaven_nhd_43_480272ef_atxl,
-	}, {
-		.compatible = "nlt,nl192108ac18-02d",
-		.data = &nlt_nl192108ac18_02d,
-	}, {
-		.compatible = "nvd,9128",
-		.data = &nvd_9128,
-	}, {
-		.compatible = "okaya,rs800480t-7x0gp",
-		.data = &okaya_rs800480t_7x0gp,
-	}, {
-		.compatible = "olimex,lcd-olinuxino-43-ts",
-		.data = &olimex_lcd_olinuxino_43ts,
-	}, {
-		.compatible = "ontat,yx700wv03",
-		.data = &ontat_yx700wv03,
-	}, {
-		.compatible = "ortustech,com43h4m85ulc",
-		.data = &ortustech_com43h4m85ulc,
-	}, {
-		.compatible = "qiaodian,qd43003c0-40",
-		.data = &qd43003c0_40,
-	}, {
-		.compatible = "rocktech,rk070er9427",
-		.data = &rocktech_rk070er9427,
-	}, {
-		.compatible = "samsung,lsn122dl01-c01",
-		.data = &samsung_lsn122dl01_c01,
-	}, {
-		.compatible = "samsung,ltn101nt05",
-		.data = &samsung_ltn101nt05,
-	}, {
-		.compatible = "samsung,ltn140at29-301",
-		.data = &samsung_ltn140at29_301,
-	}, {
-		.compatible = "sharp,lq035q7db03",
-		.data = &sharp_lq035q7db03,
-	}, {
-		.compatible = "sharp,lq101k1ly04",
-		.data = &sharp_lq101k1ly04,
-	}, {
-		.compatible = "sharp,lq123p1jx31",
-		.data = &sharp_lq123p1jx31,
-	}, {
-		.compatible = "sharp,lq150x1lg11",
-		.data = &sharp_lq150x1lg11,
-	}, {
-		.compatible = "shelly,sca07010-bfn-lnn",
-		.data = &shelly_sca07010_bfn_lnn,
-	}, {
-		.compatible = "starry,kr122ea0sra",
-		.data = &starry_kr122ea0sra,
-	}, {
-		.compatible = "tianma,tm070jdhg30",
-		.data = &tianma_tm070jdhg30,
-	}, {
-		.compatible = "tianma,tm070rvhg71",
-		.data = &tianma_tm070rvhg71,
-	}, {
-		.compatible = "toshiba,lt089ac29000",
-		.data = &toshiba_lt089ac29000,
-	}, {
-		.compatible = "tpk,f07a-0102",
-		.data = &tpk_f07a_0102,
-	}, {
-		.compatible = "tpk,f10a-0102",
-		.data = &tpk_f10a_0102,
-	}, {
-		.compatible = "urt,umsh-8596md-t",
-		.data = &urt_umsh_8596md_parallel,
-	}, {
-		.compatible = "urt,umsh-8596md-1t",
-		.data = &urt_umsh_8596md_parallel,
-	}, {
-		.compatible = "urt,umsh-8596md-7t",
-		.data = &urt_umsh_8596md_parallel,
-	}, {
-		.compatible = "urt,umsh-8596md-11t",
-		.data = &urt_umsh_8596md_lvds,
-	}, {
-		.compatible = "urt,umsh-8596md-19t",
-		.data = &urt_umsh_8596md_lvds,
-	}, {
-		.compatible = "urt,umsh-8596md-20t",
-		.data = &urt_umsh_8596md_parallel,
-	}, {
-		.compatible = "winstar,wf35ltiacd",
-		.data = &winstar_wf35ltiacd,
-#endif /* !CONFIG_DRM_PANEL_SIMPLE_OF_ONLY */
-	}, {
-		/* sentinel */
-	}
-};
-MODULE_DEVICE_TABLE(of, platform_of_match);
-
-static int panel_simple_of_get_desc_data(struct device *dev,
-					 struct panel_desc *desc)
-{
-	struct device_node *np = dev->of_node;
-	struct drm_display_mode *mode;
-	u32 bus_flags;
-	const void *data;
-	int len;
-	int err;
-
-	mode = devm_kzalloc(dev, sizeof(*mode), GFP_KERNEL);
-	if (!mode)
-		return -ENOMEM;
-
-	err = of_get_drm_display_mode(np, mode, &bus_flags, OF_USE_NATIVE_MODE);
-	if (!err) {
-		desc->modes = mode;
-		desc->num_modes = 1;
-		desc->bus_flags = bus_flags;
-
-		of_property_read_u32(np, "bpc", &desc->bpc);
-		of_property_read_u32(np, "bus-format", &desc->bus_format);
-		of_property_read_u32(np, "width-mm", &desc->size.width);
-		of_property_read_u32(np, "height-mm", &desc->size.height);
-	}
-
-	of_property_read_u32(np, "prepare-delay-ms", &desc->delay.prepare);
-	of_property_read_u32(np, "enable-delay-ms", &desc->delay.enable);
-	of_property_read_u32(np, "disable-delay-ms", &desc->delay.disable);
-	of_property_read_u32(np, "unprepare-delay-ms", &desc->delay.unprepare);
-	of_property_read_u32(np, "reset-delay-ms", &desc->delay.reset);
-	of_property_read_u32(np, "init-delay-ms", &desc->delay.init);
-
-	data = of_get_property(np, "panel-init-sequence", &len);
-	if (data) {
-		desc->init_seq = devm_kzalloc(dev, sizeof(*desc->init_seq),
-					      GFP_KERNEL);
-		if (!desc->init_seq)
-			return -ENOMEM;
-
-		err = panel_simple_parse_cmd_seq(dev, data, len,
-						 desc->init_seq);
-		if (err) {
-			dev_err(dev, "failed to parse init sequence\n");
-			return err;
-		}
-	}
-
-	data = of_get_property(np, "panel-exit-sequence", &len);
-	if (data) {
-		desc->exit_seq = devm_kzalloc(dev, sizeof(*desc->exit_seq),
-					      GFP_KERNEL);
-		if (!desc->exit_seq)
-			return -ENOMEM;
-
-		err = panel_simple_parse_cmd_seq(dev, data, len,
-						 desc->exit_seq);
-		if (err) {
-			dev_err(dev, "failed to parse exit sequence\n");
-			return err;
-		}
-	}
-
-	return 0;
-}
-
-static int panel_simple_platform_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	const struct of_device_id *id;
-	const struct panel_desc *desc;
-	struct panel_desc *d;
-	int err;
-
-	id = of_match_node(platform_of_match, pdev->dev.of_node);
-	if (!id)
-		return -ENODEV;
-
-	if (!id->data) {
-		d = devm_kzalloc(dev, sizeof(*d), GFP_KERNEL);
-		if (!d)
-			return -ENOMEM;
-
-		err = panel_simple_of_get_desc_data(dev, d);
-		if (err) {
-			dev_err(dev, "failed to get desc data: %d\n", err);
-			return err;
-		}
-	}
-
-	desc = id->data ? id->data : d;
-
-	return panel_simple_probe(&pdev->dev, desc);
-}
-
-static int panel_simple_platform_remove(struct platform_device *pdev)
-{
-	return panel_simple_remove(&pdev->dev);
-}
-
-static void panel_simple_platform_shutdown(struct platform_device *pdev)
-{
-	panel_simple_shutdown(&pdev->dev);
-}
-
-static struct platform_driver panel_simple_platform_driver = {
-	.driver = {
-		.name = "panel-simple",
-		.of_match_table = platform_of_match,
-	},
-	.probe = panel_simple_platform_probe,
-	.remove = panel_simple_platform_remove,
-	.shutdown = panel_simple_platform_shutdown,
-};
-
-struct panel_desc_dsi {
-	struct panel_desc desc;
-
-	unsigned long flags;
-	enum mipi_dsi_pixel_format format;
-	unsigned int lanes;
-};
-
-static const struct drm_display_mode auo_b080uan01_mode = {
-	.clock = 154500,
-	.hdisplay = 1200,
-	.hsync_start = 1200 + 62,
-	.hsync_end = 1200 + 62 + 4,
-	.htotal = 1200 + 62 + 4 + 62,
-	.vdisplay = 1920,
-	.vsync_start = 1920 + 9,
-	.vsync_end = 1920 + 9 + 2,
-	.vtotal = 1920 + 9 + 2 + 8,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc_dsi auo_b080uan01 = {
-	.desc = {
-		.modes = &auo_b080uan01_mode,
-		.num_modes = 1,
-		.bpc = 8,
-		.size = {
-			.width = 108,
-			.height = 272,
-		},
-	},
-	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
-	.format = MIPI_DSI_FMT_RGB888,
-	.lanes = 4,
-};
-
-static const struct drm_display_mode boe_tv080wum_nl0_mode = {
-	.clock = 160000,
-	.hdisplay = 1200,
-	.hsync_start = 1200 + 120,
-	.hsync_end = 1200 + 120 + 20,
-	.htotal = 1200 + 120 + 20 + 21,
-	.vdisplay = 1920,
-	.vsync_start = 1920 + 21,
-	.vsync_end = 1920 + 21 + 3,
-	.vtotal = 1920 + 21 + 3 + 18,
-	.vrefresh = 60,
-	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
-};
-
-static const struct panel_desc_dsi boe_tv080wum_nl0 = {
-	.desc = {
-		.modes = &boe_tv080wum_nl0_mode,
-		.num_modes = 1,
-		.size = {
-			.width = 107,
-			.height = 172,
-		},
-	},
-	.flags = MIPI_DSI_MODE_VIDEO |
-		 MIPI_DSI_MODE_VIDEO_BURST |
-		 MIPI_DSI_MODE_VIDEO_SYNC_PULSE,
-	.format = MIPI_DSI_FMT_RGB888,
-	.lanes = 4,
-};
-
-static const struct drm_display_mode lg_ld070wx3_sl01_mode = {
-	.clock = 71000,
-	.hdisplay = 800,
-	.hsync_start = 800 + 32,
-	.hsync_end = 800 + 32 + 1,
-	.htotal = 800 + 32 + 1 + 57,
-	.vdisplay = 1280,
-	.vsync_start = 1280 + 28,
-	.vsync_end = 1280 + 28 + 1,
-	.vtotal = 1280 + 28 + 1 + 14,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc_dsi lg_ld070wx3_sl01 = {
-	.desc = {
-		.modes = &lg_ld070wx3_sl01_mode,
-		.num_modes = 1,
-		.bpc = 8,
-		.size = {
-			.width = 94,
-			.height = 151,
-		},
-	},
-	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
-	.format = MIPI_DSI_FMT_RGB888,
-	.lanes = 4,
-};
-
-static const struct drm_display_mode lg_lh500wx1_sd03_mode = {
-	.clock = 67000,
-	.hdisplay = 720,
-	.hsync_start = 720 + 12,
-	.hsync_end = 720 + 12 + 4,
-	.htotal = 720 + 12 + 4 + 112,
-	.vdisplay = 1280,
-	.vsync_start = 1280 + 8,
-	.vsync_end = 1280 + 8 + 4,
-	.vtotal = 1280 + 8 + 4 + 12,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc_dsi lg_lh500wx1_sd03 = {
-	.desc = {
-		.modes = &lg_lh500wx1_sd03_mode,
-		.num_modes = 1,
-		.bpc = 8,
-		.size = {
-			.width = 62,
-			.height = 110,
-		},
-	},
-	.flags = MIPI_DSI_MODE_VIDEO,
-	.format = MIPI_DSI_FMT_RGB888,
-	.lanes = 4,
-};
-
-static const struct drm_display_mode panasonic_vvx10f004b00_mode = {
-	.clock = 157200,
-	.hdisplay = 1920,
-	.hsync_start = 1920 + 154,
-	.hsync_end = 1920 + 154 + 16,
-	.htotal = 1920 + 154 + 16 + 32,
-	.vdisplay = 1200,
-	.vsync_start = 1200 + 17,
-	.vsync_end = 1200 + 17 + 2,
-	.vtotal = 1200 + 17 + 2 + 16,
-	.vrefresh = 60,
-};
-
-static const struct panel_desc_dsi panasonic_vvx10f004b00 = {
-	.desc = {
-		.modes = &panasonic_vvx10f004b00_mode,
-		.num_modes = 1,
-		.bpc = 8,
-		.size = {
-			.width = 217,
-			.height = 136,
-		},
-	},
-	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
-		 MIPI_DSI_CLOCK_NON_CONTINUOUS,
-	.format = MIPI_DSI_FMT_RGB888,
-	.lanes = 4,
-};
-
-static const struct of_device_id dsi_of_match[] = {
-	{
-		.compatible = "simple-panel-dsi",
-		.data = NULL,
-#ifndef CONFIG_DRM_PANEL_SIMPLE_OF_ONLY
-	}, {
-		.compatible = "auo,b080uan01",
-		.data = &auo_b080uan01
-	}, {
-		.compatible = "boe,tv080wum-nl0",
-		.data = &boe_tv080wum_nl0
-	}, {
-		.compatible = "lg,ld070wx3-sl01",
-		.data = &lg_ld070wx3_sl01
-	}, {
-		.compatible = "lg,lh500wx1-sd03",
-		.data = &lg_lh500wx1_sd03
-	}, {
-		.compatible = "panasonic,vvx10f004b00",
-		.data = &panasonic_vvx10f004b00
-#endif /* !CONFIG_DRM_PANEL_SIMPLE_OF_ONLY */
-	}, {
-		/* sentinel */
-	}
-};
-MODULE_DEVICE_TABLE(of, dsi_of_match);
-
-static int panel_simple_dsi_of_get_desc_data(struct device *dev,
-					     struct panel_desc_dsi *desc)
-{
-	struct device_node *np = dev->of_node;
-	u32 val;
-	int err;
-
-	err = panel_simple_of_get_desc_data(dev, &desc->desc);
-	if (err)
-		return err;
-
-	if (!of_property_read_u32(np, "dsi,flags", &val))
-		desc->flags = val;
-	if (!of_property_read_u32(np, "dsi,format", &val))
-		desc->format = val;
-	if (!of_property_read_u32(np, "dsi,lanes", &val))
-		desc->lanes = val;
-
-	return 0;
-}
-
-static int panel_simple_dsi_probe(struct mipi_dsi_device *dsi)
-{
-	struct panel_simple *panel;
-	struct device *dev = &dsi->dev;
-	const struct panel_desc_dsi *desc;
-	struct panel_desc_dsi *d;
-	const struct of_device_id *id;
-	int err;
-
-	id = of_match_node(dsi_of_match, dsi->dev.of_node);
-	if (!id)
-		return -ENODEV;
-
-	if (!id->data) {
-		d = devm_kzalloc(dev, sizeof(*d), GFP_KERNEL);
-		if (!d)
-			return -ENOMEM;
-
-		err = panel_simple_dsi_of_get_desc_data(dev, d);
-		if (err) {
-			dev_err(dev, "failed to get desc data: %d\n", err);
-			return err;
-		}
-	}
-
-	desc = id->data ? id->data : d;
-
-	err = panel_simple_probe(&dsi->dev, &desc->desc);
-	if (err < 0)
-		return err;
-
-	panel = dev_get_drvdata(dev);
-	panel->dsi = dsi;
-
-	dsi->mode_flags = desc->flags;
-	dsi->format = desc->format;
-	dsi->lanes = desc->lanes;
-
-	err = mipi_dsi_attach(dsi);
-	if (err) {
-		struct panel_simple *panel = dev_get_drvdata(&dsi->dev);
-
-		drm_panel_remove(&panel->base);
-	}
-
-	return err;
-}
-
-static int panel_simple_dsi_remove(struct mipi_dsi_device *dsi)
-{
-	int err;
-
-	err = mipi_dsi_detach(dsi);
-	if (err < 0)
-		dev_err(&dsi->dev, "failed to detach from DSI host: %d\n", err);
-
-	return panel_simple_remove(&dsi->dev);
-}
-
-static void panel_simple_dsi_shutdown(struct mipi_dsi_device *dsi)
-{
-	panel_simple_shutdown(&dsi->dev);
-}
-
-static struct mipi_dsi_driver panel_simple_dsi_driver = {
-	.driver = {
-		.name = "panel-simple-dsi",
-		.of_match_table = dsi_of_match,
-	},
-	.probe = panel_simple_dsi_probe,
-	.remove = panel_simple_dsi_remove,
-	.shutdown = panel_simple_dsi_shutdown,
-};
-
-static int __init panel_simple_init(void)
-{
-	int err;
-
-	err = platform_driver_register(&panel_simple_platform_driver);
-	if (err < 0)
-		return err;
-
-	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI)) {
-		err = mipi_dsi_driver_register(&panel_simple_dsi_driver);
-		if (err < 0)
-			return err;
-	}
-
-	return 0;
-}
-#ifdef CONFIG_ROCKCHIP_THUNDER_BOOT
-rootfs_initcall(panel_simple_init);
-#else
-module_init(panel_simple_init);
-#endif
-
-static void __exit panel_simple_exit(void)
-{
-	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI))
-		mipi_dsi_driver_unregister(&panel_simple_dsi_driver);
-
-	platform_driver_unregister(&panel_simple_platform_driver);
-}
-module_exit(panel_simple_exit);
-
-MODULE_AUTHOR("Thierry Reding <treding@nvidia.com>");
-MODULE_DESCRIPTION("DRM Driver for Simple Panels");
-MODULE_LICENSE("GPL and additional rights");
+version https://git-lfs.github.com/spec/v1
+oid sha256:e2af13fa79fc2951d0164c8b198dabf5790bc88427255846c90f5a7709732406
+size 82527
diff --git a/kernel/include/linux/backlight.h b/kernel/include/linux/backlight.h
index a5a50e7845..627adb80af 100644
--- a/kernel/include/linux/backlight.h
+++ b/kernel/include/linux/backlight.h
@@ -1,236 +1,3 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Backlight Lowlevel Control Abstraction
- *
- * Copyright (C) 2003,2004 Hewlett-Packard Company
- *
- */
-
-#ifndef _LINUX_BACKLIGHT_H
-#define _LINUX_BACKLIGHT_H
-
-#include <linux/device.h>
-#include <linux/fb.h>
-#include <linux/mutex.h>
-#include <linux/notifier.h>
-#include <linux/thermal.h>
-
-/* Notes on locking:
- *
- * backlight_device->ops_lock is an internal backlight lock protecting the
- * ops pointer and no code outside the core should need to touch it.
- *
- * Access to update_status() is serialised by the update_lock mutex since
- * most drivers seem to need this and historically get it wrong.
- *
- * Most drivers don't need locking on their get_brightness() method.
- * If yours does, you need to implement it in the driver. You can use the
- * update_lock mutex if appropriate.
- *
- * Any other use of the locks below is probably wrong.
- */
-
-enum backlight_update_reason {
-	BACKLIGHT_UPDATE_HOTKEY,
-	BACKLIGHT_UPDATE_SYSFS,
-};
-
-enum backlight_type {
-	BACKLIGHT_RAW = 1,
-	BACKLIGHT_PLATFORM,
-	BACKLIGHT_FIRMWARE,
-	BACKLIGHT_TYPE_MAX,
-};
-
-enum backlight_notification {
-	BACKLIGHT_REGISTERED,
-	BACKLIGHT_UNREGISTERED,
-};
-
-struct backlight_device;
-struct fb_info;
-
-struct backlight_ops {
-	unsigned int options;
-
-#define BL_CORE_SUSPENDRESUME	(1 << 0)
-
-	/* Notify the backlight driver some property has changed */
-	int (*update_status)(struct backlight_device *);
-	/* Return the current backlight brightness (accounting for power,
-	   fb_blank etc.) */
-	int (*get_brightness)(struct backlight_device *);
-	/* Check if given framebuffer device is the one bound to this backlight;
-	   return 0 if not, !=0 if it is. If NULL, backlight always matches the fb. */
-	int (*check_fb)(struct backlight_device *, struct fb_info *);
-};
-
-/* This structure defines all the properties of a backlight */
-struct backlight_properties {
-	/* Current User requested brightness (0 - max_brightness) */
-	int brightness;
-	/* Maximal value for brightness (read-only) */
-	int max_brightness;
-	/* Current FB Power mode (0: full on, 1..3: power saving
-	   modes; 4: full off), see FB_BLANK_XXX */
-	int power;
-	/* FB Blanking active? (values as for power) */
-	/* Due to be removed, please use (state & BL_CORE_FBBLANK) */
-	int fb_blank;
-	/* Backlight type */
-	enum backlight_type type;
-	/* Flags used to signal drivers of state changes */
-	unsigned int state;
-
-#define BL_CORE_SUSPENDED	(1 << 0)	/* backlight is suspended */
-#define BL_CORE_FBBLANK		(1 << 1)	/* backlight is under an fb blank event */
-
-};
-
-struct backlight_device {
-	/* Backlight properties */
-	struct backlight_properties props;
-
-	/* Serialise access to update_status method */
-	struct mutex update_lock;
-
-	/* This protects the 'ops' field. If 'ops' is NULL, the driver that
-	   registered this device has been unloaded, and if class_get_devdata()
-	   points to something in the body of that driver, it is also invalid. */
-	struct mutex ops_lock;
-	const struct backlight_ops *ops;
-
-	/* The framebuffer notifier block */
-	struct notifier_block fb_notif;
-
-	/* list entry of all registered backlight devices */
-	struct list_head entry;
-
-	struct device dev;
-	/* Backlight cooling device */
-	struct thermal_cooling_device *cdev;
-	/* Thermally limited max brightness */
-	int thermal_brightness_limit;
-	/* User brightness request */
-	int usr_brightness_req;
-
-	/* Multiple framebuffers may share one backlight device */
-	bool fb_bl_on[FB_MAX];
-
-	int use_count;
-};
-
-static inline int backlight_update_status(struct backlight_device *bd)
-{
-	int ret = -ENOENT;
-
-	mutex_lock(&bd->update_lock);
-	if (bd->ops && bd->ops->update_status)
-		ret = bd->ops->update_status(bd);
-	mutex_unlock(&bd->update_lock);
-
-	return ret;
-}
-
-/**
- * backlight_enable - Enable backlight
- * @bd: the backlight device to enable
- */
-static inline int backlight_enable(struct backlight_device *bd)
-{
-	if (!bd)
-		return 0;
-
-	bd->props.power = FB_BLANK_UNBLANK;
-	bd->props.fb_blank = FB_BLANK_UNBLANK;
-	bd->props.state &= ~BL_CORE_FBBLANK;
-
-	return backlight_update_status(bd);
-}
-
-/**
- * backlight_disable - Disable backlight
- * @bd: the backlight device to disable
- */
-static inline int backlight_disable(struct backlight_device *bd)
-{
-	if (!bd)
-		return 0;
-
-	bd->props.power = FB_BLANK_POWERDOWN;
-	bd->props.fb_blank = FB_BLANK_POWERDOWN;
-	bd->props.state |= BL_CORE_FBBLANK;
-
-	return backlight_update_status(bd);
-}
-
-/**
- * backlight_put - Drop backlight reference
- * @bd: the backlight device to put
- */
-static inline void backlight_put(struct backlight_device *bd)
-{
-	if (bd)
-		put_device(&bd->dev);
-}
-
-extern struct backlight_device *backlight_device_register(const char *name,
-	struct device *dev, void *devdata, const struct backlight_ops *ops,
-	const struct backlight_properties *props);
-extern struct backlight_device *devm_backlight_device_register(
-	struct device *dev, const char *name, struct device *parent,
-	void *devdata, const struct backlight_ops *ops,
-	const struct backlight_properties *props);
-extern void backlight_device_unregister(struct backlight_device *bd);
-extern void devm_backlight_device_unregister(struct device *dev,
-					struct backlight_device *bd);
-extern void backlight_force_update(struct backlight_device *bd,
-				   enum backlight_update_reason reason);
-extern int backlight_register_notifier(struct notifier_block *nb);
-extern int backlight_unregister_notifier(struct notifier_block *nb);
-extern struct backlight_device *backlight_device_get_by_type(enum backlight_type type);
-extern int backlight_device_set_brightness(struct backlight_device *bd, unsigned long brightness);
-
-#define to_backlight_device(obj) container_of(obj, struct backlight_device, dev)
-
-static inline void * bl_get_data(struct backlight_device *bl_dev)
-{
-	return dev_get_drvdata(&bl_dev->dev);
-}
-
-struct generic_bl_info {
-	const char *name;
-	int max_intensity;
-	int default_intensity;
-	int limit_mask;
-	void (*set_bl_intensity)(int intensity);
-	void (*kick_battery)(void);
-};
-
-#ifdef CONFIG_OF
-struct backlight_device *of_find_backlight_by_node(struct device_node *node);
-#else
-static inline struct backlight_device *
-of_find_backlight_by_node(struct device_node *node)
-{
-	return NULL;
-}
-#endif
-
-#if IS_ENABLED(CONFIG_BACKLIGHT_CLASS_DEVICE)
-struct backlight_device *of_find_backlight(struct device *dev);
-struct backlight_device *devm_of_find_backlight(struct device *dev);
-#else
-static inline struct backlight_device *of_find_backlight(struct device *dev)
-{
-	return NULL;
-}
-
-static inline struct backlight_device *
-devm_of_find_backlight(struct device *dev)
-{
-	return NULL;
-}
-#endif
-
-#endif
+version https://git-lfs.github.com/spec/v1
+oid sha256:f65e4988e5bf7df31364dc8a348c40fa935fab8563b25ed4b7c28d67b7ba6242
+size 6547
diff --git a/kernel/include/linux/device.h b/kernel/include/linux/device.h
index d91fe50cea..67264c51f6 100644
--- a/kernel/include/linux/device.h
+++ b/kernel/include/linux/device.h
@@ -1,1736 +1,3 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * device.h - generic, centralized driver model
- *
- * Copyright (c) 2001-2003 Patrick Mochel <mochel@osdl.org>
- * Copyright (c) 2004-2009 Greg Kroah-Hartman <gregkh@suse.de>
- * Copyright (c) 2008-2009 Novell Inc.
- *
- * See Documentation/driver-model/ for more information.
- */
-
-#ifndef _DEVICE_H_
-#define _DEVICE_H_
-
-#include <linux/ioport.h>
-#include <linux/kobject.h>
-#include <linux/klist.h>
-#include <linux/list.h>
-#include <linux/lockdep.h>
-#include <linux/compiler.h>
-#include <linux/types.h>
-#include <linux/mutex.h>
-#include <linux/pm.h>
-#include <linux/atomic.h>
-#include <linux/ratelimit.h>
-#include <linux/uidgid.h>
-#include <linux/gfp.h>
-#include <linux/overflow.h>
-#include <linux/android_kabi.h>
-#include <asm/device.h>
-
-struct device;
-struct device_private;
-struct device_driver;
-struct driver_private;
-struct module;
-struct class;
-struct subsys_private;
-struct bus_type;
-struct device_node;
-struct fwnode_handle;
-struct iommu_ops;
-struct iommu_group;
-struct iommu_fwspec;
-struct dev_pin_info;
-
-struct bus_attribute {
-	struct attribute	attr;
-	ssize_t (*show)(struct bus_type *bus, char *buf);
-	ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);
-};
-
-#define BUS_ATTR(_name, _mode, _show, _store)	\
-	struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show, _store)
-#define BUS_ATTR_RW(_name) \
-	struct bus_attribute bus_attr_##_name = __ATTR_RW(_name)
-#define BUS_ATTR_RO(_name) \
-	struct bus_attribute bus_attr_##_name = __ATTR_RO(_name)
-
-extern int __must_check bus_create_file(struct bus_type *,
-					struct bus_attribute *);
-extern void bus_remove_file(struct bus_type *, struct bus_attribute *);
-
-/**
- * struct bus_type - The bus type of the device
- *
- * @name:	The name of the bus.
- * @dev_name:	Used for subsystems to enumerate devices like ("foo%u", dev->id).
- * @dev_root:	Default device to use as the parent.
- * @bus_groups:	Default attributes of the bus.
- * @dev_groups:	Default attributes of the devices on the bus.
- * @drv_groups: Default attributes of the device drivers on the bus.
- * @match:	Called, perhaps multiple times, whenever a new device or driver
- *		is added for this bus. It should return a positive value if the
- *		given device can be handled by the given driver and zero
- *		otherwise. It may also return error code if determining that
- *		the driver supports the device is not possible. In case of
- *		-EPROBE_DEFER it will queue the device for deferred probing.
- * @uevent:	Called when a device is added, removed, or a few other things
- *		that generate uevents to add the environment variables.
- * @probe:	Called when a new device or driver add to this bus, and callback
- *		the specific driver's probe to initial the matched device.
- * @sync_state:	Called to sync device state to software state after all the
- *		state tracking consumers linked to this device (present at
- *		the time of late_initcall) have successfully bound to a
- *		driver. If the device has no consumers, this function will
- *		be called at late_initcall_sync level. If the device has
- *		consumers that are never bound to a driver, this function
- *		will never get called until they do.
- * @remove:	Called when a device removed from this bus.
- * @shutdown:	Called at shut-down time to quiesce the device.
- *
- * @online:	Called to put the device back online (after offlining it).
- * @offline:	Called to put the device offline for hot-removal. May fail.
- *
- * @suspend:	Called when a device on this bus wants to go to sleep mode.
- * @resume:	Called to bring a device on this bus out of sleep mode.
- * @num_vf:	Called to find out how many virtual functions a device on this
- *		bus supports.
- * @dma_configure:	Called to setup DMA configuration on a device on
- *			this bus.
- * @pm:		Power management operations of this bus, callback the specific
- *		device driver's pm-ops.
- * @iommu_ops:  IOMMU specific operations for this bus, used to attach IOMMU
- *              driver implementations to a bus and allow the driver to do
- *              bus-specific setup
- * @p:		The private data of the driver core, only the driver core can
- *		touch this.
- * @lock_key:	Lock class key for use by the lock validator
- * @need_parent_lock:	When probing or removing a device on this bus, the
- *			device core should lock the device's parent.
- *
- * A bus is a channel between the processor and one or more devices. For the
- * purposes of the device model, all devices are connected via a bus, even if
- * it is an internal, virtual, "platform" bus. Buses can plug into each other.
- * A USB controller is usually a PCI device, for example. The device model
- * represents the actual connections between buses and the devices they control.
- * A bus is represented by the bus_type structure. It contains the name, the
- * default attributes, the bus' methods, PM operations, and the driver core's
- * private data.
- */
-struct bus_type {
-	const char		*name;
-	const char		*dev_name;
-	struct device		*dev_root;
-	const struct attribute_group **bus_groups;
-	const struct attribute_group **dev_groups;
-	const struct attribute_group **drv_groups;
-
-	int (*match)(struct device *dev, struct device_driver *drv);
-	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
-	int (*probe)(struct device *dev);
-	void (*sync_state)(struct device *dev);
-	int (*remove)(struct device *dev);
-	void (*shutdown)(struct device *dev);
-
-	int (*online)(struct device *dev);
-	int (*offline)(struct device *dev);
-
-	int (*suspend)(struct device *dev, pm_message_t state);
-	int (*resume)(struct device *dev);
-
-	int (*num_vf)(struct device *dev);
-
-	int (*dma_configure)(struct device *dev);
-
-	const struct dev_pm_ops *pm;
-
-	const struct iommu_ops *iommu_ops;
-
-	struct subsys_private *p;
-	struct lock_class_key lock_key;
-
-	bool need_parent_lock;
-
-	ANDROID_KABI_RESERVE(1);
-	ANDROID_KABI_RESERVE(2);
-	ANDROID_KABI_RESERVE(3);
-	ANDROID_KABI_RESERVE(4);
-};
-
-extern int __must_check bus_register(struct bus_type *bus);
-
-extern void bus_unregister(struct bus_type *bus);
-
-extern int __must_check bus_rescan_devices(struct bus_type *bus);
-
-/* iterator helpers for buses */
-struct subsys_dev_iter {
-	struct klist_iter		ki;
-	const struct device_type	*type;
-};
-void subsys_dev_iter_init(struct subsys_dev_iter *iter,
-			 struct bus_type *subsys,
-			 struct device *start,
-			 const struct device_type *type);
-struct device *subsys_dev_iter_next(struct subsys_dev_iter *iter);
-void subsys_dev_iter_exit(struct subsys_dev_iter *iter);
-
-int bus_for_each_dev(struct bus_type *bus, struct device *start, void *data,
-		     int (*fn)(struct device *dev, void *data));
-struct device *bus_find_device(struct bus_type *bus, struct device *start,
-			       void *data,
-			       int (*match)(struct device *dev, void *data));
-struct device *bus_find_device_by_name(struct bus_type *bus,
-				       struct device *start,
-				       const char *name);
-struct device *subsys_find_device_by_id(struct bus_type *bus, unsigned int id,
-					struct device *hint);
-int bus_for_each_drv(struct bus_type *bus, struct device_driver *start,
-		     void *data, int (*fn)(struct device_driver *, void *));
-void bus_sort_breadthfirst(struct bus_type *bus,
-			   int (*compare)(const struct device *a,
-					  const struct device *b));
-/*
- * Bus notifiers: Get notified of addition/removal of devices
- * and binding/unbinding of drivers to devices.
- * In the long run, it should be a replacement for the platform
- * notify hooks.
- */
-struct notifier_block;
-
-extern int bus_register_notifier(struct bus_type *bus,
-				 struct notifier_block *nb);
-extern int bus_unregister_notifier(struct bus_type *bus,
-				   struct notifier_block *nb);
-
-/* All 4 notifers below get called with the target struct device *
- * as an argument. Note that those functions are likely to be called
- * with the device lock held in the core, so be careful.
- */
-#define BUS_NOTIFY_ADD_DEVICE		0x00000001 /* device added */
-#define BUS_NOTIFY_DEL_DEVICE		0x00000002 /* device to be removed */
-#define BUS_NOTIFY_REMOVED_DEVICE	0x00000003 /* device removed */
-#define BUS_NOTIFY_BIND_DRIVER		0x00000004 /* driver about to be
-						      bound */
-#define BUS_NOTIFY_BOUND_DRIVER		0x00000005 /* driver bound to device */
-#define BUS_NOTIFY_UNBIND_DRIVER	0x00000006 /* driver about to be
-						      unbound */
-#define BUS_NOTIFY_UNBOUND_DRIVER	0x00000007 /* driver is unbound
-						      from the device */
-#define BUS_NOTIFY_DRIVER_NOT_BOUND	0x00000008 /* driver fails to be bound */
-
-extern struct kset *bus_get_kset(struct bus_type *bus);
-extern struct klist *bus_get_device_klist(struct bus_type *bus);
-
-/**
- * enum probe_type - device driver probe type to try
- *	Device drivers may opt in for special handling of their
- *	respective probe routines. This tells the core what to
- *	expect and prefer.
- *
- * @PROBE_DEFAULT_STRATEGY: Used by drivers that work equally well
- *	whether probed synchronously or asynchronously.
- * @PROBE_PREFER_ASYNCHRONOUS: Drivers for "slow" devices which
- *	probing order is not essential for booting the system may
- *	opt into executing their probes asynchronously.
- * @PROBE_FORCE_SYNCHRONOUS: Use this to annotate drivers that need
- *	their probe routines to run synchronously with driver and
- *	device registration (with the exception of -EPROBE_DEFER
- *	handling - re-probing always ends up being done asynchronously).
- *
- * Note that the end goal is to switch the kernel to use asynchronous
- * probing by default, so annotating drivers with
- * %PROBE_PREFER_ASYNCHRONOUS is a temporary measure that allows us
- * to speed up boot process while we are validating the rest of the
- * drivers.
- */
-enum probe_type {
-	PROBE_DEFAULT_STRATEGY,
-	PROBE_PREFER_ASYNCHRONOUS,
-	PROBE_FORCE_SYNCHRONOUS,
-};
-
-/**
- * struct device_driver - The basic device driver structure
- * @name:	Name of the device driver.
- * @bus:	The bus which the device of this driver belongs to.
- * @owner:	The module owner.
- * @mod_name:	Used for built-in modules.
- * @suppress_bind_attrs: Disables bind/unbind via sysfs.
- * @probe_type:	Type of the probe (synchronous or asynchronous) to use.
- * @of_match_table: The open firmware table.
- * @acpi_match_table: The ACPI match table.
- * @probe:	Called to query the existence of a specific device,
- *		whether this driver can work with it, and bind the driver
- *		to a specific device.
- * @sync_state:	Called to sync device state to software state after all the
- *		state tracking consumers linked to this device (present at
- *		the time of late_initcall) have successfully bound to a
- *		driver. If the device has no consumers, this function will
- *		be called at late_initcall_sync level. If the device has
- *		consumers that are never bound to a driver, this function
- *		will never get called until they do.
- * @remove:	Called when the device is removed from the system to
- *		unbind a device from this driver.
- * @shutdown:	Called at shut-down time to quiesce the device.
- * @suspend:	Called to put the device to sleep mode. Usually to a
- *		low power state.
- * @resume:	Called to bring a device from sleep mode.
- * @groups:	Default attributes that get created by the driver core
- *		automatically.
- * @pm:		Power management operations of the device which matched
- *		this driver.
- * @coredump:	Called when sysfs entry is written to. The device driver
- *		is expected to call the dev_coredump API resulting in a
- *		uevent.
- * @p:		Driver core's private data, no one other than the driver
- *		core can touch this.
- *
- * The device driver-model tracks all of the drivers known to the system.
- * The main reason for this tracking is to enable the driver core to match
- * up drivers with new devices. Once drivers are known objects within the
- * system, however, a number of other things become possible. Device drivers
- * can export information and configuration variables that are independent
- * of any specific device.
- */
-struct device_driver {
-	const char		*name;
-	struct bus_type		*bus;
-
-	struct module		*owner;
-	const char		*mod_name;	/* used for built-in modules */
-
-	bool suppress_bind_attrs;	/* disables bind/unbind via sysfs */
-	enum probe_type probe_type;
-
-	const struct of_device_id	*of_match_table;
-	const struct acpi_device_id	*acpi_match_table;
-
-	int (*probe) (struct device *dev);
-	void (*sync_state)(struct device *dev);
-	int (*remove) (struct device *dev);
-	void (*shutdown) (struct device *dev);
-	int (*suspend) (struct device *dev, pm_message_t state);
-	int (*resume) (struct device *dev);
-	const struct attribute_group **groups;
-
-	const struct dev_pm_ops *pm;
-	void (*coredump) (struct device *dev);
-
-	struct driver_private *p;
-
-	ANDROID_KABI_RESERVE(1);
-	ANDROID_KABI_RESERVE(2);
-	ANDROID_KABI_RESERVE(3);
-	ANDROID_KABI_RESERVE(4);
-};
-
-
-extern int __must_check driver_register(struct device_driver *drv);
-extern void driver_unregister(struct device_driver *drv);
-
-extern struct device_driver *driver_find(const char *name,
-					 struct bus_type *bus);
-extern int driver_probe_done(void);
-extern void wait_for_device_probe(void);
-
-/* sysfs interface for exporting driver attributes */
-
-struct driver_attribute {
-	struct attribute attr;
-	ssize_t (*show)(struct device_driver *driver, char *buf);
-	ssize_t (*store)(struct device_driver *driver, const char *buf,
-			 size_t count);
-};
-
-#define DRIVER_ATTR_RW(_name) \
-	struct driver_attribute driver_attr_##_name = __ATTR_RW(_name)
-#define DRIVER_ATTR_RO(_name) \
-	struct driver_attribute driver_attr_##_name = __ATTR_RO(_name)
-#define DRIVER_ATTR_WO(_name) \
-	struct driver_attribute driver_attr_##_name = __ATTR_WO(_name)
-
-extern int __must_check driver_create_file(struct device_driver *driver,
-					const struct driver_attribute *attr);
-extern void driver_remove_file(struct device_driver *driver,
-			       const struct driver_attribute *attr);
-
-extern int __must_check driver_for_each_device(struct device_driver *drv,
-					       struct device *start,
-					       void *data,
-					       int (*fn)(struct device *dev,
-							 void *));
-struct device *driver_find_device(struct device_driver *drv,
-				  struct device *start, void *data,
-				  int (*match)(struct device *dev, void *data));
-
-void driver_deferred_probe_add(struct device *dev);
-int driver_deferred_probe_check_state(struct device *dev);
-
-/**
- * struct subsys_interface - interfaces to device functions
- * @name:       name of the device function
- * @subsys:     subsytem of the devices to attach to
- * @node:       the list of functions registered at the subsystem
- * @add_dev:    device hookup to device function handler
- * @remove_dev: device hookup to device function handler
- *
- * Simple interfaces attached to a subsystem. Multiple interfaces can
- * attach to a subsystem and its devices. Unlike drivers, they do not
- * exclusively claim or control devices. Interfaces usually represent
- * a specific functionality of a subsystem/class of devices.
- */
-struct subsys_interface {
-	const char *name;
-	struct bus_type *subsys;
-	struct list_head node;
-	int (*add_dev)(struct device *dev, struct subsys_interface *sif);
-	void (*remove_dev)(struct device *dev, struct subsys_interface *sif);
-};
-
-int subsys_interface_register(struct subsys_interface *sif);
-void subsys_interface_unregister(struct subsys_interface *sif);
-
-int subsys_system_register(struct bus_type *subsys,
-			   const struct attribute_group **groups);
-int subsys_virtual_register(struct bus_type *subsys,
-			    const struct attribute_group **groups);
-
-/**
- * struct class - device classes
- * @name:	Name of the class.
- * @owner:	The module owner.
- * @class_groups: Default attributes of this class.
- * @dev_groups:	Default attributes of the devices that belong to the class.
- * @dev_kobj:	The kobject that represents this class and links it into the hierarchy.
- * @dev_uevent:	Called when a device is added, removed from this class, or a
- *		few other things that generate uevents to add the environment
- *		variables.
- * @devnode:	Callback to provide the devtmpfs.
- * @class_release: Called to release this class.
- * @dev_release: Called to release the device.
- * @shutdown_pre: Called at shut-down time before driver shutdown.
- * @ns_type:	Callbacks so sysfs can detemine namespaces.
- * @namespace:	Namespace of the device belongs to this class.
- * @get_ownership: Allows class to specify uid/gid of the sysfs directories
- *		for the devices belonging to the class. Usually tied to
- *		device's namespace.
- * @pm:		The default device power management operations of this class.
- * @p:		The private data of the driver core, no one other than the
- *		driver core can touch this.
- *
- * A class is a higher-level view of a device that abstracts out low-level
- * implementation details. Drivers may see a SCSI disk or an ATA disk, but,
- * at the class level, they are all simply disks. Classes allow user space
- * to work with devices based on what they do, rather than how they are
- * connected or how they work.
- */
-struct class {
-	const char		*name;
-	struct module		*owner;
-
-	const struct attribute_group	**class_groups;
-	const struct attribute_group	**dev_groups;
-	struct kobject			*dev_kobj;
-
-	int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env);
-	char *(*devnode)(struct device *dev, umode_t *mode);
-
-	void (*class_release)(struct class *class);
-	void (*dev_release)(struct device *dev);
-
-	int (*shutdown_pre)(struct device *dev);
-
-	const struct kobj_ns_type_operations *ns_type;
-	const void *(*namespace)(struct device *dev);
-
-	void (*get_ownership)(struct device *dev, kuid_t *uid, kgid_t *gid);
-
-	const struct dev_pm_ops *pm;
-
-	struct subsys_private *p;
-
-	ANDROID_KABI_RESERVE(1);
-	ANDROID_KABI_RESERVE(2);
-	ANDROID_KABI_RESERVE(3);
-	ANDROID_KABI_RESERVE(4);
-};
-
-struct class_dev_iter {
-	struct klist_iter		ki;
-	const struct device_type	*type;
-};
-
-extern struct kobject *sysfs_dev_block_kobj;
-extern struct kobject *sysfs_dev_char_kobj;
-extern int __must_check __class_register(struct class *class,
-					 struct lock_class_key *key);
-extern void class_unregister(struct class *class);
-
-/* This is a #define to keep the compiler from merging different
- * instances of the __key variable */
-#define class_register(class)			\
-({						\
-	static struct lock_class_key __key;	\
-	__class_register(class, &__key);	\
-})
-
-struct class_compat;
-struct class_compat *class_compat_register(const char *name);
-void class_compat_unregister(struct class_compat *cls);
-int class_compat_create_link(struct class_compat *cls, struct device *dev,
-			     struct device *device_link);
-void class_compat_remove_link(struct class_compat *cls, struct device *dev,
-			      struct device *device_link);
-
-extern void class_dev_iter_init(struct class_dev_iter *iter,
-				struct class *class,
-				struct device *start,
-				const struct device_type *type);
-extern struct device *class_dev_iter_next(struct class_dev_iter *iter);
-extern void class_dev_iter_exit(struct class_dev_iter *iter);
-
-extern int class_for_each_device(struct class *class, struct device *start,
-				 void *data,
-				 int (*fn)(struct device *dev, void *data));
-extern struct device *class_find_device(struct class *class,
-					struct device *start, const void *data,
-					int (*match)(struct device *, const void *));
-
-struct class_attribute {
-	struct attribute attr;
-	ssize_t (*show)(struct class *class, struct class_attribute *attr,
-			char *buf);
-	ssize_t (*store)(struct class *class, struct class_attribute *attr,
-			const char *buf, size_t count);
-};
-
-#define CLASS_ATTR_RW(_name) \
-	struct class_attribute class_attr_##_name = __ATTR_RW(_name)
-#define CLASS_ATTR_RO(_name) \
-	struct class_attribute class_attr_##_name = __ATTR_RO(_name)
-#define CLASS_ATTR_WO(_name) \
-	struct class_attribute class_attr_##_name = __ATTR_WO(_name)
-
-extern int __must_check class_create_file_ns(struct class *class,
-					     const struct class_attribute *attr,
-					     const void *ns);
-extern void class_remove_file_ns(struct class *class,
-				 const struct class_attribute *attr,
-				 const void *ns);
-
-static inline int __must_check class_create_file(struct class *class,
-					const struct class_attribute *attr)
-{
-	return class_create_file_ns(class, attr, NULL);
-}
-
-static inline void class_remove_file(struct class *class,
-				     const struct class_attribute *attr)
-{
-	return class_remove_file_ns(class, attr, NULL);
-}
-
-/* Simple class attribute that is just a static string */
-struct class_attribute_string {
-	struct class_attribute attr;
-	char *str;
-};
-
-/* Currently read-only only */
-#define _CLASS_ATTR_STRING(_name, _mode, _str) \
-	{ __ATTR(_name, _mode, show_class_attr_string, NULL), _str }
-#define CLASS_ATTR_STRING(_name, _mode, _str) \
-	struct class_attribute_string class_attr_##_name = \
-		_CLASS_ATTR_STRING(_name, _mode, _str)
-
-extern ssize_t show_class_attr_string(struct class *class, struct class_attribute *attr,
-                        char *buf);
-
-struct class_interface {
-	struct list_head	node;
-	struct class		*class;
-
-	int (*add_dev)		(struct device *, struct class_interface *);
-	void (*remove_dev)	(struct device *, struct class_interface *);
-};
-
-extern int __must_check class_interface_register(struct class_interface *);
-extern void class_interface_unregister(struct class_interface *);
-
-extern struct class * __must_check __class_create(struct module *owner,
-						  const char *name,
-						  struct lock_class_key *key);
-extern void class_destroy(struct class *cls);
-
-/* This is a #define to keep the compiler from merging different
- * instances of the __key variable */
-#define class_create(owner, name)		\
-({						\
-	static struct lock_class_key __key;	\
-	__class_create(owner, name, &__key);	\
-})
-
-/*
- * The type of device, "struct device" is embedded in. A class
- * or bus can contain devices of different types
- * like "partitions" and "disks", "mouse" and "event".
- * This identifies the device type and carries type-specific
- * information, equivalent to the kobj_type of a kobject.
- * If "name" is specified, the uevent will contain it in
- * the DEVTYPE variable.
- */
-struct device_type {
-	const char *name;
-	const struct attribute_group **groups;
-	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
-	char *(*devnode)(struct device *dev, umode_t *mode,
-			 kuid_t *uid, kgid_t *gid);
-	void (*release)(struct device *dev);
-
-	const struct dev_pm_ops *pm;
-};
-
-/* interface for exporting device attributes */
-struct device_attribute {
-	struct attribute	attr;
-	ssize_t (*show)(struct device *dev, struct device_attribute *attr,
-			char *buf);
-	ssize_t (*store)(struct device *dev, struct device_attribute *attr,
-			 const char *buf, size_t count);
-};
-
-struct dev_ext_attribute {
-	struct device_attribute attr;
-	void *var;
-};
-
-ssize_t device_show_ulong(struct device *dev, struct device_attribute *attr,
-			  char *buf);
-ssize_t device_store_ulong(struct device *dev, struct device_attribute *attr,
-			   const char *buf, size_t count);
-ssize_t device_show_int(struct device *dev, struct device_attribute *attr,
-			char *buf);
-ssize_t device_store_int(struct device *dev, struct device_attribute *attr,
-			 const char *buf, size_t count);
-ssize_t device_show_bool(struct device *dev, struct device_attribute *attr,
-			char *buf);
-ssize_t device_store_bool(struct device *dev, struct device_attribute *attr,
-			 const char *buf, size_t count);
-
-#define DEVICE_ATTR(_name, _mode, _show, _store) \
-	struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)
-#define DEVICE_ATTR_PREALLOC(_name, _mode, _show, _store) \
-	struct device_attribute dev_attr_##_name = \
-		__ATTR_PREALLOC(_name, _mode, _show, _store)
-#define DEVICE_ATTR_RW(_name) \
-	struct device_attribute dev_attr_##_name = __ATTR_RW(_name)
-#define DEVICE_ATTR_RO(_name) \
-	struct device_attribute dev_attr_##_name = __ATTR_RO(_name)
-#define DEVICE_ATTR_WO(_name) \
-	struct device_attribute dev_attr_##_name = __ATTR_WO(_name)
-#define DEVICE_ULONG_ATTR(_name, _mode, _var) \
-	struct dev_ext_attribute dev_attr_##_name = \
-		{ __ATTR(_name, _mode, device_show_ulong, device_store_ulong), &(_var) }
-#define DEVICE_INT_ATTR(_name, _mode, _var) \
-	struct dev_ext_attribute dev_attr_##_name = \
-		{ __ATTR(_name, _mode, device_show_int, device_store_int), &(_var) }
-#define DEVICE_BOOL_ATTR(_name, _mode, _var) \
-	struct dev_ext_attribute dev_attr_##_name = \
-		{ __ATTR(_name, _mode, device_show_bool, device_store_bool), &(_var) }
-#define DEVICE_ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store) \
-	struct device_attribute dev_attr_##_name =		\
-		__ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store)
-
-extern int device_create_file(struct device *device,
-			      const struct device_attribute *entry);
-extern void device_remove_file(struct device *dev,
-			       const struct device_attribute *attr);
-extern bool device_remove_file_self(struct device *dev,
-				    const struct device_attribute *attr);
-extern int __must_check device_create_bin_file(struct device *dev,
-					const struct bin_attribute *attr);
-extern void device_remove_bin_file(struct device *dev,
-				   const struct bin_attribute *attr);
-
-/* device resource management */
-typedef void (*dr_release_t)(struct device *dev, void *res);
-typedef int (*dr_match_t)(struct device *dev, void *res, void *match_data);
-
-#ifdef CONFIG_DEBUG_DEVRES
-extern void *__devres_alloc_node(dr_release_t release, size_t size, gfp_t gfp,
-				 int nid, const char *name) __malloc;
-#define devres_alloc(release, size, gfp) \
-	__devres_alloc_node(release, size, gfp, NUMA_NO_NODE, #release)
-#define devres_alloc_node(release, size, gfp, nid) \
-	__devres_alloc_node(release, size, gfp, nid, #release)
-#else
-extern void *devres_alloc_node(dr_release_t release, size_t size, gfp_t gfp,
-			       int nid) __malloc;
-static inline void *devres_alloc(dr_release_t release, size_t size, gfp_t gfp)
-{
-	return devres_alloc_node(release, size, gfp, NUMA_NO_NODE);
-}
-#endif
-
-extern void devres_for_each_res(struct device *dev, dr_release_t release,
-				dr_match_t match, void *match_data,
-				void (*fn)(struct device *, void *, void *),
-				void *data);
-extern void devres_free(void *res);
-extern void devres_add(struct device *dev, void *res);
-extern void *devres_find(struct device *dev, dr_release_t release,
-			 dr_match_t match, void *match_data);
-extern void *devres_get(struct device *dev, void *new_res,
-			dr_match_t match, void *match_data);
-extern void *devres_remove(struct device *dev, dr_release_t release,
-			   dr_match_t match, void *match_data);
-extern int devres_destroy(struct device *dev, dr_release_t release,
-			  dr_match_t match, void *match_data);
-extern int devres_release(struct device *dev, dr_release_t release,
-			  dr_match_t match, void *match_data);
-
-/* devres group */
-extern void * __must_check devres_open_group(struct device *dev, void *id,
-					     gfp_t gfp);
-extern void devres_close_group(struct device *dev, void *id);
-extern void devres_remove_group(struct device *dev, void *id);
-extern int devres_release_group(struct device *dev, void *id);
-
-/* managed devm_k.alloc/kfree for device drivers */
-extern void *devm_kmalloc(struct device *dev, size_t size, gfp_t gfp) __malloc;
-extern __printf(3, 0)
-char *devm_kvasprintf(struct device *dev, gfp_t gfp, const char *fmt,
-		      va_list ap) __malloc;
-extern __printf(3, 4)
-char *devm_kasprintf(struct device *dev, gfp_t gfp, const char *fmt, ...) __malloc;
-static inline void *devm_kzalloc(struct device *dev, size_t size, gfp_t gfp)
-{
-	return devm_kmalloc(dev, size, gfp | __GFP_ZERO);
-}
-static inline void *devm_kmalloc_array(struct device *dev,
-				       size_t n, size_t size, gfp_t flags)
-{
-	size_t bytes;
-
-	if (unlikely(check_mul_overflow(n, size, &bytes)))
-		return NULL;
-
-	return devm_kmalloc(dev, bytes, flags);
-}
-static inline void *devm_kcalloc(struct device *dev,
-				 size_t n, size_t size, gfp_t flags)
-{
-	return devm_kmalloc_array(dev, n, size, flags | __GFP_ZERO);
-}
-extern void devm_kfree(struct device *dev, void *p);
-extern char *devm_kstrdup(struct device *dev, const char *s, gfp_t gfp) __malloc;
-extern void *devm_kmemdup(struct device *dev, const void *src, size_t len,
-			  gfp_t gfp);
-
-extern unsigned long devm_get_free_pages(struct device *dev,
-					 gfp_t gfp_mask, unsigned int order);
-extern void devm_free_pages(struct device *dev, unsigned long addr);
-
-void __iomem *devm_ioremap_resource(struct device *dev,
-				    const struct resource *res);
-
-void __iomem *devm_of_iomap(struct device *dev,
-			    struct device_node *node, int index,
-			    resource_size_t *size);
-
-/* allows to add/remove a custom action to devres stack */
-int devm_add_action(struct device *dev, void (*action)(void *), void *data);
-void devm_remove_action(struct device *dev, void (*action)(void *), void *data);
-
-static inline int devm_add_action_or_reset(struct device *dev,
-					   void (*action)(void *), void *data)
-{
-	int ret;
-
-	ret = devm_add_action(dev, action, data);
-	if (ret)
-		action(data);
-
-	return ret;
-}
-
-/**
- * devm_alloc_percpu - Resource-managed alloc_percpu
- * @dev: Device to allocate per-cpu memory for
- * @type: Type to allocate per-cpu memory for
- *
- * Managed alloc_percpu. Per-cpu memory allocated with this function is
- * automatically freed on driver detach.
- *
- * RETURNS:
- * Pointer to allocated memory on success, NULL on failure.
- */
-#define devm_alloc_percpu(dev, type)      \
-	((typeof(type) __percpu *)__devm_alloc_percpu((dev), sizeof(type), \
-						      __alignof__(type)))
-
-void __percpu *__devm_alloc_percpu(struct device *dev, size_t size,
-				   size_t align);
-void devm_free_percpu(struct device *dev, void __percpu *pdata);
-
-struct device_dma_parameters {
-	/*
-	 * a low level driver may set these to teach IOMMU code about
-	 * sg limitations.
-	 */
-	unsigned int max_segment_size;
-	unsigned long segment_boundary_mask;
-};
-
-/**
- * struct device_connection - Device Connection Descriptor
- * @fwnode: The device node of the connected device
- * @endpoint: The names of the two devices connected together
- * @id: Unique identifier for the connection
- * @list: List head, private, for internal use only
- *
- * NOTE: @fwnode is not used together with @endpoint. @fwnode is used when
- * platform firmware defines the connection. When the connection is registered
- * with device_connection_add() @endpoint is used instead.
- */
-struct device_connection {
-	struct fwnode_handle	*fwnode;
-	const char		*endpoint[2];
-	const char		*id;
-	struct list_head	list;
-};
-
-void *device_connection_find_match(struct device *dev, const char *con_id,
-				void *data,
-				void *(*match)(struct device_connection *con,
-					       int ep, void *data));
-
-struct device *device_connection_find(struct device *dev, const char *con_id);
-
-void device_connection_add(struct device_connection *con);
-void device_connection_remove(struct device_connection *con);
-
-/**
- * device_connections_add - Add multiple device connections at once
- * @cons: Zero terminated array of device connection descriptors
- */
-static inline void device_connections_add(struct device_connection *cons)
-{
-	struct device_connection *c;
-
-	for (c = cons; c->endpoint[0]; c++)
-		device_connection_add(c);
-}
-
-/**
- * device_connections_remove - Remove multiple device connections at once
- * @cons: Zero terminated array of device connection descriptors
- */
-static inline void device_connections_remove(struct device_connection *cons)
-{
-	struct device_connection *c;
-
-	for (c = cons; c->endpoint[0]; c++)
-		device_connection_remove(c);
-}
-
-/**
- * enum device_link_state - Device link states.
- * @DL_STATE_NONE: The presence of the drivers is not being tracked.
- * @DL_STATE_DORMANT: None of the supplier/consumer drivers is present.
- * @DL_STATE_AVAILABLE: The supplier driver is present, but the consumer is not.
- * @DL_STATE_CONSUMER_PROBE: The consumer is probing (supplier driver present).
- * @DL_STATE_ACTIVE: Both the supplier and consumer drivers are present.
- * @DL_STATE_SUPPLIER_UNBIND: The supplier driver is unbinding.
- */
-enum device_link_state {
-	DL_STATE_NONE = -1,
-	DL_STATE_DORMANT = 0,
-	DL_STATE_AVAILABLE,
-	DL_STATE_CONSUMER_PROBE,
-	DL_STATE_ACTIVE,
-	DL_STATE_SUPPLIER_UNBIND,
-};
-
-/*
- * Device link flags.
- *
- * STATELESS: The core will not remove this link automatically.
- * AUTOREMOVE_CONSUMER: Remove the link automatically on consumer driver unbind.
- * PM_RUNTIME: If set, the runtime PM framework will use this link.
- * RPM_ACTIVE: Run pm_runtime_get_sync() on the supplier during link creation.
- * AUTOREMOVE_SUPPLIER: Remove the link automatically on supplier driver unbind.
- * AUTOPROBE_CONSUMER: Probe consumer driver automatically after supplier binds.
- * MANAGED: The core tracks presence of supplier/consumer drivers (internal).
- * SYNC_STATE_ONLY: Link only affects sync_state() behavior.
- */
-#define DL_FLAG_STATELESS		BIT(0)
-#define DL_FLAG_AUTOREMOVE_CONSUMER	BIT(1)
-#define DL_FLAG_PM_RUNTIME		BIT(2)
-#define DL_FLAG_RPM_ACTIVE		BIT(3)
-#define DL_FLAG_AUTOREMOVE_SUPPLIER	BIT(4)
-#define DL_FLAG_AUTOPROBE_CONSUMER	BIT(5)
-#define DL_FLAG_MANAGED			BIT(6)
-#define DL_FLAG_SYNC_STATE_ONLY		BIT(7)
-
-/**
- * struct device_link - Device link representation.
- * @supplier: The device on the supplier end of the link.
- * @s_node: Hook to the supplier device's list of links to consumers.
- * @consumer: The device on the consumer end of the link.
- * @c_node: Hook to the consumer device's list of links to suppliers.
- * @status: The state of the link (with respect to the presence of drivers).
- * @flags: Link flags.
- * @rpm_active: Whether or not the consumer device is runtime-PM-active.
- * @kref: Count repeated addition of the same link.
- * @rcu_head: An RCU head to use for deferred execution of SRCU callbacks.
- */
-struct device_link {
-	struct device *supplier;
-	struct list_head s_node;
-	struct device *consumer;
-	struct list_head c_node;
-	enum device_link_state status;
-	u32 flags;
-	refcount_t rpm_active;
-	struct kref kref;
-#ifdef CONFIG_SRCU
-	struct rcu_head rcu_head;
-#endif
-	bool supplier_preactivated; /* Owned by consumer probe. */
-
-	ANDROID_KABI_RESERVE(1);
-	ANDROID_KABI_RESERVE(2);
-	ANDROID_KABI_RESERVE(3);
-	ANDROID_KABI_RESERVE(4);
-};
-
-/**
- * enum dl_dev_state - Device driver presence tracking information.
- * @DL_DEV_NO_DRIVER: There is no driver attached to the device.
- * @DL_DEV_PROBING: A driver is probing.
- * @DL_DEV_DRIVER_BOUND: The driver has been bound to the device.
- * @DL_DEV_UNBINDING: The driver is unbinding from the device.
- */
-enum dl_dev_state {
-	DL_DEV_NO_DRIVER = 0,
-	DL_DEV_PROBING,
-	DL_DEV_DRIVER_BOUND,
-	DL_DEV_UNBINDING,
-};
-
-/**
- * struct dev_links_info - Device data related to device links.
- * @suppliers: List of links to supplier devices.
- * @consumers: List of links to consumer devices.
- * @needs_suppliers: Hook to global list of devices waiting for suppliers.
- * @defer_hook: Hook to global list of devices that have deferred sync_state or
- *		deferred fw_devlink.
- * @need_for_probe: If needs_suppliers is on a list, this indicates if the
- *		    suppliers are needed for probe or not.
- * @status: Driver status information.
- */
-struct dev_links_info {
-	struct list_head suppliers;
-	struct list_head consumers;
-	struct list_head needs_suppliers;
-	struct list_head defer_hook;
-	bool need_for_probe;
-	enum dl_dev_state status;
-
-	ANDROID_KABI_RESERVE(1);
-	ANDROID_KABI_RESERVE(2);
-	ANDROID_KABI_RESERVE(3);
-	ANDROID_KABI_RESERVE(4);
-};
-
-/**
- * struct device - The basic device structure
- * @parent:	The device's "parent" device, the device to which it is attached.
- * 		In most cases, a parent device is some sort of bus or host
- * 		controller. If parent is NULL, the device, is a top-level device,
- * 		which is not usually what you want.
- * @p:		Holds the private data of the driver core portions of the device.
- * 		See the comment of the struct device_private for detail.
- * @kobj:	A top-level, abstract class from which other classes are derived.
- * @init_name:	Initial name of the device.
- * @type:	The type of device.
- * 		This identifies the device type and carries type-specific
- * 		information.
- * @mutex:	Mutex to synchronize calls to its driver.
- * @bus:	Type of bus device is on.
- * @driver:	Which driver has allocated this
- * @platform_data: Platform data specific to the device.
- * 		Example: For devices on custom boards, as typical of embedded
- * 		and SOC based hardware, Linux often uses platform_data to point
- * 		to board-specific structures describing devices and how they
- * 		are wired.  That can include what ports are available, chip
- * 		variants, which GPIO pins act in what additional roles, and so
- * 		on.  This shrinks the "Board Support Packages" (BSPs) and
- * 		minimizes board-specific #ifdefs in drivers.
- * @driver_data: Private pointer for driver specific info.
- * @links:	Links to suppliers and consumers of this device.
- * @power:	For device power management.
- *		See Documentation/driver-api/pm/devices.rst for details.
- * @pm_domain:	Provide callbacks that are executed during system suspend,
- * 		hibernation, system resume and during runtime PM transitions
- * 		along with subsystem-level and driver-level callbacks.
- * @pins:	For device pin management.
- *		See Documentation/driver-api/pinctl.rst for details.
- * @msi_list:	Hosts MSI descriptors
- * @msi_domain: The generic MSI domain this device is using.
- * @numa_node:	NUMA node this device is close to.
- * @dma_ops:    DMA mapping operations for this device.
- * @dma_mask:	Dma mask (if dma'ble device).
- * @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all
- * 		hardware supports 64-bit addresses for consistent allocations
- * 		such descriptors.
- * @bus_dma_mask: Mask of an upstream bridge or bus which imposes a smaller DMA
- *		limit than the device itself supports.
- * @dma_pfn_offset: offset of DMA memory range relatively of RAM
- * @dma_parms:	A low level driver may set these to teach IOMMU code about
- * 		segment limitations.
- * @dma_pools:	Dma pools (if dma'ble device).
- * @dma_mem:	Internal for coherent mem override.
- * @cma_area:	Contiguous memory area for dma allocations
- * @archdata:	For arch-specific additions.
- * @of_node:	Associated device tree node.
- * @fwnode:	Associated device node supplied by platform firmware.
- * @devt:	For creating the sysfs "dev".
- * @id:		device instance
- * @devres_lock: Spinlock to protect the resource of the device.
- * @devres_head: The resources list of the device.
- * @knode_class: The node used to add the device to the class list.
- * @class:	The class of the device.
- * @groups:	Optional attribute groups.
- * @release:	Callback to free the device after all references have
- * 		gone away. This should be set by the allocator of the
- * 		device (i.e. the bus driver that discovered the device).
- * @iommu_group: IOMMU group the device belongs to.
- * @iommu_fwspec: IOMMU-specific properties supplied by firmware.
- *
- * @offline_disabled: If set, the device is permanently online.
- * @offline:	Set after successful invocation of bus type's .offline().
- * @of_node_reused: Set if the device-tree node is shared with an ancestor
- *              device.
- * @state_synced: The hardware state of this device has been synced to match
- *		  the software state of this device by calling the driver/bus
- *		  sync_state() callback.
- *
- * At the lowest level, every device in a Linux system is represented by an
- * instance of struct device. The device structure contains the information
- * that the device model core needs to model the system. Most subsystems,
- * however, track additional information about the devices they host. As a
- * result, it is rare for devices to be represented by bare device structures;
- * instead, that structure, like kobject structures, is usually embedded within
- * a higher-level representation of the device.
- */
-struct device {
-	struct device		*parent;
-
-	struct device_private	*p;
-
-	struct kobject kobj;
-	const char		*init_name; /* initial name of the device */
-	const struct device_type *type;
-
-	struct mutex		mutex;	/* mutex to synchronize calls to
-					 * its driver.
-					 */
-
-	struct bus_type	*bus;		/* type of bus device is on */
-	struct device_driver *driver;	/* which driver has allocated this
-					   device */
-	void		*platform_data;	/* Platform specific data, device
-					   core doesn't touch it */
-	void		*driver_data;	/* Driver data, set and get with
-					   dev_set/get_drvdata */
-	struct dev_links_info	links;
-	struct dev_pm_info	power;
-	struct dev_pm_domain	*pm_domain;
-
-#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN
-	struct irq_domain	*msi_domain;
-#endif
-#ifdef CONFIG_PINCTRL
-	struct dev_pin_info	*pins;
-#endif
-#ifdef CONFIG_GENERIC_MSI_IRQ
-	struct list_head	msi_list;
-#endif
-
-#ifdef CONFIG_NUMA
-	int		numa_node;	/* NUMA node this device is close to */
-#endif
-	const struct dma_map_ops *dma_ops;
-	u64		*dma_mask;	/* dma mask (if dma'able device) */
-	u64		coherent_dma_mask;/* Like dma_mask, but for
-					     alloc_coherent mappings as
-					     not all hardware supports
-					     64 bit addresses for consistent
-					     allocations such descriptors. */
-	u64		bus_dma_mask;	/* upstream dma_mask constraint */
-	unsigned long	dma_pfn_offset;
-
-	struct device_dma_parameters *dma_parms;
-
-	struct list_head	dma_pools;	/* dma pools (if dma'ble) */
-
-	struct dma_coherent_mem	*dma_mem; /* internal for coherent mem
-					     override */
-#ifdef CONFIG_DMA_CMA
-	struct cma *cma_area;		/* contiguous memory area for dma
-					   allocations */
-#endif
-	struct removed_region *removed_mem;
-	/* arch specific additions */
-	struct dev_archdata	archdata;
-
-	struct device_node	*of_node; /* associated device tree node */
-	struct fwnode_handle	*fwnode; /* firmware device node */
-
-	dev_t			devt;	/* dev_t, creates the sysfs "dev" */
-	u32			id;	/* device instance */
-
-	spinlock_t		devres_lock;
-	struct list_head	devres_head;
-
-	struct klist_node	knode_class;
-	struct class		*class;
-	const struct attribute_group **groups;	/* optional groups */
-
-	void	(*release)(struct device *dev);
-	struct iommu_group	*iommu_group;
-	struct iommu_fwspec	*iommu_fwspec;
-
-	bool			offline_disabled:1;
-	bool			offline:1;
-	bool			of_node_reused:1;
-	bool			state_synced:1;
-
-	ANDROID_KABI_RESERVE(1);
-	ANDROID_KABI_RESERVE(2);
-	ANDROID_KABI_RESERVE(3);
-	ANDROID_KABI_RESERVE(4);
-	ANDROID_KABI_RESERVE(5);
-	ANDROID_KABI_RESERVE(6);
-	ANDROID_KABI_RESERVE(7);
-	ANDROID_KABI_RESERVE(8);
-};
-
-static inline struct device *kobj_to_dev(struct kobject *kobj)
-{
-	return container_of(kobj, struct device, kobj);
-}
-
-/* Get the wakeup routines, which depend on struct device */
-#include <linux/pm_wakeup.h>
-
-static inline const char *dev_name(const struct device *dev)
-{
-	/* Use the init name until the kobject becomes available */
-	if (dev->init_name)
-		return dev->init_name;
-
-	return kobject_name(&dev->kobj);
-}
-
-extern __printf(2, 3)
-int dev_set_name(struct device *dev, const char *name, ...);
-
-#ifdef CONFIG_NUMA
-static inline int dev_to_node(struct device *dev)
-{
-	return dev->numa_node;
-}
-static inline void set_dev_node(struct device *dev, int node)
-{
-	dev->numa_node = node;
-}
-#else
-static inline int dev_to_node(struct device *dev)
-{
-	return -1;
-}
-static inline void set_dev_node(struct device *dev, int node)
-{
-}
-#endif
-
-static inline struct irq_domain *dev_get_msi_domain(const struct device *dev)
-{
-#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN
-	return dev->msi_domain;
-#else
-	return NULL;
-#endif
-}
-
-static inline void dev_set_msi_domain(struct device *dev, struct irq_domain *d)
-{
-#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN
-	dev->msi_domain = d;
-#endif
-}
-
-static inline void *dev_get_drvdata(const struct device *dev)
-{
-	return dev->driver_data;
-}
-
-static inline void dev_set_drvdata(struct device *dev, void *data)
-{
-	dev->driver_data = data;
-}
-
-static inline struct pm_subsys_data *dev_to_psd(struct device *dev)
-{
-	return dev ? dev->power.subsys_data : NULL;
-}
-
-static inline unsigned int dev_get_uevent_suppress(const struct device *dev)
-{
-	return dev->kobj.uevent_suppress;
-}
-
-static inline void dev_set_uevent_suppress(struct device *dev, int val)
-{
-	dev->kobj.uevent_suppress = val;
-}
-
-static inline int device_is_registered(struct device *dev)
-{
-	return dev->kobj.state_in_sysfs;
-}
-
-static inline void device_enable_async_suspend(struct device *dev)
-{
-	if (!dev->power.is_prepared)
-		dev->power.async_suspend = true;
-}
-
-static inline void device_disable_async_suspend(struct device *dev)
-{
-	if (!dev->power.is_prepared)
-		dev->power.async_suspend = false;
-}
-
-static inline bool device_async_suspend_enabled(struct device *dev)
-{
-	return !!dev->power.async_suspend;
-}
-
-static inline bool device_pm_not_required(struct device *dev)
-{
-	return dev->power.no_pm;
-}
-
-static inline void device_set_pm_not_required(struct device *dev)
-{
-	dev->power.no_pm = true;
-}
-
-static inline void dev_pm_syscore_device(struct device *dev, bool val)
-{
-#ifdef CONFIG_PM_SLEEP
-	dev->power.syscore = val;
-#endif
-}
-
-static inline void dev_pm_set_driver_flags(struct device *dev, u32 flags)
-{
-	dev->power.driver_flags = flags;
-}
-
-static inline bool dev_pm_test_driver_flags(struct device *dev, u32 flags)
-{
-	return !!(dev->power.driver_flags & flags);
-}
-
-static inline void device_lock(struct device *dev)
-{
-	mutex_lock(&dev->mutex);
-}
-
-static inline int device_lock_interruptible(struct device *dev)
-{
-	return mutex_lock_interruptible(&dev->mutex);
-}
-
-static inline int device_trylock(struct device *dev)
-{
-	return mutex_trylock(&dev->mutex);
-}
-
-static inline void device_unlock(struct device *dev)
-{
-	mutex_unlock(&dev->mutex);
-}
-
-static inline void device_lock_assert(struct device *dev)
-{
-	lockdep_assert_held(&dev->mutex);
-}
-
-static inline struct device_node *dev_of_node(struct device *dev)
-{
-	if (!IS_ENABLED(CONFIG_OF))
-		return NULL;
-	return dev->of_node;
-}
-
-static inline bool dev_has_sync_state(struct device *dev)
-{
-	if (!dev)
-		return false;
-	if (dev->driver && dev->driver->sync_state)
-		return true;
-	if (dev->bus && dev->bus->sync_state)
-		return true;
-	return false;
-}
-
-void driver_init(void);
-
-/*
- * High level routines for use by the bus drivers
- */
-extern int __must_check device_register(struct device *dev);
-extern void device_unregister(struct device *dev);
-extern void device_initialize(struct device *dev);
-extern int __must_check device_add(struct device *dev);
-extern void device_del(struct device *dev);
-extern int device_for_each_child(struct device *dev, void *data,
-		     int (*fn)(struct device *dev, void *data));
-extern int device_for_each_child_reverse(struct device *dev, void *data,
-		     int (*fn)(struct device *dev, void *data));
-extern struct device *device_find_child(struct device *dev, void *data,
-				int (*match)(struct device *dev, void *data));
-extern int device_rename(struct device *dev, const char *new_name);
-extern int device_move(struct device *dev, struct device *new_parent,
-		       enum dpm_order dpm_order);
-extern const char *device_get_devnode(struct device *dev,
-				      umode_t *mode, kuid_t *uid, kgid_t *gid,
-				      const char **tmp);
-
-static inline bool device_supports_offline(struct device *dev)
-{
-	return dev->bus && dev->bus->offline && dev->bus->online;
-}
-
-extern void lock_device_hotplug(void);
-extern void unlock_device_hotplug(void);
-extern int lock_device_hotplug_sysfs(void);
-extern int device_offline(struct device *dev);
-extern int device_online(struct device *dev);
-extern void set_primary_fwnode(struct device *dev, struct fwnode_handle *fwnode);
-extern void set_secondary_fwnode(struct device *dev, struct fwnode_handle *fwnode);
-void device_set_of_node_from_dev(struct device *dev, const struct device *dev2);
-
-static inline int dev_num_vf(struct device *dev)
-{
-	if (dev->bus && dev->bus->num_vf)
-		return dev->bus->num_vf(dev);
-	return 0;
-}
-
-/*
- * Root device objects for grouping under /sys/devices
- */
-extern struct device *__root_device_register(const char *name,
-					     struct module *owner);
-
-/* This is a macro to avoid include problems with THIS_MODULE */
-#define root_device_register(name) \
-	__root_device_register(name, THIS_MODULE)
-
-extern void root_device_unregister(struct device *root);
-
-static inline void *dev_get_platdata(const struct device *dev)
-{
-	return dev->platform_data;
-}
-
-/*
- * Manual binding of a device to driver. See drivers/base/bus.c
- * for information on use.
- */
-extern int __must_check device_bind_driver(struct device *dev);
-extern void device_release_driver(struct device *dev);
-extern int  __must_check device_attach(struct device *dev);
-extern int __must_check driver_attach(struct device_driver *drv);
-extern void device_initial_probe(struct device *dev);
-extern int __must_check device_reprobe(struct device *dev);
-
-extern bool device_is_bound(struct device *dev);
-
-/*
- * Easy functions for dynamically creating devices on the fly
- */
-extern __printf(5, 0)
-struct device *device_create_vargs(struct class *cls, struct device *parent,
-				   dev_t devt, void *drvdata,
-				   const char *fmt, va_list vargs);
-extern __printf(5, 6)
-struct device *device_create(struct class *cls, struct device *parent,
-			     dev_t devt, void *drvdata,
-			     const char *fmt, ...);
-extern __printf(6, 7)
-struct device *device_create_with_groups(struct class *cls,
-			     struct device *parent, dev_t devt, void *drvdata,
-			     const struct attribute_group **groups,
-			     const char *fmt, ...);
-extern void device_destroy(struct class *cls, dev_t devt);
-
-extern int __must_check device_add_groups(struct device *dev,
-					const struct attribute_group **groups);
-extern void device_remove_groups(struct device *dev,
-				 const struct attribute_group **groups);
-
-static inline int __must_check device_add_group(struct device *dev,
-					const struct attribute_group *grp)
-{
-	const struct attribute_group *groups[] = { grp, NULL };
-
-	return device_add_groups(dev, groups);
-}
-
-static inline void device_remove_group(struct device *dev,
-				       const struct attribute_group *grp)
-{
-	const struct attribute_group *groups[] = { grp, NULL };
-
-	return device_remove_groups(dev, groups);
-}
-
-extern int __must_check devm_device_add_groups(struct device *dev,
-					const struct attribute_group **groups);
-extern void devm_device_remove_groups(struct device *dev,
-				      const struct attribute_group **groups);
-extern int __must_check devm_device_add_group(struct device *dev,
-					const struct attribute_group *grp);
-extern void devm_device_remove_group(struct device *dev,
-				     const struct attribute_group *grp);
-
-/*
- * Platform "fixup" functions - allow the platform to have their say
- * about devices and actions that the general device layer doesn't
- * know about.
- */
-/* Notify platform of device discovery */
-extern int (*platform_notify)(struct device *dev);
-
-extern int (*platform_notify_remove)(struct device *dev);
-
-
-/*
- * get_device - atomically increment the reference count for the device.
- *
- */
-extern struct device *get_device(struct device *dev);
-extern void put_device(struct device *dev);
-extern bool kill_device(struct device *dev);
-
-#ifdef CONFIG_DEVTMPFS
-extern int devtmpfs_create_node(struct device *dev);
-extern int devtmpfs_delete_node(struct device *dev);
-extern int devtmpfs_mount(const char *mntdir);
-#else
-static inline int devtmpfs_create_node(struct device *dev) { return 0; }
-static inline int devtmpfs_delete_node(struct device *dev) { return 0; }
-static inline int devtmpfs_mount(const char *mountpoint) { return 0; }
-#endif
-
-/* drivers/base/power/shutdown.c */
-extern void device_shutdown(void);
-
-/* debugging and troubleshooting/diagnostic helpers. */
-extern const char *dev_driver_string(const struct device *dev);
-
-/* Device links interface. */
-struct device_link *device_link_add(struct device *consumer,
-				    struct device *supplier, u32 flags);
-void device_link_del(struct device_link *link);
-void device_link_remove(void *consumer, struct device *supplier);
-void device_links_supplier_sync_state_pause(void);
-void device_links_supplier_sync_state_resume(void);
-
-#ifndef dev_fmt
-#define dev_fmt(fmt) fmt
-#endif
-
-#ifdef CONFIG_PRINTK
-
-__printf(3, 0)
-int dev_vprintk_emit(int level, const struct device *dev,
-		     const char *fmt, va_list args);
-__printf(3, 4)
-int dev_printk_emit(int level, const struct device *dev, const char *fmt, ...);
-
-__printf(3, 4)
-void dev_printk(const char *level, const struct device *dev,
-		const char *fmt, ...);
-__printf(2, 3)
-void _dev_emerg(const struct device *dev, const char *fmt, ...);
-__printf(2, 3)
-void _dev_alert(const struct device *dev, const char *fmt, ...);
-__printf(2, 3)
-void _dev_crit(const struct device *dev, const char *fmt, ...);
-__printf(2, 3)
-void _dev_err(const struct device *dev, const char *fmt, ...);
-__printf(2, 3)
-void _dev_warn(const struct device *dev, const char *fmt, ...);
-__printf(2, 3)
-void _dev_notice(const struct device *dev, const char *fmt, ...);
-__printf(2, 3)
-void _dev_info(const struct device *dev, const char *fmt, ...);
-
-#else
-
-static inline __printf(3, 0)
-int dev_vprintk_emit(int level, const struct device *dev,
-		     const char *fmt, va_list args)
-{ return 0; }
-static inline __printf(3, 4)
-int dev_printk_emit(int level, const struct device *dev, const char *fmt, ...)
-{ return 0; }
-
-static inline void __dev_printk(const char *level, const struct device *dev,
-				struct va_format *vaf)
-{}
-static inline __printf(3, 4)
-void dev_printk(const char *level, const struct device *dev,
-		 const char *fmt, ...)
-{}
-
-static inline __printf(2, 3)
-void _dev_emerg(const struct device *dev, const char *fmt, ...)
-{}
-static inline __printf(2, 3)
-void _dev_crit(const struct device *dev, const char *fmt, ...)
-{}
-static inline __printf(2, 3)
-void _dev_alert(const struct device *dev, const char *fmt, ...)
-{}
-static inline __printf(2, 3)
-void _dev_err(const struct device *dev, const char *fmt, ...)
-{}
-static inline __printf(2, 3)
-void _dev_warn(const struct device *dev, const char *fmt, ...)
-{}
-static inline __printf(2, 3)
-void _dev_notice(const struct device *dev, const char *fmt, ...)
-{}
-static inline __printf(2, 3)
-void _dev_info(const struct device *dev, const char *fmt, ...)
-{}
-
-#endif
-
-/*
- * #defines for all the dev_<level> macros to prefix with whatever
- * possible use of #define dev_fmt(fmt) ...
- */
-
-#define dev_emerg(dev, fmt, ...)					\
-	_dev_emerg(dev, dev_fmt(fmt), ##__VA_ARGS__)
-#define dev_crit(dev, fmt, ...)						\
-	_dev_crit(dev, dev_fmt(fmt), ##__VA_ARGS__)
-#define dev_alert(dev, fmt, ...)					\
-	_dev_alert(dev, dev_fmt(fmt), ##__VA_ARGS__)
-#define dev_err(dev, fmt, ...)						\
-	_dev_err(dev, dev_fmt(fmt), ##__VA_ARGS__)
-#define dev_warn(dev, fmt, ...)						\
-	_dev_warn(dev, dev_fmt(fmt), ##__VA_ARGS__)
-#define dev_notice(dev, fmt, ...)					\
-	_dev_notice(dev, dev_fmt(fmt), ##__VA_ARGS__)
-#define dev_info(dev, fmt, ...)						\
-	_dev_info(dev, dev_fmt(fmt), ##__VA_ARGS__)
-
-#if defined(CONFIG_DYNAMIC_DEBUG)
-#define dev_dbg(dev, fmt, ...)						\
-	dynamic_dev_dbg(dev, dev_fmt(fmt), ##__VA_ARGS__)
-#elif defined(DEBUG)
-#define dev_dbg(dev, fmt, ...)						\
-	dev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__)
-#else
-#define dev_dbg(dev, fmt, ...)						\
-({									\
-	if (0)								\
-		dev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__); \
-})
-#endif
-
-#ifdef CONFIG_PRINTK
-#define dev_level_once(dev_level, dev, fmt, ...)			\
-do {									\
-	static bool __print_once __read_mostly;				\
-									\
-	if (!__print_once) {						\
-		__print_once = true;					\
-		dev_level(dev, fmt, ##__VA_ARGS__);			\
-	}								\
-} while (0)
-#else
-#define dev_level_once(dev_level, dev, fmt, ...)			\
-do {									\
-	if (0)								\
-		dev_level(dev, fmt, ##__VA_ARGS__);			\
-} while (0)
-#endif
-
-#define dev_emerg_once(dev, fmt, ...)					\
-	dev_level_once(dev_emerg, dev, fmt, ##__VA_ARGS__)
-#define dev_alert_once(dev, fmt, ...)					\
-	dev_level_once(dev_alert, dev, fmt, ##__VA_ARGS__)
-#define dev_crit_once(dev, fmt, ...)					\
-	dev_level_once(dev_crit, dev, fmt, ##__VA_ARGS__)
-#define dev_err_once(dev, fmt, ...)					\
-	dev_level_once(dev_err, dev, fmt, ##__VA_ARGS__)
-#define dev_warn_once(dev, fmt, ...)					\
-	dev_level_once(dev_warn, dev, fmt, ##__VA_ARGS__)
-#define dev_notice_once(dev, fmt, ...)					\
-	dev_level_once(dev_notice, dev, fmt, ##__VA_ARGS__)
-#define dev_info_once(dev, fmt, ...)					\
-	dev_level_once(dev_info, dev, fmt, ##__VA_ARGS__)
-#define dev_dbg_once(dev, fmt, ...)					\
-	dev_level_once(dev_dbg, dev, fmt, ##__VA_ARGS__)
-
-#define dev_level_ratelimited(dev_level, dev, fmt, ...)			\
-do {									\
-	static DEFINE_RATELIMIT_STATE(_rs,				\
-				      DEFAULT_RATELIMIT_INTERVAL,	\
-				      DEFAULT_RATELIMIT_BURST);		\
-	if (__ratelimit(&_rs))						\
-		dev_level(dev, fmt, ##__VA_ARGS__);			\
-} while (0)
-
-#define dev_emerg_ratelimited(dev, fmt, ...)				\
-	dev_level_ratelimited(dev_emerg, dev, fmt, ##__VA_ARGS__)
-#define dev_alert_ratelimited(dev, fmt, ...)				\
-	dev_level_ratelimited(dev_alert, dev, fmt, ##__VA_ARGS__)
-#define dev_crit_ratelimited(dev, fmt, ...)				\
-	dev_level_ratelimited(dev_crit, dev, fmt, ##__VA_ARGS__)
-#define dev_err_ratelimited(dev, fmt, ...)				\
-	dev_level_ratelimited(dev_err, dev, fmt, ##__VA_ARGS__)
-#define dev_warn_ratelimited(dev, fmt, ...)				\
-	dev_level_ratelimited(dev_warn, dev, fmt, ##__VA_ARGS__)
-#define dev_notice_ratelimited(dev, fmt, ...)				\
-	dev_level_ratelimited(dev_notice, dev, fmt, ##__VA_ARGS__)
-#define dev_info_ratelimited(dev, fmt, ...)				\
-	dev_level_ratelimited(dev_info, dev, fmt, ##__VA_ARGS__)
-#if defined(CONFIG_DYNAMIC_DEBUG)
-/* descriptor check is first to prevent flooding with "callbacks suppressed" */
-#define dev_dbg_ratelimited(dev, fmt, ...)				\
-do {									\
-	static DEFINE_RATELIMIT_STATE(_rs,				\
-				      DEFAULT_RATELIMIT_INTERVAL,	\
-				      DEFAULT_RATELIMIT_BURST);		\
-	DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);			\
-	if (unlikely(descriptor.flags & _DPRINTK_FLAGS_PRINT) &&	\
-	    __ratelimit(&_rs))						\
-		__dynamic_dev_dbg(&descriptor, dev, dev_fmt(fmt),	\
-				  ##__VA_ARGS__);			\
-} while (0)
-#elif defined(DEBUG)
-#define dev_dbg_ratelimited(dev, fmt, ...)				\
-do {									\
-	static DEFINE_RATELIMIT_STATE(_rs,				\
-				      DEFAULT_RATELIMIT_INTERVAL,	\
-				      DEFAULT_RATELIMIT_BURST);		\
-	if (__ratelimit(&_rs))						\
-		dev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__); \
-} while (0)
-#else
-#define dev_dbg_ratelimited(dev, fmt, ...)				\
-do {									\
-	if (0)								\
-		dev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__); \
-} while (0)
-#endif
-
-#ifdef VERBOSE_DEBUG
-#define dev_vdbg	dev_dbg
-#else
-#define dev_vdbg(dev, fmt, ...)						\
-({									\
-	if (0)								\
-		dev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__); \
-})
-#endif
-
-/*
- * dev_WARN*() acts like dev_printk(), but with the key difference of
- * using WARN/WARN_ONCE to include file/line information and a backtrace.
- */
-#define dev_WARN(dev, format, arg...) \
-	WARN(1, "%s %s: " format, dev_driver_string(dev), dev_name(dev), ## arg);
-
-#define dev_WARN_ONCE(dev, condition, format, arg...) \
-	WARN_ONCE(condition, "%s %s: " format, \
-			dev_driver_string(dev), dev_name(dev), ## arg)
-
-/* Create alias, so I can be autoloaded. */
-#define MODULE_ALIAS_CHARDEV(major,minor) \
-	MODULE_ALIAS("char-major-" __stringify(major) "-" __stringify(minor))
-#define MODULE_ALIAS_CHARDEV_MAJOR(major) \
-	MODULE_ALIAS("char-major-" __stringify(major) "-*")
-
-#ifdef CONFIG_SYSFS_DEPRECATED
-extern long sysfs_deprecated;
-#else
-#define sysfs_deprecated 0
-#endif
-
-/**
- * module_driver() - Helper macro for drivers that don't do anything
- * special in module init/exit. This eliminates a lot of boilerplate.
- * Each module may only use this macro once, and calling it replaces
- * module_init() and module_exit().
- *
- * @__driver: driver name
- * @__register: register function for this driver type
- * @__unregister: unregister function for this driver type
- * @...: Additional arguments to be passed to __register and __unregister.
- *
- * Use this macro to construct bus specific macros for registering
- * drivers, and do not use it on its own.
- */
-#define module_driver(__driver, __register, __unregister, ...) \
-static int __init __driver##_init(void) \
-{ \
-	return __register(&(__driver) , ##__VA_ARGS__); \
-} \
-module_init(__driver##_init); \
-static void __exit __driver##_exit(void) \
-{ \
-	__unregister(&(__driver) , ##__VA_ARGS__); \
-} \
-module_exit(__driver##_exit);
-
-/**
- * builtin_driver() - Helper macro for drivers that don't do anything
- * special in init and have no exit. This eliminates some boilerplate.
- * Each driver may only use this macro once, and calling it replaces
- * device_initcall (or in some cases, the legacy __initcall).  This is
- * meant to be a direct parallel of module_driver() above but without
- * the __exit stuff that is not used for builtin cases.
- *
- * @__driver: driver name
- * @__register: register function for this driver type
- * @...: Additional arguments to be passed to __register
- *
- * Use this macro to construct bus specific macros for registering
- * drivers, and do not use it on its own.
- */
-#define builtin_driver(__driver, __register, ...) \
-static int __init __driver##_init(void) \
-{ \
-	return __register(&(__driver) , ##__VA_ARGS__); \
-} \
-device_initcall(__driver##_init);
-
-#endif /* _DEVICE_H_ */
+version https://git-lfs.github.com/spec/v1
+oid sha256:a759677a542642ea2f9d93abcee4442ce6e495e0ffc0a5665343b5cbfb6d1cad
+size 60753
diff --git a/mkimage.sh b/mkimage.sh
index b8269bc81a..a23ddb13fc 100755
--- a/mkimage.sh
+++ b/mkimage.sh
@@ -1,322 +1,3 @@
-#!/bin/bash
-set -e
-
-. build/envsetup.sh >/dev/null && setpaths
-
-export PATH=$ANDROID_BUILD_PATHS:$PATH
-TARGET_PRODUCT=`get_build_var TARGET_PRODUCT`
-TARGET_DEVICE_DIR=`get_build_var TARGET_DEVICE_DIR`
-PLATFORM_VERSION=`get_build_var PLATFORM_VERSION`
-PLATFORM_SECURITY_PATCH=`get_build_var PLATFORM_SECURITY_PATCH`
-TARGET_ARCH_VARIANT=`get_build_var TARGET_ARCH_VARIANT`
-TARGET_BASE_PARAMETER_IMAGE=`get_build_var TARGET_BASE_PARAMETER_IMAGE`
-HIGH_RELIABLE_RECOVERY_OTA=`get_build_var HIGH_RELIABLE_RECOVERY_OTA`
-BOARD_AVB_ENABLE=`get_build_var BOARD_AVB_ENABLE`
-BOARD_KERNEL_CMDLINE=`get_build_var BOARD_KERNEL_CMDLINE`
-ROCKCHIP_RECOVERYIMAGE_CMDLINE_ARGS=`get_build_var ROCKCHIP_RECOVERYIMAGE_CMDLINE_ARGS`
-BOARD_BOOTIMG_HEADER_VERSION=`get_build_var BOARD_BOOTIMG_HEADER_VERSION`
-PRODUCT_USE_DYNAMIC_PARTITIONS=`get_build_var PRODUCT_USE_DYNAMIC_PARTITIONS`
-
-echo TARGET_PRODUCT=$TARGET_PRODUCT
-echo TARGET_BASE_PARAMETER_IMAGE==$TARGET_BASE_PARAMETER_IMAGE
-echo HIGH_RELIABLE_RECOVERY_OTA=$HIGH_RELIABLE_RECOVERY_OTA
-echo BOARD_AVB_ENABLE=$BOARD_AVB_ENABLE
-TARGET="withoutkernel"
-if [ "$1"x != ""x  ]; then
-         TARGET=$1
-fi
-
-IMAGE_PATH=rockdev/Image-$TARGET_PRODUCT
-UBOOT_PATH=u-boot
-KERNEL_PATH=kernel
-KERNEL_CONFIG=$KERNEL_PATH/.config
-rm -rf $IMAGE_PATH
-mkdir -p $IMAGE_PATH
-
-if [ "$TARGET_ARCH_VARIANT" = "armv8-a" ]; then
-KERNEL_DEBUG=kernel/arch/arm64/boot/Image
-else
-KERNEL_DEBUG=kernel/arch/arm/boot/zImage
-fi
-
-
-FSTYPE=ext4
-echo system filesysystem is $FSTYPE
-
-BOARD_CONFIG=device/rockchip/common/device.mk
-
-PARAMETER=${TARGET_DEVICE_DIR}/parameter.txt
-FLASH_CONFIG_FILE=${TARGET_DEVICE_DIR}/config.cfg
-
-KERNEL_SRC_PATH=`grep TARGET_PREBUILT_KERNEL ${BOARD_CONFIG} |grep "^\s*TARGET_PREBUILT_KERNEL *:= *[\w]*\s" |awk  '{print $3}'`
-
-[ $(id -u) -eq 0 ] || FAKEROOT=fakeroot
-
-BOOT_OTA="ota"
-
-[ $TARGET != $BOOT_OTA -a $TARGET != "withoutkernel" ] && echo "unknow target[${TARGET}],exit!" && exit 0
-
-    if [ ! -f $OUT/kernel ]
-    then
-	    echo "kernel image not fount![$OUT/kernel] "
-        read -p "copy kernel from TARGET_PREBUILT_KERNEL[$KERNEL_SRC_PATH] (y/n) n to exit?"
-        if [ "$REPLY" == "y" ]
-        then
-            [ -f $KERNEL_SRC_PATH ]  || \
-                echo -n "fatal! TARGET_PREBUILT_KERNEL not eixit! " || \
-                echo -n "check you configuration in [${BOARD_CONFIG}] " || exit 0
-
-            cp ${KERNEL_SRC_PATH} $OUT/kernel
-
-        else
-            exit 0
-        fi
-    fi
-
-
-echo "create dtbo.img.... "
-if [ ! -f "$OUT/dtbo.img" ]; then
-BOARD_DTBO_IMG=$OUT/rebuild-dtbo.img
-else
-BOARD_DTBO_IMG=$OUT/dtbo.img
-fi
-cp -a $BOARD_DTBO_IMG $IMAGE_PATH/dtbo.img
-echo "done."
-
-echo "create boot.img.... "
-if [ "$BOARD_AVB_ENABLE" = "true" ]; then
-cp -a $OUT/boot.img $IMAGE_PATH/boot.img
-cp -a $OUT/boot-debug.img $IMAGE_PATH/boot-debug.img
-else
-echo "BOARD_AVB_ENABLE is false, make boot.img from kernel."
-    mkbootimg --kernel $KERNEL_DEBUG --ramdisk $OUT/ramdisk.img --second kernel/resource.img --os_version $PLATFORM_VERSION --header_version $BOARD_BOOTIMG_HEADER_VERSION --os_patch_level $PLATFORM_SECURITY_PATCH --cmdline "$BOARD_KERNEL_CMDLINE" --output $OUT/boot.img && \
-    cp -a $OUT/boot.img $IMAGE_PATH/boot.img
-fi
-echo "done."
-
-echo "create recovery.img.... "
-if [ "$BOARD_AVB_ENABLE" = "true" ]; then
-cp -a $OUT/recovery.img $IMAGE_PATH/recovery.img
-else
-echo "BOARD_AVB_ENABLE is false, make recovery.img from kernel && out."
-    [ -d $OUT/recovery/root ] && \
-    mkbootfs -d $OUT/system $OUT/recovery/root | minigzip > $OUT/ramdisk-recovery.img && \
-    mkbootimg --kernel $KERNEL_DEBUG --ramdisk $OUT/ramdisk-recovery.img --second kernel/resource.img --os_version $PLATFORM_VERSION --header_version $BOARD_BOOTIMG_HEADER_VERSION --recovery_dtbo $BOARD_DTBO_IMG --os_patch_level $PLATFORM_SECURITY_PATCH --cmdline "$ROCKCHIP_RECOVERYIMAGE_CMDLINE_ARGS" --output $OUT/recovery.img && \
-    cp -a $OUT/recovery.img $IMAGE_PATH/recovery.img
-fi
-echo "done."
-
-echo -n "create system.img.... "
-if [ "$BOARD_AVB_ENABLE" = "true" ]; then
-echo -n "system.img has been signed by avbtool, just copy."
-else
-echo "BOARD_AVB_ENABLE is false, make system.img from out."
-    [ -d $OUT/system ] && \
-    python build/make/tools/releasetools/build_image.py \
-    $OUT/system \
-    $OUT/obj/PACKAGING/systemimage_intermediates/system_image_info.txt \
-    $OUT/system.img \
-    $OUT/system
-fi
-python device/rockchip/common/sparse_tool.py $OUT/system.img
-mv $OUT/system.img.out $OUT/system.img
-cp -f $OUT/system.img $IMAGE_PATH/system.img
-#cp -f $OUT/system.img $IMAGE_PATH/system.img
-echo "done."
-
-echo -n "create vbmeta.img.... "
-if [ "$BOARD_AVB_ENABLE" = "true" ]; then
-cp -a $OUT/vbmeta.img $IMAGE_PATH/vbmeta.img
-else
-echo -n "BOARD_AVB_ENABLE is false,use default vbmeta.img"
-cp -a device/rockchip/common/vbmeta.img $IMAGE_PATH/vbmeta.img
-fi
-echo -n "done."
-
-echo -n "create vendor.img..."
-if [ "$BOARD_AVB_ENABLE" = "true" ]; then
-echo -n "vendor.img has been signed by avbtool, just copy."
-else
-echo "BOARD_AVB_ENABLE is false, make vendor.img from out."
-    [ -d $OUT/vendor ] && \
-    python build/make/tools/releasetools/build_image.py \
-    $OUT/vendor \
-    $OUT/obj/PACKAGING/vendor_intermediates/vendor_image_info.txt \
-    $OUT/vendor.img \
-    $OUT/system
-fi
-python device/rockchip/common/sparse_tool.py $OUT/vendor.img
-mv $OUT/vendor.img.out $OUT/vendor.img
-cp -a $OUT/vendor.img $IMAGE_PATH/vendor.img
-echo -n "done."
-
-echo -n "create odm.img..."
-if [ "$BOARD_AVB_ENABLE" = "true" ]; then
-echo -n "odm.img has been signed by avbtool, just copy."
-else
-echo "BOARD_AVB_ENABLE is false, make odm.img from out."
-    [ -d $OUT/odm ] && \
-    python build/make/tools/releasetools/build_image.py \
-    $OUT/odm \
-    $OUT/obj/PACKAGING/odm_intermediates/odm_image_info.txt \
-    $OUT/odm.img \
-    $OUT/system
-fi
-python device/rockchip/common/sparse_tool.py $OUT/odm.img
-mv $OUT/odm.img.out $OUT/odm.img
-cp -f $OUT/odm.img $IMAGE_PATH/odm.img
-echo "done."
-
-if [ "$PRODUCT_USE_DYNAMIC_PARTITIONS" = "true" ]; then
-    cp -a $OUT/super.img $IMAGE_PATH/super.img
-    echo "copy super.img..."
-fi
-
-echo -n "create misc.img.... "
-cp -a rkst/Image/misc.img $IMAGE_PATH/misc.img
-cp -a rkst/Image/pcba_small_misc.img $IMAGE_PATH/pcba_small_misc.img
-cp -a rkst/Image/pcba_whole_misc.img $IMAGE_PATH/pcba_whole_misc.img
-echo "done."
-
-if [ -f $UBOOT_PATH/uboot.img ]
-then
-	echo -n "create uboot.img..."
-	cp -a $UBOOT_PATH/uboot.img $IMAGE_PATH/uboot.img
-	echo "done."
-else
-	echo "$UBOOT_PATH/uboot.img not fount! Please make it from $UBOOT_PATH first!"
-fi
-
-echo "make oem images... "
-cp device/rockchip/rk3399/oem.img $IMAGE_PATH/oem.img
-
-
-if [ -f $UBOOT_PATH/trust_nand.img ]
-then
-        echo -n "create trust.img..."
-        cp -a $UBOOT_PATH/trust_nand.img $IMAGE_PATH/trust.img
-        echo "done."
-elif [ -f $UBOOT_PATH/trust_with_ta.img ]
-then
-        echo -n "create trust.img..."
-        cp -a $UBOOT_PATH/trust_with_ta.img $IMAGE_PATH/trust.img
-        echo "done."
-elif [ -f $UBOOT_PATH/trust.img ]
-then
-        echo -n "create trust.img..."
-        cp -a $UBOOT_PATH/trust.img $IMAGE_PATH/trust.img
-        echo "done."
-
-else    
-        echo "$UBOOT_PATH/trust.img not fount! Please make it from $UBOOT_PATH first!"
-fi
-
-if [ "$HIGH_RELIABLE_RECOVERY_OTA" = "true" ]; then
-	if [ -f $UBOOT_PATH/uboot_ro.img ]
-	then
-		echo -n "HIGH_RELIABLE_RECOVERY_OTA is true. create uboot_ro.img..."
-		cp -a $UBOOT_PATH/uboot_ro.img $IMAGE_PATH/uboot_ro.img
-		cp -a $IMAGE_PATH/trust.img $IMAGE_PATH/trust_ro.img
-		echo "done."
-	else
-		echo "$UBOOT_PATH/uboot_ro.img not fount! Please make it from $UBOOT_PATH first!"
-	fi
-fi
-
-if [ -f $UBOOT_PATH/*_loader_*.bin ]
-then
-        echo -n "create loader..."
-        cp -a $UBOOT_PATH/*_loader_*.bin $IMAGE_PATH/MiniLoaderAll.bin
-        echo "done."
-else
-	if [ -f $UBOOT_PATH/*loader*.bin ]; then
-		echo -n "create loader..."
-		cp -a $UBOOT_PATH/*loader*.bin $IMAGE_PATH/MiniLoaderAll.bin
-		echo "done."
-	elif [ "$TARGET_PRODUCT" == "px3" -a -f $UBOOT_PATH/RKPX3Loader_miniall.bin ]; then
-        echo -n "create loader..."
-        cp -a $UBOOT_PATH/RKPX3Loader_miniall.bin $IMAGE_PATH/MiniLoaderAll.bin
-        echo "done."
-	else
-        echo "$UBOOT_PATH/*MiniLoaderAll_*.bin not fount! Please make it from $UBOOT_PATH first!"
-	fi
-fi
-
-if [ -f $KERNEL_PATH/resource.img ]
-then
-        echo -n "create resource.img..."
-        cp -a $KERNEL_PATH/resource.img $IMAGE_PATH/resource.img
-        echo "done."
-else
-        echo "$KERNEL_PATH/resource.img not fount!"
-fi
-
-if [ -f $KERNEL_PATH/kernel.img ]
-then
-        echo -n "create kernel.img..."
-        cp -a $KERNEL_PATH/kernel.img $IMAGE_PATH/kernel.img
-        echo "done."
-else
-        echo "$KERNEL_PATH/kernel.img not fount!"
-fi
-
-if [ -f $FLASH_CONFIG_FILE ]
-then
-    echo -n "create config.cfg..."
-    cp -a $FLASH_CONFIG_FILE $IMAGE_PATH/config.cfg
-    echo "done."
-else
-    echo "$FLASH_CONFIG_FILE not fount!"
-fi
-
-if [ -f $PARAMETER ]
-then
-				if [ "$HIGH_RELIABLE_RECOVERY_OTA" = "true" ]; then
-	        echo -n "create parameter...HIGH_RELIABLE_RECOVERY_OTA is ture. "
-	        echo -n "create parameter from hrr..."
-	        if [ -f $PARAMETER ]; then
-						cp -a ${TARGET_DEVICE_DIR}/parameter_hrr.txt $IMAGE_PATH/parameter.txt
-						echo "done."
-	        else
-						echo "${TARGET_DEVICE_DIR}/parameter_hrr.txt not fount! Please make it from ${TARGET_DEVICE_DIR} first!"
-	        fi
-	      else
-					echo -n "create parameter..."
-	        cp -a $PARAMETER $IMAGE_PATH/parameter.txt
-	        echo "done."
-	      fi
-else
-        echo "$PARAMETER not fount!"
-fi
-
-if [ "$TARGET_BASE_PARAMETER_IMAGE"x != ""x ]
-then
-    if [ -f $TARGET_BASE_PARAMETER_IMAGE ]
-    then
-        echo -n "create baseparameter..."
-        cp -a $TARGET_BASE_PARAMETER_IMAGE $IMAGE_PATH/baseparameter.img
-        echo "done."
-    else
-        echo "$TARGET_BASE_PARAMETER_IMAGE not fount!"
-    fi
-fi
-
-if [ $TARGET == $BOOT_OTA ]
-then
-if [ "$PRODUCT_USE_DYNAMIC_PARTITIONS" = "true" ]; then
-    echo "Generate mass production super.img firmware that matches OTA ... "
-    make dist -j32
-    echo "re-generate super.img for mass production done "
-    cp -rf  $OUT/obj/PACKAGING/super.img_intermediates/super.img  $IMAGE_PATH/
-fi
-echo -n "create system.img boot.img oem.img vendor.img dtbo.img vbmeta.img for OTA..."
-cp -rf  $OUT/obj/PACKAGING/target_files_intermediates/*-target_files*/IMAGES/*.img  $IMAGE_PATH/
-rm -rf  $IMAGE_PATH/cache.img
-rm -rf  $IMAGE_PATH/recovery-two-step.img
-if [ "$PRODUCT_USE_DYNAMIC_PARTITIONS" = "true" ]; then
-    rm -rf  $IMAGE_PATH/super_empty.img
-fi
-echo "done."
-fi
-
-chmod a+r -R $IMAGE_PATH/
+version https://git-lfs.github.com/spec/v1
+oid sha256:c4dd7722d82a8128728bb387c20fe057055006f16e0106fdb03aabb66c67eb19
+size 10747
diff --git a/u-boot/configs/rk3399_defconfig b/u-boot/configs/rk3399_defconfig
index 75760e07e6..14fdd9f35d 100644
--- a/u-boot/configs/rk3399_defconfig
+++ b/u-boot/configs/rk3399_defconfig
@@ -1,147 +1,3 @@
-CONFIG_ARM=y
-CONFIG_ARCH_ROCKCHIP=y
-CONFIG_SPL_LIBCOMMON_SUPPORT=y
-CONFIG_SPL_LIBGENERIC_SUPPORT=y
-CONFIG_SYS_MALLOC_F_LEN=0x10000
-CONFIG_SPL_FIT_GENERATOR="arch/arm/mach-rockchip/make_fit_atf.py"
-CONFIG_ROCKCHIP_RK3399=y
-CONFIG_ROCKCHIP_VENDOR_PARTITION=y
-CONFIG_UBOOT_SIZE_KB=2048
-CONFIG_UBOOT_NUM=2
-CONFIG_DEFAULT_DEVICE_TREE="rk3399-evb"
-CONFIG_DEBUG_UART=y
-CONFIG_FIT=y
-CONFIG_SPL_LOAD_FIT=y
-# CONFIG_SPL_SYS_DCACHE_OFF is not set
-CONFIG_BOOTDELAY=0
-CONFIG_OPTEE_ALWAYS_USE_SECURITY_PARTITION=y
-CONFIG_SYS_CONSOLE_INFO_QUIET=y
-# CONFIG_DISPLAY_CPUINFO is not set
-CONFIG_ANDROID_BOOTLOADER=y
-CONFIG_ANDROID_AVB=y
-# CONFIG_SPL_RAW_IMAGE_SUPPORT is not set
-# CONFIG_SPL_LEGACY_IMAGE_SUPPORT is not set
-CONFIG_SPL_STACK_R=y
-CONFIG_SPL_STACK_R_MALLOC_SIMPLE_LEN=0x10000
-CONFIG_SPL_SHA256_SUPPORT=y
-CONFIG_SPL_CRYPTO_SUPPORT=y
-CONFIG_SPL_HASH_SUPPORT=y
-CONFIG_SPL_ATF=y
-CONFIG_SPL_ATF_NO_PLATFORM_PARAM=y
-CONFIG_FASTBOOT_BUF_ADDR=0x00800800
-CONFIG_FASTBOOT_BUF_SIZE=0x04000000
-CONFIG_FASTBOOT_FLASH=y
-CONFIG_FASTBOOT_FLASH_MMC_DEV=0
-CONFIG_CMD_BOOTZ=y
-# CONFIG_CMD_BOOTEFI_HELLO_COMPILE is not set
-CONFIG_CMD_DTIMG=y
-# CONFIG_CMD_ELF is not set
-# CONFIG_CMD_IMI is not set
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_XIMG is not set
-# CONFIG_CMD_LZMADEC is not set
-# CONFIG_CMD_UNZIP is not set
-# CONFIG_CMD_FLASH is not set
-# CONFIG_CMD_FPGA is not set
-CONFIG_CMD_GPT=y
-# CONFIG_CMD_LOADB is not set
-# CONFIG_CMD_LOADS is not set
-CONFIG_CMD_BOOT_ANDROID=y
-CONFIG_CMD_BOOT_ROCKCHIP=y
-CONFIG_CMD_MMC=y
-CONFIG_CMD_USB=y
-CONFIG_CMD_USB_MASS_STORAGE=y
-# CONFIG_CMD_ITEST is not set
-# CONFIG_CMD_SETEXPR is not set
-# CONFIG_CMD_MISC is not set
-# CONFIG_SPL_DOS_PARTITION is not set
-# CONFIG_ISO_PARTITION is not set
-CONFIG_EFI_PARTITION_ENTRIES_NUMBERS=64
-CONFIG_RKPARM_PARTITION=y
-CONFIG_SPL_OF_CONTROL=y
-CONFIG_OF_LIVE=y
-CONFIG_OF_SPL_REMOVE_PROPS="pinctrl-0 pinctrl-names clock-names interrupt-parent assigned-clocks assigned-clock-rates assigned-clock-parents"
-# CONFIG_NET_TFTP_VARS is not set
-CONFIG_REGMAP=y
-CONFIG_SPL_REGMAP=y
-CONFIG_SYSCON=y
-CONFIG_SPL_SYSCON=y
-CONFIG_CLK=y
-CONFIG_SPL_CLK=y
-CONFIG_DM_CRYPTO=y
-CONFIG_ROCKCHIP_CRYPTO_V1=y
-CONFIG_ROCKCHIP_GPIO=y
-CONFIG_SYS_I2C_ROCKCHIP=y
-CONFIG_DM_KEY=y
-CONFIG_ADC_KEY=y
-CONFIG_GPIO_KEY=y
-CONFIG_RK_KEY=y
-CONFIG_MISC=y
-CONFIG_ROCKCHIP_EFUSE=y
-CONFIG_MMC_DW=y
-CONFIG_MMC_DW_ROCKCHIP=y
-CONFIG_MMC_SDHCI=y
-CONFIG_MMC_SDHCI_ROCKCHIP=y
-CONFIG_SF_DEFAULT_SPEED=20000000
-CONFIG_DM_ETH=y
-CONFIG_ETH_DESIGNWARE=y
-CONFIG_GMAC_ROCKCHIP=y
-CONFIG_PHY_ROCKCHIP_INNO_USB2=y
-CONFIG_PHY_ROCKCHIP_TYPEC=y
-CONFIG_PINCTRL=y
-CONFIG_SPL_PINCTRL=y
-CONFIG_DM_FUEL_GAUGE=y
-CONFIG_POWER_FG_RK817=y
-CONFIG_POWER_FG_RK818=y
-CONFIG_DM_PMIC=y
-CONFIG_PMIC_RK8XX=y
-CONFIG_REGULATOR_PWM=y
-CONFIG_DM_REGULATOR_FIXED=y
-CONFIG_REGULATOR_RK8XX=y
-CONFIG_DM_CHARGE_DISPLAY=y
-CONFIG_CHARGE_ANIMATION=y
-CONFIG_PWM_ROCKCHIP=y
-CONFIG_RAM=y
-CONFIG_SPL_RAM=y
-CONFIG_ROCKCHIP_SDRAM_COMMON=y
-CONFIG_DM_RESET=y
-CONFIG_BAUDRATE=1500000
-CONFIG_DEBUG_UART_BASE=0xFF1A0000
-CONFIG_DEBUG_UART_CLOCK=24000000
-CONFIG_DEBUG_UART_SHIFT=2
-CONFIG_SYSRESET=y
-CONFIG_USB=y
-CONFIG_USB_XHCI_HCD=y
-CONFIG_USB_XHCI_DWC3=y
-CONFIG_USB_EHCI_HCD=y
-CONFIG_USB_EHCI_GENERIC=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_OHCI_GENERIC=y
-CONFIG_USB_DWC3=y
-CONFIG_USB_DWC3_GADGET=y
-CONFIG_USB_DWC3_GENERIC=y
-CONFIG_USB_STORAGE=y
-CONFIG_USB_GADGET=y
-CONFIG_USB_GADGET_MANUFACTURER="Rockchip"
-CONFIG_USB_GADGET_VENDOR_NUM=0x2207
-CONFIG_USB_GADGET_PRODUCT_NUM=0x330a
-CONFIG_USB_GADGET_DOWNLOAD=y
-CONFIG_DM_VIDEO=y
-CONFIG_DISPLAY=y
-CONFIG_DRM_ROCKCHIP=y
-CONFIG_DRM_ROCKCHIP_DW_HDMI=y
-CONFIG_DRM_ROCKCHIP_DW_MIPI_DSI=y
-CONFIG_DRM_ROCKCHIP_ANALOGIX_DP=y
-CONFIG_LCD=y
-CONFIG_USE_TINY_PRINTF=y
-CONFIG_LIB_RAND=y
-CONFIG_SPL_TINY_MEMSET=y
-CONFIG_ERRNO_STR=y
-CONFIG_AVB_LIBAVB=y
-CONFIG_AVB_LIBAVB_AB=y
-CONFIG_AVB_LIBAVB_ATX=y
-CONFIG_AVB_LIBAVB_USER=y
-CONFIG_RK_AVB_LIBAVB_USER=y
-CONFIG_OPTEE_CLIENT=y
-CONFIG_OPTEE_V1=y
-CONFIG_TEST_ROCKCHIP=y
+version https://git-lfs.github.com/spec/v1
+oid sha256:0764cf57a7a497bc325a02bb16adfa055852a49361d52b08fcc91f8b187d438c
+size 4094
diff --git a/u-boot/configs/rk3399pro_defconfig b/u-boot/configs/rk3399pro_defconfig
index 5af187c333..317d38eef4 100644
--- a/u-boot/configs/rk3399pro_defconfig
+++ b/u-boot/configs/rk3399pro_defconfig
@@ -1,147 +1,3 @@
-CONFIG_ARM=y
-CONFIG_ARCH_ROCKCHIP=y
-CONFIG_SPL_LIBCOMMON_SUPPORT=y
-CONFIG_SPL_LIBGENERIC_SUPPORT=y
-CONFIG_SYS_MALLOC_F_LEN=0x4000
-CONFIG_SPL_FIT_GENERATOR="arch/arm/mach-rockchip/make_fit_atf.py"
-CONFIG_ROCKCHIP_RK3399=y
-CONFIG_ROCKCHIP_RK3399PRO=y
-CONFIG_ROCKCHIP_VENDOR_PARTITION=y
-CONFIG_CHIP_NAME="RK3399PRO"
-CONFIG_UBOOT_SIZE_KB=2048
-CONFIG_UBOOT_NUM=2
-CONFIG_DEFAULT_DEVICE_TREE="rk3399-evb"
-CONFIG_DEBUG_UART=y
-CONFIG_FIT=y
-CONFIG_SPL_LOAD_FIT=y
-CONFIG_BOOTDELAY=0
-CONFIG_SYS_CONSOLE_INFO_QUIET=y
-# CONFIG_DISPLAY_CPUINFO is not set
-CONFIG_ANDROID_BOOTLOADER=y
-CONFIG_ANDROID_AVB=y
-CONFIG_SPL_STACK_R=y
-CONFIG_SPL_STACK_R_MALLOC_SIMPLE_LEN=0x10000
-CONFIG_SPL_ATF=y
-CONFIG_SPL_ATF_NO_PLATFORM_PARAM=y
-CONFIG_FASTBOOT_BUF_ADDR=0x00800800
-CONFIG_FASTBOOT_BUF_SIZE=0x04000000
-CONFIG_FASTBOOT_FLASH=y
-CONFIG_FASTBOOT_FLASH_MMC_DEV=0
-CONFIG_CMD_BOOTZ=y
-CONFIG_CMD_DTIMG=y
-# CONFIG_CMD_ELF is not set
-# CONFIG_CMD_IMI is not set
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_XIMG is not set
-# CONFIG_CMD_LZMADEC is not set
-# CONFIG_CMD_UNZIP is not set
-# CONFIG_CMD_FLASH is not set
-# CONFIG_CMD_FPGA is not set
-CONFIG_CMD_GPT=y
-# CONFIG_CMD_LOADB is not set
-# CONFIG_CMD_LOADS is not set
-CONFIG_CMD_BOOT_ANDROID=y
-CONFIG_CMD_BOOT_ROCKCHIP=y
-CONFIG_CMD_MMC=y
-CONFIG_CMD_SF=y
-CONFIG_CMD_USB=y
-CONFIG_CMD_USB_MASS_STORAGE=y
-# CONFIG_CMD_ITEST is not set
-# CONFIG_CMD_SETEXPR is not set
-# CONFIG_CMD_MISC is not set
-# CONFIG_SPL_DOS_PARTITION is not set
-# CONFIG_ISO_PARTITION is not set
-CONFIG_EFI_PARTITION_ENTRIES_NUMBERS=64
-CONFIG_RKPARM_PARTITION=y
-CONFIG_SPL_OF_CONTROL=y
-CONFIG_OF_LIVE=y
-CONFIG_OF_SPL_REMOVE_PROPS="pinctrl-0 pinctrl-names clock-names interrupt-parent assigned-clocks assigned-clock-rates assigned-clock-parents"
-CONFIG_NET_RANDOM_ETHADDR=y
-CONFIG_REGMAP=y
-CONFIG_SPL_REGMAP=y
-CONFIG_SYSCON=y
-CONFIG_SPL_SYSCON=y
-CONFIG_CLK=y
-CONFIG_SPL_CLK=y
-CONFIG_DM_CRYPTO=y
-CONFIG_ROCKCHIP_CRYPTO_V1=y
-CONFIG_ROCKCHIP_GPIO=y
-CONFIG_SYS_I2C_ROCKCHIP=y
-CONFIG_DM_KEY=y
-CONFIG_ADC_KEY=y
-CONFIG_GPIO_KEY=y
-CONFIG_RK_KEY=y
-CONFIG_MISC=y
-CONFIG_ROCKCHIP_EFUSE=y
-CONFIG_MMC_DW=y
-CONFIG_MMC_DW_ROCKCHIP=y
-CONFIG_MMC_SDHCI=y
-CONFIG_MMC_SDHCI_ROCKCHIP=y
-CONFIG_DM_ETH=y
-CONFIG_ETH_DESIGNWARE=y
-CONFIG_GMAC_ROCKCHIP=y
-CONFIG_PHY_ROCKCHIP_INNO_USB2=y
-CONFIG_PINCTRL=y
-CONFIG_SPL_PINCTRL=y
-CONFIG_DM_FUEL_GAUGE=y
-CONFIG_POWER_FG_RK817=y
-CONFIG_IO_DOMAIN=y
-CONFIG_ROCKCHIP_IO_DOMAIN=y
-CONFIG_DM_PMIC=y
-CONFIG_PMIC_RK8XX=y
-CONFIG_REGULATOR_PWM=y
-CONFIG_DM_REGULATOR_FIXED=y
-CONFIG_REGULATOR_RK8XX=y
-CONFIG_CHARGER_BQ25700=y
-CONFIG_DM_CHARGE_DISPLAY=y
-CONFIG_CHARGE_ANIMATION=y
-CONFIG_PWM_ROCKCHIP=y
-CONFIG_RAM=y
-CONFIG_SPL_RAM=y
-CONFIG_ROCKCHIP_SDRAM_COMMON=y
-CONFIG_DM_RESET=y
-CONFIG_BAUDRATE=1500000
-CONFIG_DEBUG_UART_BASE=0xFF1A0000
-CONFIG_DEBUG_UART_CLOCK=24000000
-CONFIG_DEBUG_UART_SHIFT=2
-CONFIG_SYSRESET=y
-CONFIG_USB=y
-CONFIG_USB_XHCI_HCD=y
-CONFIG_USB_XHCI_DWC3=y
-CONFIG_USB_EHCI_HCD=y
-CONFIG_USB_EHCI_GENERIC=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_OHCI_GENERIC=y
-CONFIG_USB_DWC3=y
-CONFIG_USB_DWC3_GADGET=y
-CONFIG_USB_STORAGE=y
-CONFIG_USB_GADGET=y
-CONFIG_USB_GADGET_MANUFACTURER="Rockchip"
-CONFIG_USB_GADGET_VENDOR_NUM=0x2207
-CONFIG_USB_GADGET_PRODUCT_NUM=0x330a
-CONFIG_USB_GADGET_DOWNLOAD=y
-CONFIG_USB_HOST_ETHER=y
-CONFIG_USB_ETHER_ASIX=y
-CONFIG_USB_ETHER_ASIX88179=y
-CONFIG_USB_ETHER_MCS7830=y
-CONFIG_USB_ETHER_RTL8152=y
-CONFIG_USB_ETHER_SMSC95XX=y
-CONFIG_DM_VIDEO=y
-CONFIG_DISPLAY=y
-CONFIG_DRM_ROCKCHIP=y
-CONFIG_DRM_ROCKCHIP_DW_HDMI=y
-CONFIG_DRM_ROCKCHIP_DW_MIPI_DSI=y
-CONFIG_DRM_ROCKCHIP_ANALOGIX_DP=y
-CONFIG_LCD=y
-CONFIG_USE_TINY_PRINTF=y
-CONFIG_SPL_TINY_MEMSET=y
-CONFIG_ERRNO_STR=y
-# CONFIG_EFI_LOADER is not set
-CONFIG_AVB_LIBAVB=y
-CONFIG_AVB_LIBAVB_AB=y
-CONFIG_AVB_LIBAVB_ATX=y
-CONFIG_AVB_LIBAVB_USER=y
-CONFIG_RK_AVB_LIBAVB_USER=y
-CONFIG_OPTEE_CLIENT=y
-CONFIG_OPTEE_V1=y
-CONFIG_TEST_ROCKCHIP=y
+version https://git-lfs.github.com/spec/v1
+oid sha256:ac437d44a0044b2d7684a8157dde8f54a29db02d7f1514452a8a74e28e571a5c
+size 3795
diff --git a/u-boot/drivers/video/drm/dw_hdmi.c b/u-boot/drivers/video/drm/dw_hdmi.c
index 667a5c1773..9f4a4d9af3 100644
--- a/u-boot/drivers/video/drm/dw_hdmi.c
+++ b/u-boot/drivers/video/drm/dw_hdmi.c
@@ -1,2605 +1,3 @@
-/*
- * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <malloc.h>
-#include <syscon.h>
-#include <asm/arch-rockchip/clock.h>
-#include <asm/arch/vendor.h>
-#include <edid.h>
-#include <dm/device.h>
-#include <dm/of_access.h>
-#include <dm/ofnode.h>
-#include <dm/read.h>
-#include <linux/hdmi.h>
-#include <linux/media-bus-format.h>
-#include <linux/dw_hdmi.h>
-#include <asm/io.h>
-#include "rockchip_display.h"
-#include "rockchip_crtc.h"
-#include "rockchip_connector.h"
-#include "dw_hdmi.h"
-#include "rockchip_phy.h"
-
-#define HDCP_PRIVATE_KEY_SIZE   280
-#define HDCP_KEY_SHA_SIZE       20
-#define HDMI_HDCP1X_ID		5
-/*
- * Unless otherwise noted, entries in this table are 100% optimization.
- * Values can be obtained from hdmi_compute_n() but that function is
- * slow so we pre-compute values we expect to see.
- *
- * All 32k and 48k values are expected to be the same (due to the way
- * the math works) for any rate that's an exact kHz.
- */
-static const struct dw_hdmi_audio_tmds_n common_tmds_n_table[] = {
-	{ .tmds = 25175000, .n_32k = 4096, .n_44k1 = 12854, .n_48k = 6144, },
-	{ .tmds = 25200000, .n_32k = 4096, .n_44k1 = 5656, .n_48k = 6144, },
-	{ .tmds = 27000000, .n_32k = 4096, .n_44k1 = 5488, .n_48k = 6144, },
-	{ .tmds = 28320000, .n_32k = 4096, .n_44k1 = 5586, .n_48k = 6144, },
-	{ .tmds = 30240000, .n_32k = 4096, .n_44k1 = 5642, .n_48k = 6144, },
-	{ .tmds = 31500000, .n_32k = 4096, .n_44k1 = 5600, .n_48k = 6144, },
-	{ .tmds = 32000000, .n_32k = 4096, .n_44k1 = 5733, .n_48k = 6144, },
-	{ .tmds = 33750000, .n_32k = 4096, .n_44k1 = 6272, .n_48k = 6144, },
-	{ .tmds = 36000000, .n_32k = 4096, .n_44k1 = 5684, .n_48k = 6144, },
-	{ .tmds = 40000000, .n_32k = 4096, .n_44k1 = 5733, .n_48k = 6144, },
-	{ .tmds = 49500000, .n_32k = 4096, .n_44k1 = 5488, .n_48k = 6144, },
-	{ .tmds = 50000000, .n_32k = 4096, .n_44k1 = 5292, .n_48k = 6144, },
-	{ .tmds = 54000000, .n_32k = 4096, .n_44k1 = 5684, .n_48k = 6144, },
-	{ .tmds = 65000000, .n_32k = 4096, .n_44k1 = 7056, .n_48k = 6144, },
-	{ .tmds = 68250000, .n_32k = 4096, .n_44k1 = 5376, .n_48k = 6144, },
-	{ .tmds = 71000000, .n_32k = 4096, .n_44k1 = 7056, .n_48k = 6144, },
-	{ .tmds = 72000000, .n_32k = 4096, .n_44k1 = 5635, .n_48k = 6144, },
-	{ .tmds = 73250000, .n_32k = 4096, .n_44k1 = 14112, .n_48k = 6144, },
-	{ .tmds = 74250000, .n_32k = 4096, .n_44k1 = 6272, .n_48k = 6144, },
-	{ .tmds = 75000000, .n_32k = 4096, .n_44k1 = 5880, .n_48k = 6144, },
-	{ .tmds = 78750000, .n_32k = 4096, .n_44k1 = 5600, .n_48k = 6144, },
-	{ .tmds = 78800000, .n_32k = 4096, .n_44k1 = 5292, .n_48k = 6144, },
-	{ .tmds = 79500000, .n_32k = 4096, .n_44k1 = 4704, .n_48k = 6144, },
-	{ .tmds = 83500000, .n_32k = 4096, .n_44k1 = 7056, .n_48k = 6144, },
-	{ .tmds = 85500000, .n_32k = 4096, .n_44k1 = 5488, .n_48k = 6144, },
-	{ .tmds = 88750000, .n_32k = 4096, .n_44k1 = 14112, .n_48k = 6144, },
-	{ .tmds = 97750000, .n_32k = 4096, .n_44k1 = 14112, .n_48k = 6144, },
-	{ .tmds = 101000000, .n_32k = 4096, .n_44k1 = 7056, .n_48k = 6144, },
-	{ .tmds = 106500000, .n_32k = 4096, .n_44k1 = 4704, .n_48k = 6144, },
-	{ .tmds = 108000000, .n_32k = 4096, .n_44k1 = 5684, .n_48k = 6144, },
-	{ .tmds = 115500000, .n_32k = 4096, .n_44k1 = 5712, .n_48k = 6144, },
-	{ .tmds = 119000000, .n_32k = 4096, .n_44k1 = 5544, .n_48k = 6144, },
-	{ .tmds = 135000000, .n_32k = 4096, .n_44k1 = 5488, .n_48k = 6144, },
-	{ .tmds = 146250000, .n_32k = 4096, .n_44k1 = 6272, .n_48k = 6144, },
-	{ .tmds = 148500000, .n_32k = 4096, .n_44k1 = 5488, .n_48k = 6144, },
-	{ .tmds = 154000000, .n_32k = 4096, .n_44k1 = 5544, .n_48k = 6144, },
-	{ .tmds = 162000000, .n_32k = 4096, .n_44k1 = 5684, .n_48k = 6144, },
-
-	/* For 297 MHz+ HDMI spec have some other rule for setting N */
-	{ .tmds = 297000000, .n_32k = 3073, .n_44k1 = 4704, .n_48k = 5120, },
-	{ .tmds = 594000000, .n_32k = 3073, .n_44k1 = 9408, .n_48k = 10240, },
-
-	/* End of table */
-	{ .tmds = 0,         .n_32k = 0,    .n_44k1 = 0,    .n_48k = 0, },
-};
-
-static const u16 csc_coeff_default[3][4] = {
-	{ 0x2000, 0x0000, 0x0000, 0x0000 },
-	{ 0x0000, 0x2000, 0x0000, 0x0000 },
-	{ 0x0000, 0x0000, 0x2000, 0x0000 }
-};
-
-static const u16 csc_coeff_rgb_out_eitu601[3][4] = {
-	{ 0x2000, 0x6926, 0x74fd, 0x010e },
-	{ 0x2000, 0x2cdd, 0x0000, 0x7e9a },
-	{ 0x2000, 0x0000, 0x38b4, 0x7e3b }
-};
-
-static const u16 csc_coeff_rgb_out_eitu709[3][4] = {
-	{ 0x2000, 0x7106, 0x7a02, 0x00a7 },
-	{ 0x2000, 0x3264, 0x0000, 0x7e6d },
-	{ 0x2000, 0x0000, 0x3b61, 0x7e25 }
-};
-
-static const u16 csc_coeff_rgb_in_eitu601[3][4] = {
-	{ 0x2591, 0x1322, 0x074b, 0x0000 },
-	{ 0x6535, 0x2000, 0x7acc, 0x0200 },
-	{ 0x6acd, 0x7534, 0x2000, 0x0200 }
-};
-
-static const u16 csc_coeff_rgb_in_eitu709[3][4] = {
-	{ 0x2dc5, 0x0d9b, 0x049e, 0x0000 },
-	{ 0x62f0, 0x2000, 0x7d11, 0x0200 },
-	{ 0x6756, 0x78ab, 0x2000, 0x0200 }
-};
-
-static const u16 csc_coeff_full_to_limited[3][4] = {
-	{ 0x36f7, 0x0000, 0x0000, 0x0040 },
-	{ 0x0000, 0x36f7, 0x0000, 0x0040 },
-	{ 0x0000, 0x0000, 0x36f7, 0x0040 }
-};
-
-struct hdmi_vmode {
-	bool mdataenablepolarity;
-
-	unsigned int mpixelclock;
-	unsigned int mpixelrepetitioninput;
-	unsigned int mpixelrepetitionoutput;
-	unsigned int mtmdsclock;
-};
-
-struct hdmi_data_info {
-	unsigned int enc_in_bus_format;
-	unsigned int enc_out_bus_format;
-	unsigned int enc_in_encoding;
-	unsigned int enc_out_encoding;
-	unsigned int quant_range;
-	unsigned int pix_repet_factor;
-	struct hdmi_vmode video_mode;
-};
-
-struct dw_hdmi_phy_data {
-	enum dw_hdmi_phy_type type;
-	const char *name;
-	unsigned int gen;
-	bool has_svsret;
-	int (*configure)(struct dw_hdmi *hdmi,
-			 const struct dw_hdmi_plat_data *pdata,
-			 unsigned long mpixelclock);
-};
-
-struct hdcp_keys {
-	u8 KSV[8];
-	u8 devicekey[HDCP_PRIVATE_KEY_SIZE];
-	u8 sha1[HDCP_KEY_SHA_SIZE];
-	u8 seeds[2];
-};
-
-struct dw_hdmi_i2c {
-	u8			slave_reg;
-	bool			is_regaddr;
-	bool			is_segment;
-
-	unsigned int		scl_high_ns;
-	unsigned int		scl_low_ns;
-};
-
-struct dw_hdmi {
-	int id;
-	enum dw_hdmi_devtype dev_type;
-	unsigned int version;
-	struct hdmi_data_info hdmi_data;
-	struct hdmi_edid_data edid_data;
-	const struct dw_hdmi_plat_data *plat_data;
-	struct ddc_adapter adap;
-
-	int vic;
-	int io_width;
-
-	unsigned long bus_format;
-	bool cable_plugin;
-	bool sink_is_hdmi;
-	bool sink_has_audio;
-	void *regs;
-	void *grf;
-	struct dw_hdmi_i2c *i2c;
-
-	struct {
-		const struct dw_hdmi_phy_ops *ops;
-		const char *name;
-		void *data;
-		bool enabled;
-	} phy;
-
-	struct drm_display_mode previous_mode;
-
-	unsigned int sample_rate;
-	unsigned int audio_cts;
-	unsigned int audio_n;
-	bool audio_enable;
-	bool scramble_low_rates;
-
-	void (*write)(struct dw_hdmi *hdmi, u8 val, int offset);
-	u8 (*read)(struct dw_hdmi *hdmi, int offset);
-
-	bool hdcp1x_enable;
-};
-
-static void dw_hdmi_writel(struct dw_hdmi *hdmi, u8 val, int offset)
-{
-	writel(val, hdmi->regs + (offset << 2));
-}
-
-static u8 dw_hdmi_readl(struct dw_hdmi *hdmi, int offset)
-{
-	return readl(hdmi->regs + (offset << 2));
-}
-
-static void dw_hdmi_writeb(struct dw_hdmi *hdmi, u8 val, int offset)
-{
-	writeb(val, hdmi->regs + offset);
-}
-
-static u8 dw_hdmi_readb(struct dw_hdmi *hdmi, int offset)
-{
-	return readb(hdmi->regs + offset);
-}
-
-static inline void hdmi_writeb(struct dw_hdmi *hdmi, u8 val, int offset)
-{
-	hdmi->write(hdmi, val, offset);
-}
-
-static inline u8 hdmi_readb(struct dw_hdmi *hdmi, int offset)
-{
-	return hdmi->read(hdmi, offset);
-}
-
-static void hdmi_modb(struct dw_hdmi *hdmi, u8 data, u8 mask, unsigned reg)
-{
-	u8 val = hdmi_readb(hdmi, reg) & ~mask;
-
-	val |= data & mask;
-	hdmi_writeb(hdmi, val, reg);
-}
-
-static void hdmi_mask_writeb(struct dw_hdmi *hdmi, u8 data, unsigned int reg,
-			     u8 shift, u8 mask)
-{
-	hdmi_modb(hdmi, data << shift, mask, reg);
-}
-
-static bool hdmi_bus_fmt_is_rgb(unsigned int bus_format)
-{
-	switch (bus_format) {
-	case MEDIA_BUS_FMT_RGB888_1X24:
-	case MEDIA_BUS_FMT_RGB101010_1X30:
-	case MEDIA_BUS_FMT_RGB121212_1X36:
-	case MEDIA_BUS_FMT_RGB161616_1X48:
-		return true;
-
-	default:
-		return false;
-	}
-}
-
-static bool hdmi_bus_fmt_is_yuv444(unsigned int bus_format)
-{
-	switch (bus_format) {
-	case MEDIA_BUS_FMT_YUV8_1X24:
-	case MEDIA_BUS_FMT_YUV10_1X30:
-	case MEDIA_BUS_FMT_YUV12_1X36:
-	case MEDIA_BUS_FMT_YUV16_1X48:
-		return true;
-
-	default:
-		return false;
-	}
-}
-
-static bool hdmi_bus_fmt_is_yuv422(unsigned int bus_format)
-{
-	switch (bus_format) {
-	case MEDIA_BUS_FMT_UYVY8_1X16:
-	case MEDIA_BUS_FMT_UYVY10_1X20:
-	case MEDIA_BUS_FMT_UYVY12_1X24:
-		return true;
-
-	default:
-		return false;
-	}
-}
-
-static bool hdmi_bus_fmt_is_yuv420(unsigned int bus_format)
-{
-	switch (bus_format) {
-	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
-	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
-	case MEDIA_BUS_FMT_UYYVYY12_0_5X36:
-	case MEDIA_BUS_FMT_UYYVYY16_0_5X48:
-		return true;
-
-	default:
-		return false;
-	}
-}
-
-static int hdmi_bus_fmt_color_depth(unsigned int bus_format)
-{
-	switch (bus_format) {
-	case MEDIA_BUS_FMT_RGB888_1X24:
-	case MEDIA_BUS_FMT_YUV8_1X24:
-	case MEDIA_BUS_FMT_UYVY8_1X16:
-	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
-		return 8;
-
-	case MEDIA_BUS_FMT_RGB101010_1X30:
-	case MEDIA_BUS_FMT_YUV10_1X30:
-	case MEDIA_BUS_FMT_UYVY10_1X20:
-	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
-		return 10;
-
-	case MEDIA_BUS_FMT_RGB121212_1X36:
-	case MEDIA_BUS_FMT_YUV12_1X36:
-	case MEDIA_BUS_FMT_UYVY12_1X24:
-	case MEDIA_BUS_FMT_UYYVYY12_0_5X36:
-		return 12;
-
-	case MEDIA_BUS_FMT_RGB161616_1X48:
-	case MEDIA_BUS_FMT_YUV16_1X48:
-	case MEDIA_BUS_FMT_UYYVYY16_0_5X48:
-		return 16;
-
-	default:
-		return 0;
-	}
-}
-
-static int is_color_space_conversion(struct dw_hdmi *hdmi)
-{
-	struct drm_display_mode *mode =
-		hdmi->edid_data.preferred_mode;
-	bool is_cea_default;
-
-	is_cea_default = (drm_match_cea_mode(mode) > 1) &&
-			 (hdmi->hdmi_data.quant_range ==
-			  HDMI_QUANTIZATION_RANGE_DEFAULT);
-
-	/*
-	 * When output is rgb limited range or default range with
-	 * cea mode, csc should be enabled.
-	 */
-	if (hdmi->hdmi_data.enc_in_bus_format !=
-	    hdmi->hdmi_data.enc_out_bus_format ||
-	    ((hdmi->hdmi_data.quant_range == HDMI_QUANTIZATION_RANGE_LIMITED ||
-	      is_cea_default) &&
-	     hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_in_bus_format)))
-		return 1;
-
-	return 0;
-}
-
-static int is_color_space_decimation(struct dw_hdmi *hdmi)
-{
-	if (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format))
-		return 0;
-
-	if (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_in_bus_format) ||
-	    hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_in_bus_format))
-		return 1;
-
-	return 0;
-}
-
-static inline void hdmi_phy_test_clear(struct dw_hdmi *hdmi,
-				       unsigned char bit)
-{
-	hdmi_modb(hdmi, bit << HDMI_PHY_TST0_TSTCLR_OFFSET,
-		  HDMI_PHY_TST0_TSTCLR_MASK, HDMI_PHY_TST0);
-}
-
-static inline void hdmi_phy_test_enable(struct dw_hdmi *hdmi,
-					unsigned char bit)
-{
-	hdmi_modb(hdmi, bit << HDMI_PHY_TST0_TSTEN_OFFSET,
-		  HDMI_PHY_TST0_TSTEN_MASK, HDMI_PHY_TST0);
-}
-
-static inline void hdmi_phy_test_clock(struct dw_hdmi *hdmi,
-				       unsigned char bit)
-{
-	hdmi_modb(hdmi, bit << HDMI_PHY_TST0_TSTCLK_OFFSET,
-		  HDMI_PHY_TST0_TSTCLK_MASK, HDMI_PHY_TST0);
-}
-
-static inline void hdmi_phy_test_din(struct dw_hdmi *hdmi,
-				     unsigned char bit)
-{
-	hdmi_writeb(hdmi, bit, HDMI_PHY_TST1);
-}
-
-static inline void hdmi_phy_test_dout(struct dw_hdmi *hdmi,
-				      unsigned char bit)
-{
-	hdmi_writeb(hdmi, bit, HDMI_PHY_TST2);
-}
-
-static int dw_hdmi_i2c_read(struct dw_hdmi *hdmi,
-			    unsigned char *buf, unsigned int length)
-{
-	struct dw_hdmi_i2c *i2c = hdmi->i2c;
-	int interrupt = 0, i = 20;
-
-	if (!i2c->is_regaddr) {
-		printf("set read register address to 0\n");
-		i2c->slave_reg = 0x00;
-		i2c->is_regaddr = true;
-	}
-
-	while (length--) {
-		hdmi_writeb(hdmi, i2c->slave_reg++, HDMI_I2CM_ADDRESS);
-		if (i2c->is_segment)
-			hdmi_writeb(hdmi, HDMI_I2CM_OPERATION_READ_EXT,
-				    HDMI_I2CM_OPERATION);
-		else
-			hdmi_writeb(hdmi, HDMI_I2CM_OPERATION_READ,
-				    HDMI_I2CM_OPERATION);
-
-		while (i--) {
-			udelay(1000);
-			interrupt = hdmi_readb(hdmi, HDMI_IH_I2CM_STAT0);
-			if (interrupt)
-				hdmi_writeb(hdmi, interrupt,
-					    HDMI_IH_I2CM_STAT0);
-			if (interrupt & (m_SCDC_READREQ | m_I2CM_DONE |
-					 m_I2CM_ERROR))
-				break;
-		}
-
-		if (!interrupt) {
-			printf("[%s] i2c read reg[0x%02x] no interrupt\n",
-			       __func__, i2c->slave_reg);
-			return -EAGAIN;
-		}
-
-		/* Check for error condition on the bus */
-		if (interrupt & HDMI_IH_I2CM_STAT0_ERROR) {
-			printf("[%s] read reg[0x%02x] data error:0x%02x\n",
-			       __func__, i2c->slave_reg, interrupt);
-			return -EIO;
-		}
-
-		i = 20;
-		*buf++ = hdmi_readb(hdmi, HDMI_I2CM_DATAI);
-	}
-	i2c->is_segment = false;
-
-	return 0;
-}
-
-static int dw_hdmi_i2c_write(struct dw_hdmi *hdmi,
-			     unsigned char *buf, unsigned int length)
-{
-	struct dw_hdmi_i2c *i2c = hdmi->i2c;
-	int i = 20;
-	u8 interrupt = 0;
-
-	if (!i2c->is_regaddr) {
-		/* Use the first write byte as register address */
-		i2c->slave_reg = buf[0];
-		length--;
-		buf++;
-		i2c->is_regaddr = true;
-	}
-
-	while (length--) {
-		hdmi_writeb(hdmi, *buf++, HDMI_I2CM_DATAO);
-		hdmi_writeb(hdmi, i2c->slave_reg++, HDMI_I2CM_ADDRESS);
-		hdmi_writeb(hdmi, HDMI_I2CM_OPERATION_WRITE,
-			    HDMI_I2CM_OPERATION);
-
-		while (i--) {
-			udelay(1000);
-			interrupt = hdmi_readb(hdmi, HDMI_IH_I2CM_STAT0);
-			if (interrupt)
-				hdmi_writeb(hdmi,
-					    interrupt, HDMI_IH_I2CM_STAT0);
-
-			if (interrupt & (m_SCDC_READREQ |
-					 m_I2CM_DONE | m_I2CM_ERROR))
-				break;
-		}
-
-		if ((interrupt & m_I2CM_ERROR) || (i == -1)) {
-			printf("[%s] write data error\n", __func__);
-			return -EIO;
-		} else if (interrupt & m_I2CM_DONE) {
-			printf("[%s] write offset %02x success\n",
-			       __func__, i2c->slave_reg);
-			return -EAGAIN;
-		}
-
-		i = 20;
-	}
-
-	return 0;
-}
-
-static int dw_hdmi_i2c_xfer(struct ddc_adapter *adap,
-			    struct i2c_msg *msgs, int num)
-{
-	struct dw_hdmi *hdmi = container_of(adap, struct dw_hdmi, adap);
-	struct dw_hdmi_i2c *i2c = hdmi->i2c;
-	u8 addr = msgs[0].addr;
-	int i, ret = 0;
-
-	printf("xfer: num: %d, addr: %#x\n", num, addr);
-	for (i = 0; i < num; i++) {
-		if (msgs[i].len == 0) {
-			printf("unsupported transfer %d/%d, no data\n",
-			       i + 1, num);
-			return -EOPNOTSUPP;
-		}
-	}
-
-	hdmi_writeb(hdmi, 0x00, HDMI_IH_MUTE_I2CM_STAT0);
-
-	/* Set slave device address taken from the first I2C message */
-	if (addr == DDC_SEGMENT_ADDR && msgs[0].len == 1)
-		addr = DDC_ADDR;
-	hdmi_writeb(hdmi, addr, HDMI_I2CM_SLAVE);
-
-	/* Set slave device register address on transfer */
-	i2c->is_regaddr = false;
-
-	/* Set segment pointer for I2C extended read mode operation */
-	i2c->is_segment = false;
-
-	for (i = 0; i < num; i++) {
-		debug("xfer: num: %d/%d, len: %d, flags: %#x\n",
-		      i + 1, num, msgs[i].len, msgs[i].flags);
-		if (msgs[i].addr == DDC_SEGMENT_ADDR && msgs[i].len == 1) {
-			i2c->is_segment = true;
-			hdmi_writeb(hdmi, DDC_SEGMENT_ADDR, HDMI_I2CM_SEGADDR);
-			hdmi_writeb(hdmi, *msgs[i].buf, HDMI_I2CM_SEGPTR);
-		} else {
-			if (msgs[i].flags & I2C_M_RD)
-				ret = dw_hdmi_i2c_read(hdmi, msgs[i].buf,
-						       msgs[i].len);
-			else
-				ret = dw_hdmi_i2c_write(hdmi, msgs[i].buf,
-							msgs[i].len);
-		}
-		if (ret < 0)
-			break;
-	}
-
-	if (!ret)
-		ret = num;
-
-	/* Mute DONE and ERROR interrupts */
-	hdmi_writeb(hdmi, HDMI_IH_I2CM_STAT0_ERROR | HDMI_IH_I2CM_STAT0_DONE,
-		    HDMI_IH_MUTE_I2CM_STAT0);
-
-	return ret;
-}
-
-static bool hdmi_phy_wait_i2c_done(struct dw_hdmi *hdmi, int msec)
-{
-	u32 val;
-
-	while ((val = hdmi_readb(hdmi, HDMI_IH_I2CMPHY_STAT0) & 0x3) == 0) {
-		if (msec-- == 0)
-			return false;
-		udelay(1000);
-	}
-	hdmi_writeb(hdmi, val, HDMI_IH_I2CMPHY_STAT0);
-
-	return true;
-}
-
-static void dw_hdmi_phy_i2c_write(struct dw_hdmi *hdmi, unsigned short data,
-				  unsigned char addr)
-{
-	hdmi_writeb(hdmi, 0xFF, HDMI_IH_I2CMPHY_STAT0);
-	hdmi_writeb(hdmi, addr, HDMI_PHY_I2CM_ADDRESS_ADDR);
-	hdmi_writeb(hdmi, (unsigned char)(data >> 8),
-		    HDMI_PHY_I2CM_DATAO_1_ADDR);
-	hdmi_writeb(hdmi, (unsigned char)(data >> 0),
-		    HDMI_PHY_I2CM_DATAO_0_ADDR);
-	hdmi_writeb(hdmi, HDMI_PHY_I2CM_OPERATION_ADDR_WRITE,
-		    HDMI_PHY_I2CM_OPERATION_ADDR);
-	hdmi_phy_wait_i2c_done(hdmi, 1000);
-}
-
-static void dw_hdmi_phy_enable_powerdown(struct dw_hdmi *hdmi, bool enable)
-{
-	hdmi_mask_writeb(hdmi, !enable, HDMI_PHY_CONF0,
-			 HDMI_PHY_CONF0_PDZ_OFFSET,
-			 HDMI_PHY_CONF0_PDZ_MASK);
-}
-
-static void dw_hdmi_phy_enable_tmds(struct dw_hdmi *hdmi, u8 enable)
-{
-	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
-			 HDMI_PHY_CONF0_ENTMDS_OFFSET,
-			 HDMI_PHY_CONF0_ENTMDS_MASK);
-}
-
-static void dw_hdmi_phy_enable_svsret(struct dw_hdmi *hdmi, u8 enable)
-{
-	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
-			 HDMI_PHY_CONF0_SVSRET_OFFSET,
-			 HDMI_PHY_CONF0_SVSRET_MASK);
-}
-
-static void dw_hdmi_phy_gen2_pddq(struct dw_hdmi *hdmi, u8 enable)
-{
-	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
-			 HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET,
-			 HDMI_PHY_CONF0_GEN2_PDDQ_MASK);
-}
-
-static void dw_hdmi_phy_gen2_txpwron(struct dw_hdmi *hdmi, u8 enable)
-{
-	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
-			 HDMI_PHY_CONF0_GEN2_TXPWRON_OFFSET,
-			 HDMI_PHY_CONF0_GEN2_TXPWRON_MASK);
-}
-
-static void dw_hdmi_phy_sel_data_en_pol(struct dw_hdmi *hdmi, u8 enable)
-{
-	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
-			 HDMI_PHY_CONF0_SELDATAENPOL_OFFSET,
-			 HDMI_PHY_CONF0_SELDATAENPOL_MASK);
-}
-
-static void dw_hdmi_phy_sel_interface_control(struct dw_hdmi *hdmi, u8 enable)
-{
-	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
-			 HDMI_PHY_CONF0_SELDIPIF_OFFSET,
-			 HDMI_PHY_CONF0_SELDIPIF_MASK);
-}
-
-static void dw_hdmi_phy_power_off(struct dw_hdmi *hdmi)
-{
-	const struct dw_hdmi_phy_data *phy = hdmi->phy.data;
-	unsigned int i;
-	u16 val;
-
-	if (phy->gen == 1) {
-		dw_hdmi_phy_enable_tmds(hdmi, 0);
-		dw_hdmi_phy_enable_powerdown(hdmi, true);
-		return;
-	}
-
-	dw_hdmi_phy_gen2_txpwron(hdmi, 0);
-
-	/*
-	 * Wait for TX_PHY_LOCK to be deasserted to indicate that the PHY went
-	 * to low power mode.
-	 */
-	for (i = 0; i < 5; ++i) {
-		val = hdmi_readb(hdmi, HDMI_PHY_STAT0);
-		if (!(val & HDMI_PHY_TX_PHY_LOCK))
-			break;
-
-		udelay(2000);
-	}
-
-	if (val & HDMI_PHY_TX_PHY_LOCK)
-		printf("PHY failed to power down\n");
-	else
-		printf("PHY powered down in %u iterations\n", i);
-
-	dw_hdmi_phy_gen2_pddq(hdmi, 1);
-}
-
-static int dw_hdmi_phy_power_on(struct dw_hdmi *hdmi)
-{
-	const struct dw_hdmi_phy_data *phy = hdmi->phy.data;
-	unsigned int i;
-	u8 val;
-
-	if (phy->gen == 1) {
-		dw_hdmi_phy_enable_powerdown(hdmi, false);
-
-		/* Toggle TMDS enable. */
-		dw_hdmi_phy_enable_tmds(hdmi, 0);
-		dw_hdmi_phy_enable_tmds(hdmi, 1);
-		return 0;
-	}
-
-	dw_hdmi_phy_gen2_txpwron(hdmi, 1);
-	dw_hdmi_phy_gen2_pddq(hdmi, 0);
-
-	/* Wait for PHY PLL lock */
-	for (i = 0; i < 5; ++i) {
-		val = hdmi_readb(hdmi, HDMI_PHY_STAT0) & HDMI_PHY_TX_PHY_LOCK;
-		if (val)
-			break;
-
-		udelay(2000);
-	}
-
-	if (!val) {
-		printf("PHY PLL failed to lock\n");
-		return -ETIMEDOUT;
-	}
-	printf("PHY PLL locked %u iterations\n", i);
-
-	return 0;
-}
-
-/*
- * PHY configuration function for the DWC HDMI 3D TX PHY. Based on the available
- * information the DWC MHL PHY has the same register layout and is thus also
- * supported by this function.
- */
-static
-int hdmi_phy_configure_dwc_hdmi_3d_tx(struct dw_hdmi *hdmi,
-				      const struct dw_hdmi_plat_data *pdata,
-				      unsigned long mpixelclock)
-{
-	const struct dw_hdmi_mpll_config *mpll_config = pdata->mpll_cfg;
-	const struct dw_hdmi_curr_ctrl *curr_ctrl = pdata->cur_ctr;
-	const struct dw_hdmi_phy_config *phy_config = pdata->phy_config;
-	unsigned int tmdsclock = hdmi->hdmi_data.video_mode.mtmdsclock;
-	unsigned int depth =
-		hdmi_bus_fmt_color_depth(hdmi->hdmi_data.enc_out_bus_format);
-
-	if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format) &&
-	    pdata->mpll_cfg_420)
-		mpll_config = pdata->mpll_cfg_420;
-
-	/* PLL/MPLL Cfg - always match on final entry */
-	for (; mpll_config->mpixelclock != ~0UL; mpll_config++)
-		if (mpixelclock <= mpll_config->mpixelclock)
-			break;
-
-	for (; curr_ctrl->mpixelclock != ~0UL; curr_ctrl++)
-		if (tmdsclock <= curr_ctrl->mpixelclock)
-			break;
-
-	for (; phy_config->mpixelclock != ~0UL; phy_config++)
-		if (tmdsclock <= phy_config->mpixelclock)
-			break;
-
-	if (mpll_config->mpixelclock == ~0UL ||
-	    curr_ctrl->mpixelclock == ~0UL ||
-	    phy_config->mpixelclock == ~0UL)
-		return -EINVAL;
-
-	if (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format))
-		depth = fls(depth - 8);
-	else
-		depth = 0;
-	if (depth)
-		depth--;
-
-	dw_hdmi_phy_i2c_write(hdmi, mpll_config->res[depth].cpce,
-			      HDMI_3D_TX_PHY_CPCE_CTRL);
-
-	dw_hdmi_phy_i2c_write(hdmi, mpll_config->res[depth].gmp,
-			      HDMI_3D_TX_PHY_GMPCTRL);
-	dw_hdmi_phy_i2c_write(hdmi, curr_ctrl->curr[depth],
-			      HDMI_3D_TX_PHY_CURRCTRL);
-
-	dw_hdmi_phy_i2c_write(hdmi, 0, HDMI_3D_TX_PHY_PLLPHBYCTRL);
-	dw_hdmi_phy_i2c_write(hdmi, HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_FB_CLK,
-			      HDMI_3D_TX_PHY_MSM_CTRL);
-
-	dw_hdmi_phy_i2c_write(hdmi, phy_config->term, HDMI_3D_TX_PHY_TXTERM);
-	dw_hdmi_phy_i2c_write(hdmi, phy_config->sym_ctr,
-			      HDMI_3D_TX_PHY_CKSYMTXCTRL);
-	dw_hdmi_phy_i2c_write(hdmi, phy_config->vlev_ctr,
-			      HDMI_3D_TX_PHY_VLEVCTRL);
-
-	return 0;
-}
-
-static const struct dw_hdmi_phy_data dw_hdmi_phys[] = {
-	{
-		.type = DW_HDMI_PHY_DWC_HDMI_TX_PHY,
-		.name = "DWC HDMI TX PHY",
-		.gen = 1,
-	}, {
-		.type = DW_HDMI_PHY_DWC_MHL_PHY_HEAC,
-		.name = "DWC MHL PHY + HEAC PHY",
-		.gen = 2,
-		.has_svsret = true,
-		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
-	}, {
-		.type = DW_HDMI_PHY_DWC_MHL_PHY,
-		.name = "DWC MHL PHY",
-		.gen = 2,
-		.has_svsret = true,
-		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
-	}, {
-		.type = DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY_HEAC,
-		.name = "DWC HDMI 3D TX PHY + HEAC PHY",
-		.gen = 2,
-		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
-	}, {
-		.type = DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY,
-		.name = "DWC HDMI 3D TX PHY",
-		.gen = 2,
-		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
-	}, {
-		.type = DW_HDMI_PHY_DWC_HDMI20_TX_PHY,
-		.name = "DWC HDMI 2.0 TX PHY",
-		.gen = 2,
-		.has_svsret = true,
-		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
-	}, {
-		.type = DW_HDMI_PHY_VENDOR_PHY,
-		.name = "Vendor PHY",
-	}
-};
-
-static int rockchip_dw_hdmi_scrambling_enable(struct dw_hdmi *hdmi,
-					      int enable)
-{
-	u8 stat;
-
-	drm_scdc_readb(&hdmi->adap, SCDC_TMDS_CONFIG, &stat);
-
-	if (stat < 0) {
-		debug("Failed to read tmds config\n");
-		return false;
-	}
-
-	if (enable == 1) {
-		/* Write on Rx the bit Scrambling_Enable, register 0x20 */
-		stat |= SCDC_SCRAMBLING_ENABLE;
-		drm_scdc_writeb(&hdmi->adap, SCDC_TMDS_CONFIG, stat);
-		/* TMDS software reset request */
-		hdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ,
-			    HDMI_MC_SWRSTZ);
-		/* Enable/Disable Scrambling */
-		hdmi_writeb(hdmi, 1, HDMI_FC_SCRAMBLER_CTRL);
-	} else {
-		/* Enable/Disable Scrambling */
-		hdmi_writeb(hdmi, 0, HDMI_FC_SCRAMBLER_CTRL);
-		/* TMDS software reset request */
-		hdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ,
-			    HDMI_MC_SWRSTZ);
-		/* Write on Rx the bit Scrambling_Enable, register 0x20 */
-		stat &= ~SCDC_SCRAMBLING_ENABLE;
-		drm_scdc_writeb(&hdmi->adap, SCDC_TMDS_CONFIG, stat);
-	}
-
-	return 0;
-}
-
-static void rockchip_dw_hdmi_scdc_set_tmds_rate(struct dw_hdmi *hdmi)
-{
-	u8 stat;
-
-	drm_scdc_readb(&hdmi->adap, SCDC_TMDS_CONFIG, &stat);
-	if (hdmi->hdmi_data.video_mode.mtmdsclock > 340000000)
-		stat |= SCDC_TMDS_BIT_CLOCK_RATIO_BY_40;
-	else
-		stat &= ~SCDC_TMDS_BIT_CLOCK_RATIO_BY_40;
-	drm_scdc_writeb(&hdmi->adap, SCDC_TMDS_CONFIG, stat);
-}
-
-static int hdmi_phy_configure(struct dw_hdmi *hdmi)
-{
-	const struct dw_hdmi_phy_data *phy = hdmi->phy.data;
-	const struct dw_hdmi_plat_data *pdata = hdmi->plat_data;
-	unsigned long mpixelclock = hdmi->hdmi_data.video_mode.mpixelclock;
-	unsigned long mtmdsclock = hdmi->hdmi_data.video_mode.mtmdsclock;
-	int ret;
-
-	dw_hdmi_phy_power_off(hdmi);
-
-	/* Control for TMDS Bit Period/TMDS Clock-Period Ratio */
-	if (hdmi->edid_data.display_info.hdmi.scdc.supported)
-		rockchip_dw_hdmi_scdc_set_tmds_rate(hdmi);
-
-	/* Leave low power consumption mode by asserting SVSRET. */
-	if (phy->has_svsret)
-		dw_hdmi_phy_enable_svsret(hdmi, 1);
-
-	/* PHY reset. The reset signal is active high on Gen2 PHYs. */
-	hdmi_writeb(hdmi, HDMI_MC_PHYRSTZ_PHYRSTZ, HDMI_MC_PHYRSTZ);
-	hdmi_writeb(hdmi, 0, HDMI_MC_PHYRSTZ);
-
-	hdmi_writeb(hdmi, HDMI_MC_HEACPHY_RST_ASSERT, HDMI_MC_HEACPHY_RST);
-
-	hdmi_phy_test_clear(hdmi, 1);
-	hdmi_writeb(hdmi, HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2,
-		    HDMI_PHY_I2CM_SLAVE_ADDR);
-	hdmi_phy_test_clear(hdmi, 0);
-
-	/* Write to the PHY as configured by the platform */
-	if (pdata->configure_phy)
-		ret = pdata->configure_phy(hdmi, pdata, mpixelclock);
-	else
-		ret = phy->configure(hdmi, pdata, mpixelclock);
-	if (ret) {
-		printf("PHY configuration failed (clock %lu)\n",
-		       mpixelclock);
-		return ret;
-	}
-
-	/* Wait for resuming transmission of TMDS clock and data */
-	if (mtmdsclock > 340000000)
-		mdelay(100);
-
-	return dw_hdmi_phy_power_on(hdmi);
-}
-
-static int dw_hdmi_phy_init(struct dw_hdmi *hdmi,
-			    void *data)
-{
-	int i, ret;
-
-	/* HDMI Phy spec says to do the phy initialization sequence twice */
-	for (i = 0; i < 2; i++) {
-		dw_hdmi_phy_sel_data_en_pol(hdmi, 1);
-		dw_hdmi_phy_sel_interface_control(hdmi, 0);
-		ret = hdmi_phy_configure(hdmi);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-static void dw_hdmi_phy_disable(struct dw_hdmi *hdmi,
-				void *data)
-{
-	dw_hdmi_phy_power_off(hdmi);
-}
-
-static enum drm_connector_status
-dw_hdmi_phy_read_hpd(struct dw_hdmi *hdmi, void *data)
-{
-	return hdmi_readb(hdmi, HDMI_PHY_STAT0) & HDMI_PHY_HPD ?
-		connector_status_connected : connector_status_disconnected;
-}
-
-static const struct dw_hdmi_phy_ops dw_hdmi_synopsys_phy_ops = {
-	.init = dw_hdmi_phy_init,
-	.disable = dw_hdmi_phy_disable,
-	.read_hpd = dw_hdmi_phy_read_hpd,
-};
-
-static int dw_hdmi_detect_phy(struct dw_hdmi *hdmi)
-{
-	unsigned int i;
-	u8 phy_type;
-
-	phy_type = hdmi_readb(hdmi, HDMI_CONFIG2_ID);
-
-	/*
-	 * RK3228 and RK3328 phy_type is DW_HDMI_PHY_DWC_HDMI20_TX_PHY,
-	 * but it has a vedor phy.
-	 */
-	if (phy_type == DW_HDMI_PHY_VENDOR_PHY ||
-	    hdmi->dev_type == RK3328_HDMI ||
-	    hdmi->dev_type == RK3228_HDMI) {
-		/* Vendor PHYs require support from the glue layer. */
-		if (!hdmi->plat_data->phy_ops || !hdmi->plat_data->phy_name) {
-			printf(
-				"Vendor HDMI PHY not supported by glue layer\n");
-			return -ENODEV;
-		}
-
-		hdmi->phy.ops = hdmi->plat_data->phy_ops;
-		hdmi->phy.data = hdmi->plat_data->phy_data;
-		hdmi->phy.name = hdmi->plat_data->phy_name;
-		return 0;
-	}
-
-	/* Synopsys PHYs are handled internally. */
-	for (i = 0; i < ARRAY_SIZE(dw_hdmi_phys); ++i) {
-		if (dw_hdmi_phys[i].type == phy_type) {
-			hdmi->phy.ops = &dw_hdmi_synopsys_phy_ops;
-			hdmi->phy.name = dw_hdmi_phys[i].name;
-			hdmi->phy.data = (void *)&dw_hdmi_phys[i];
-
-			if (!dw_hdmi_phys[i].configure &&
-			    !hdmi->plat_data->configure_phy) {
-				printf("%s requires platform support\n",
-				       hdmi->phy.name);
-				return -ENODEV;
-			}
-
-			return 0;
-		}
-	}
-
-	printf("Unsupported HDMI PHY type (%02x)\n", phy_type);
-	return -ENODEV;
-}
-
-static unsigned int
-hdmi_get_tmdsclock(struct dw_hdmi *hdmi, unsigned long mpixelclock)
-{
-	unsigned int tmdsclock = mpixelclock;
-	unsigned int depth =
-		hdmi_bus_fmt_color_depth(hdmi->hdmi_data.enc_out_bus_format);
-
-	if (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format)) {
-		switch (depth) {
-		case 16:
-			tmdsclock = mpixelclock * 2;
-			break;
-		case 12:
-			tmdsclock = mpixelclock * 3 / 2;
-			break;
-		case 10:
-			tmdsclock = mpixelclock * 5 / 4;
-			break;
-		default:
-			break;
-		}
-	}
-
-	return tmdsclock;
-}
-
-static void hdmi_av_composer(struct dw_hdmi *hdmi,
-			     const struct drm_display_mode *mode)
-{
-	u8 bytes = 0, inv_val = 0;
-	struct hdmi_vmode *vmode = &hdmi->hdmi_data.video_mode;
-	struct drm_hdmi_info *hdmi_info = &hdmi->edid_data.display_info.hdmi;
-	int hblank, vblank, h_de_hs, v_de_vs, hsync_len, vsync_len;
-	unsigned int hdisplay, vdisplay;
-
-	vmode->mpixelclock = mode->crtc_clock * 1000;
-	if ((mode->flags & DRM_MODE_FLAG_3D_MASK) ==
-		DRM_MODE_FLAG_3D_FRAME_PACKING)
-		vmode->mpixelclock *= 2;
-	vmode->mtmdsclock = hdmi_get_tmdsclock(hdmi, vmode->mpixelclock);
-	if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format))
-		vmode->mtmdsclock /= 2;
-	printf("final pixclk = %d tmdsclk = %d\n",
-	       vmode->mpixelclock, vmode->mtmdsclock);
-
-	/* Set up HDMI_FC_INVIDCONF
-	 * fc_invidconf.HDCP_keepout must be set (1'b1)
-	 * when activate the scrambler feature.
-	 */
-	inv_val = (vmode->mtmdsclock > 340000000 ||
-		   (hdmi_info->scdc.scrambling.low_rates &&
-		   hdmi->scramble_low_rates) ?
-		   HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE :
-		   HDMI_FC_INVIDCONF_HDCP_KEEPOUT_INACTIVE);
-
-	inv_val |= mode->flags & DRM_MODE_FLAG_PVSYNC ?
-		HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH :
-		HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW;
-
-	inv_val |= mode->flags & DRM_MODE_FLAG_PHSYNC ?
-		HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH :
-		HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW;
-
-	inv_val |= (vmode->mdataenablepolarity ?
-		HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH :
-		HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW);
-
-	if (hdmi->vic == 39)
-		inv_val |= HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH;
-	else
-		inv_val |= mode->flags & DRM_MODE_FLAG_INTERLACE ?
-			HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH :
-			HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW;
-
-	inv_val |= mode->flags & DRM_MODE_FLAG_INTERLACE ?
-		HDMI_FC_INVIDCONF_IN_I_P_INTERLACED :
-		HDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE;
-
-	inv_val |= hdmi->sink_is_hdmi ?
-		HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE :
-		HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE;
-
-	hdmi_writeb(hdmi, inv_val, HDMI_FC_INVIDCONF);
-
-	hdisplay = mode->hdisplay;
-	hblank = mode->htotal - mode->hdisplay;
-	h_de_hs = mode->hsync_start - mode->hdisplay;
-	hsync_len = mode->hsync_end - mode->hsync_start;
-
-	/*
-	 * When we're setting a YCbCr420 mode, we need
-	 * to adjust the horizontal timing to suit.
-	 */
-	if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format)) {
-		hdisplay /= 2;
-		hblank /= 2;
-		h_de_hs /= 2;
-		hsync_len /= 2;
-	}
-
-	vdisplay = mode->vdisplay;
-	vblank = mode->vtotal - mode->vdisplay;
-	v_de_vs = mode->vsync_start - mode->vdisplay;
-	vsync_len = mode->vsync_end - mode->vsync_start;
-
-	/*
-	 * When we're setting an interlaced mode, we need
-	 * to adjust the vertical timing to suit.
-	 */
-	if (mode->flags & DRM_MODE_FLAG_INTERLACE) {
-		vdisplay /= 2;
-		vblank /= 2;
-		v_de_vs /= 2;
-		vsync_len /= 2;
-	} else if ((mode->flags & DRM_MODE_FLAG_3D_MASK) ==
-		DRM_MODE_FLAG_3D_FRAME_PACKING) {
-		vdisplay += mode->vtotal;
-	}
-
-	/* Scrambling Control */
-	if (hdmi_info->scdc.supported) {
-		if (vmode->mtmdsclock > 340000000 ||
-		    (hdmi_info->scdc.scrambling.low_rates &&
-		     hdmi->scramble_low_rates)) {
-			drm_scdc_readb(&hdmi->adap, SCDC_SINK_VERSION, &bytes);
-			drm_scdc_writeb(&hdmi->adap, SCDC_SOURCE_VERSION,
-					bytes);
-			rockchip_dw_hdmi_scrambling_enable(hdmi, 1);
-		} else {
-			rockchip_dw_hdmi_scrambling_enable(hdmi, 0);
-		}
-	}
-
-	/* Set up horizontal active pixel width */
-	hdmi_writeb(hdmi, hdisplay >> 8, HDMI_FC_INHACTV1);
-	hdmi_writeb(hdmi, hdisplay, HDMI_FC_INHACTV0);
-
-	/* Set up vertical active lines */
-	hdmi_writeb(hdmi, vdisplay >> 8, HDMI_FC_INVACTV1);
-	hdmi_writeb(hdmi, vdisplay, HDMI_FC_INVACTV0);
-
-	/* Set up horizontal blanking pixel region width */
-	hdmi_writeb(hdmi, hblank >> 8, HDMI_FC_INHBLANK1);
-	hdmi_writeb(hdmi, hblank, HDMI_FC_INHBLANK0);
-
-	/* Set up vertical blanking pixel region width */
-	hdmi_writeb(hdmi, vblank, HDMI_FC_INVBLANK);
-
-	/* Set up HSYNC active edge delay width (in pixel clks) */
-	hdmi_writeb(hdmi, h_de_hs >> 8, HDMI_FC_HSYNCINDELAY1);
-	hdmi_writeb(hdmi, h_de_hs, HDMI_FC_HSYNCINDELAY0);
-
-	/* Set up VSYNC active edge delay (in lines) */
-	hdmi_writeb(hdmi, v_de_vs, HDMI_FC_VSYNCINDELAY);
-
-	/* Set up HSYNC active pulse width (in pixel clks) */
-	hdmi_writeb(hdmi, hsync_len >> 8, HDMI_FC_HSYNCINWIDTH1);
-	hdmi_writeb(hdmi, hsync_len, HDMI_FC_HSYNCINWIDTH0);
-
-	/* Set up VSYNC active edge delay (in lines) */
-	hdmi_writeb(hdmi, vsync_len, HDMI_FC_VSYNCINWIDTH);
-}
-
-static void dw_hdmi_update_csc_coeffs(struct dw_hdmi *hdmi)
-{
-	const u16 (*csc_coeff)[3][4] = &csc_coeff_default;
-	unsigned i;
-	u32 csc_scale = 1;
-	int enc_out_rgb, enc_in_rgb;
-
-	enc_out_rgb = hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format);
-	enc_in_rgb = hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_in_bus_format);
-
-	if (is_color_space_conversion(hdmi)) {
-		if (enc_out_rgb && enc_in_rgb) {
-			csc_coeff = &csc_coeff_full_to_limited;
-			csc_scale = 0;
-		} else if (enc_out_rgb) {
-			if (hdmi->hdmi_data.enc_out_encoding ==
-						V4L2_YCBCR_ENC_601)
-				csc_coeff = &csc_coeff_rgb_out_eitu601;
-			else
-				csc_coeff = &csc_coeff_rgb_out_eitu709;
-		} else if (enc_in_rgb) {
-			if (hdmi->hdmi_data.enc_out_encoding ==
-						V4L2_YCBCR_ENC_601)
-				csc_coeff = &csc_coeff_rgb_in_eitu601;
-			else
-				csc_coeff = &csc_coeff_rgb_in_eitu709;
-			csc_scale = 0;
-		}
-	}
-
-	/* The CSC registers are sequential, alternating MSB then LSB */
-	for (i = 0; i < ARRAY_SIZE(csc_coeff_default[0]); i++) {
-		u16 coeff_a = (*csc_coeff)[0][i];
-		u16 coeff_b = (*csc_coeff)[1][i];
-		u16 coeff_c = (*csc_coeff)[2][i];
-
-		hdmi_writeb(hdmi, coeff_a & 0xff, HDMI_CSC_COEF_A1_LSB + i * 2);
-		hdmi_writeb(hdmi, coeff_a >> 8, HDMI_CSC_COEF_A1_MSB + i * 2);
-		hdmi_writeb(hdmi, coeff_b & 0xff, HDMI_CSC_COEF_B1_LSB + i * 2);
-		hdmi_writeb(hdmi, coeff_b >> 8, HDMI_CSC_COEF_B1_MSB + i * 2);
-		hdmi_writeb(hdmi, coeff_c & 0xff, HDMI_CSC_COEF_C1_LSB + i * 2);
-		hdmi_writeb(hdmi, coeff_c >> 8, HDMI_CSC_COEF_C1_MSB + i * 2);
-	}
-
-	hdmi_modb(hdmi, csc_scale, HDMI_CSC_SCALE_CSCSCALE_MASK,
-		  HDMI_CSC_SCALE);
-}
-
-static int is_color_space_interpolation(struct dw_hdmi *hdmi)
-{
-	if (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_in_bus_format))
-		return 0;
-
-	if (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format) ||
-	    hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_out_bus_format))
-		return 1;
-
-	return 0;
-}
-
-static void hdmi_video_csc(struct dw_hdmi *hdmi)
-{
-	int color_depth = 0;
-	int interpolation = HDMI_CSC_CFG_INTMODE_DISABLE;
-	int decimation = 0;
-
-	/* YCC422 interpolation to 444 mode */
-	if (is_color_space_interpolation(hdmi))
-		interpolation = HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA1;
-	else if (is_color_space_decimation(hdmi))
-		decimation = HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA3;
-
-	switch (hdmi_bus_fmt_color_depth(hdmi->hdmi_data.enc_out_bus_format)) {
-	case 8:
-		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_24BPP;
-		break;
-	case 10:
-		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_30BPP;
-		break;
-	case 12:
-		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_36BPP;
-		break;
-	case 16:
-		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_48BPP;
-		break;
-
-	default:
-		return;
-	}
-
-	/* Configure the CSC registers */
-	hdmi_writeb(hdmi, interpolation | decimation, HDMI_CSC_CFG);
-	hdmi_modb(hdmi, color_depth, HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK,
-		  HDMI_CSC_SCALE);
-
-	dw_hdmi_update_csc_coeffs(hdmi);
-}
-
-static void dw_hdmi_enable_video_path(struct dw_hdmi *hdmi)
-{
-	u8 clkdis;
-
-	/* control period minimum duration */
-	hdmi_writeb(hdmi, 12, HDMI_FC_CTRLDUR);
-	hdmi_writeb(hdmi, 32, HDMI_FC_EXCTRLDUR);
-	hdmi_writeb(hdmi, 1, HDMI_FC_EXCTRLSPAC);
-
-	/* Set to fill TMDS data channels */
-	hdmi_writeb(hdmi, 0x0B, HDMI_FC_CH0PREAM);
-	hdmi_writeb(hdmi, 0x16, HDMI_FC_CH1PREAM);
-	hdmi_writeb(hdmi, 0x21, HDMI_FC_CH2PREAM);
-
-	/* Enable pixel clock and tmds data path */
-	clkdis = 0x7F;
-	clkdis &= ~HDMI_MC_CLKDIS_PIXELCLK_DISABLE;
-	hdmi_writeb(hdmi, clkdis, HDMI_MC_CLKDIS);
-
-	clkdis &= ~HDMI_MC_CLKDIS_TMDSCLK_DISABLE;
-	hdmi_writeb(hdmi, clkdis, HDMI_MC_CLKDIS);
-
-	/* Enable csc path */
-	if (is_color_space_conversion(hdmi)) {
-		clkdis &= ~HDMI_MC_CLKDIS_CSCCLK_DISABLE;
-		hdmi_writeb(hdmi, clkdis, HDMI_MC_CLKDIS);
-	}
-
-	/* Enable pixel repetition path */
-	if (hdmi->hdmi_data.video_mode.mpixelrepetitioninput) {
-		clkdis &= ~HDMI_MC_CLKDIS_PREPCLK_DISABLE;
-		hdmi_writeb(hdmi, clkdis, HDMI_MC_CLKDIS);
-	}
-
-	/* Enable color space conversion if needed */
-	if (is_color_space_conversion(hdmi))
-		hdmi_writeb(hdmi, HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_IN_PATH,
-			    HDMI_MC_FLOWCTRL);
-	else
-		hdmi_writeb(hdmi, HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_BYPASS,
-			    HDMI_MC_FLOWCTRL);
-}
-
-static void dw_hdmi_clear_overflow(struct dw_hdmi *hdmi)
-{
-	unsigned int count;
-	unsigned int i;
-	u8 val;
-
-	/*
-	 * Under some circumstances the Frame Composer arithmetic unit can miss
-	 * an FC register write due to being busy processing the previous one.
-	 * The issue can be worked around by issuing a TMDS software reset and
-	 * then write one of the FC registers several times.
-	 *
-	 * The number of iterations matters and depends on the HDMI TX revision
-	 * (and possibly on the platform). So far only i.MX6Q (v1.30a) and
-	 * i.MX6DL (v1.31a) have been identified as needing the workaround, with
-	 * 4 and 1 iterations respectively.
-	 */
-
-	switch (hdmi->version) {
-	case 0x130a:
-		count = 4;
-		break;
-	case 0x131a:
-	case 0x200a:
-	case 0x201a:
-	case 0x211a:
-		count = 1;
-		break;
-	default:
-		return;
-	}
-
-	/* TMDS software reset */
-	hdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ, HDMI_MC_SWRSTZ);
-
-	val = hdmi_readb(hdmi, HDMI_FC_INVIDCONF);
-	for (i = 0; i < count; i++)
-		hdmi_writeb(hdmi, val, HDMI_FC_INVIDCONF);
-}
-
-static void hdmi_disable_overflow_interrupts(struct dw_hdmi *hdmi)
-{
-	hdmi_writeb(hdmi, HDMI_IH_MUTE_FC_STAT2_OVERFLOW_MASK,
-		    HDMI_IH_MUTE_FC_STAT2);
-}
-
-static void hdmi_video_packetize(struct dw_hdmi *hdmi)
-{
-	unsigned int color_depth = 0;
-	unsigned int remap_size = HDMI_VP_REMAP_YCC422_16bit;
-	unsigned int output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_PP;
-	struct hdmi_data_info *hdmi_data = &hdmi->hdmi_data;
-	u8 val, vp_conf;
-
-	if (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format) ||
-	    hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_out_bus_format) ||
-	    hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format)) {
-		switch (hdmi_bus_fmt_color_depth(
-					hdmi->hdmi_data.enc_out_bus_format)) {
-		case 8:
-			color_depth = 0;
-			output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS;
-			break;
-		case 10:
-			color_depth = 5;
-			break;
-		case 12:
-			color_depth = 6;
-			break;
-		case 16:
-			color_depth = 7;
-			break;
-		default:
-			output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS;
-		}
-	} else if (hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format)) {
-		switch (hdmi_bus_fmt_color_depth(
-					hdmi->hdmi_data.enc_out_bus_format)) {
-		case 0:
-		case 8:
-			remap_size = HDMI_VP_REMAP_YCC422_16bit;
-			break;
-		case 10:
-			remap_size = HDMI_VP_REMAP_YCC422_20bit;
-			break;
-		case 12:
-			remap_size = HDMI_VP_REMAP_YCC422_24bit;
-			break;
-
-		default:
-			return;
-		}
-		output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422;
-	} else {
-		return;
-	}
-
-	/* set the packetizer registers */
-	val = (color_depth << HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET) &
-	      HDMI_VP_PR_CD_COLOR_DEPTH_MASK;
-	hdmi_writeb(hdmi, val, HDMI_VP_PR_CD);
-
-	hdmi_modb(hdmi, HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE,
-		  HDMI_VP_STUFF_PR_STUFFING_MASK, HDMI_VP_STUFF);
-
-	/* Data from pixel repeater block */
-	if (hdmi_data->pix_repet_factor > 0) {
-		vp_conf = HDMI_VP_CONF_PR_EN_ENABLE |
-			  HDMI_VP_CONF_BYPASS_SELECT_PIX_REPEATER;
-	} else { /* data from packetizer block */
-		vp_conf = HDMI_VP_CONF_PR_EN_DISABLE |
-			  HDMI_VP_CONF_BYPASS_SELECT_VID_PACKETIZER;
-	}
-
-	hdmi_modb(hdmi, vp_conf,
-		  HDMI_VP_CONF_PR_EN_MASK |
-		  HDMI_VP_CONF_BYPASS_SELECT_MASK, HDMI_VP_CONF);
-
-	if ((color_depth == 5 && hdmi->previous_mode.htotal % 4) ||
-	    (color_depth == 6 && hdmi->previous_mode.htotal % 2))
-		hdmi_modb(hdmi, 0, HDMI_VP_STUFF_IDEFAULT_PHASE_MASK,
-			  HDMI_VP_STUFF);
-	else
-		hdmi_modb(hdmi, 1 << HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET,
-			  HDMI_VP_STUFF_IDEFAULT_PHASE_MASK, HDMI_VP_STUFF);
-
-	hdmi_writeb(hdmi, remap_size, HDMI_VP_REMAP);
-
-	if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_PP) {
-		vp_conf = HDMI_VP_CONF_BYPASS_EN_DISABLE |
-			  HDMI_VP_CONF_PP_EN_ENABLE |
-			  HDMI_VP_CONF_YCC422_EN_DISABLE;
-	} else if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422) {
-		vp_conf = HDMI_VP_CONF_BYPASS_EN_DISABLE |
-			  HDMI_VP_CONF_PP_EN_DISABLE |
-			  HDMI_VP_CONF_YCC422_EN_ENABLE;
-	} else if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS) {
-		vp_conf = HDMI_VP_CONF_BYPASS_EN_ENABLE |
-			  HDMI_VP_CONF_PP_EN_DISABLE |
-			  HDMI_VP_CONF_YCC422_EN_DISABLE;
-	} else {
-		return;
-	}
-
-	hdmi_modb(hdmi, vp_conf,
-		  HDMI_VP_CONF_BYPASS_EN_MASK | HDMI_VP_CONF_PP_EN_ENMASK |
-		  HDMI_VP_CONF_YCC422_EN_MASK, HDMI_VP_CONF);
-
-	hdmi_modb(hdmi, HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE |
-			HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE,
-		  HDMI_VP_STUFF_PP_STUFFING_MASK |
-		  HDMI_VP_STUFF_YCC422_STUFFING_MASK, HDMI_VP_STUFF);
-
-	hdmi_modb(hdmi, output_select, HDMI_VP_CONF_OUTPUT_SELECTOR_MASK,
-		  HDMI_VP_CONF);
-}
-
-static void hdmi_video_sample(struct dw_hdmi *hdmi)
-{
-	int color_format = 0;
-	u8 val;
-
-	switch (hdmi->hdmi_data.enc_in_bus_format) {
-	case MEDIA_BUS_FMT_RGB888_1X24:
-		color_format = 0x01;
-		break;
-	case MEDIA_BUS_FMT_RGB101010_1X30:
-		color_format = 0x03;
-		break;
-	case MEDIA_BUS_FMT_RGB121212_1X36:
-		color_format = 0x05;
-		break;
-	case MEDIA_BUS_FMT_RGB161616_1X48:
-		color_format = 0x07;
-		break;
-
-	case MEDIA_BUS_FMT_YUV8_1X24:
-	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
-		color_format = 0x09;
-		break;
-	case MEDIA_BUS_FMT_YUV10_1X30:
-	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
-		color_format = 0x0B;
-		break;
-	case MEDIA_BUS_FMT_YUV12_1X36:
-	case MEDIA_BUS_FMT_UYYVYY12_0_5X36:
-		color_format = 0x0D;
-		break;
-	case MEDIA_BUS_FMT_YUV16_1X48:
-	case MEDIA_BUS_FMT_UYYVYY16_0_5X48:
-		color_format = 0x0F;
-		break;
-
-	case MEDIA_BUS_FMT_UYVY8_1X16:
-		color_format = 0x16;
-		break;
-	case MEDIA_BUS_FMT_UYVY10_1X20:
-		color_format = 0x14;
-		break;
-	case MEDIA_BUS_FMT_UYVY12_1X24:
-		color_format = 0x12;
-		break;
-
-	default:
-		return;
-	}
-
-	val = HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_DISABLE |
-		((color_format << HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET) &
-		HDMI_TX_INVID0_VIDEO_MAPPING_MASK);
-	hdmi_writeb(hdmi, val, HDMI_TX_INVID0);
-
-	/* Enable TX stuffing: When DE is inactive, fix the output data to 0 */
-	val = HDMI_TX_INSTUFFING_BDBDATA_STUFFING_ENABLE |
-		HDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE |
-		HDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE;
-	hdmi_writeb(hdmi, val, HDMI_TX_INSTUFFING);
-	hdmi_writeb(hdmi, 0x0, HDMI_TX_GYDATA0);
-	hdmi_writeb(hdmi, 0x0, HDMI_TX_GYDATA1);
-	hdmi_writeb(hdmi, 0x0, HDMI_TX_RCRDATA0);
-	hdmi_writeb(hdmi, 0x0, HDMI_TX_RCRDATA1);
-	hdmi_writeb(hdmi, 0x0, HDMI_TX_BCBDATA0);
-	hdmi_writeb(hdmi, 0x0, HDMI_TX_BCBDATA1);
-}
-
-static void dw_hdmi_disable(struct dw_hdmi *hdmi, struct display_state *state)
-{
-	if (hdmi->phy.enabled) {
-		hdmi->phy.ops->disable(hdmi, state);
-		hdmi->phy.enabled = false;
-	}
-}
-
-static void hdmi_config_AVI(struct dw_hdmi *hdmi, struct drm_display_mode *mode)
-{
-	struct hdmi_avi_infoframe frame;
-	u8 val;
-	bool is_hdmi2 = false;
-	enum hdmi_quantization_range rgb_quant_range =
-		hdmi->hdmi_data.quant_range;
-
-	if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format) ||
-	    hdmi->edid_data.display_info.hdmi.scdc.supported)
-		is_hdmi2 = true;
-	/* Initialise info frame from DRM mode */
-	drm_hdmi_avi_infoframe_from_display_mode(&frame, mode, is_hdmi2);
-
-	/*
-	 * Ignore monitor selectable quantization, use quantization set
-	 * by the user
-	 */
-	drm_hdmi_avi_infoframe_quant_range(&frame, mode, rgb_quant_range,
-					   true);
-	if (hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_out_bus_format))
-		frame.colorspace = HDMI_COLORSPACE_YUV444;
-	else if (hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format))
-		frame.colorspace = HDMI_COLORSPACE_YUV422;
-	else if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format))
-		frame.colorspace = HDMI_COLORSPACE_YUV420;
-	else
-		frame.colorspace = HDMI_COLORSPACE_RGB;
-
-	/* Set up colorimetry */
-	switch (hdmi->hdmi_data.enc_out_encoding) {
-	case V4L2_YCBCR_ENC_601:
-		if (hdmi->hdmi_data.enc_in_encoding == V4L2_YCBCR_ENC_XV601)
-			frame.colorimetry = HDMI_COLORIMETRY_EXTENDED;
-		else
-			frame.colorimetry = HDMI_COLORIMETRY_ITU_601;
-		frame.extended_colorimetry =
-				HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;
-		break;
-	case V4L2_YCBCR_ENC_709:
-		if (hdmi->hdmi_data.enc_in_encoding == V4L2_YCBCR_ENC_XV709)
-			frame.colorimetry = HDMI_COLORIMETRY_EXTENDED;
-		else
-			frame.colorimetry = HDMI_COLORIMETRY_ITU_709;
-		frame.extended_colorimetry =
-				HDMI_EXTENDED_COLORIMETRY_XV_YCC_709;
-		break;
-	default: /* Carries no data */
-		frame.colorimetry = HDMI_COLORIMETRY_ITU_601;
-		frame.extended_colorimetry =
-				HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;
-		break;
-	}
-
-	frame.scan_mode = HDMI_SCAN_MODE_NONE;
-
-	/*
-	 * The Designware IP uses a different byte format from standard
-	 * AVI info frames, though generally the bits are in the correct
-	 * bytes.
-	 */
-
-	/*
-	 * AVI data byte 1 differences: Colorspace in bits 0,1,7 rather than
-	 * 5,6,7, active aspect present in bit 6 rather than 4.
-	 */
-	val = (frame.scan_mode & 3) << 4 | (frame.colorspace & 0x3);
-	if (frame.active_aspect & 15)
-		val |= HDMI_FC_AVICONF0_ACTIVE_FMT_INFO_PRESENT;
-	if (frame.top_bar || frame.bottom_bar)
-		val |= HDMI_FC_AVICONF0_BAR_DATA_HORIZ_BAR;
-	if (frame.left_bar || frame.right_bar)
-		val |= HDMI_FC_AVICONF0_BAR_DATA_VERT_BAR;
-	hdmi_writeb(hdmi, val, HDMI_FC_AVICONF0);
-
-	/* AVI data byte 2 differences: none */
-	val = ((frame.colorimetry & 0x3) << 6) |
-	      ((frame.picture_aspect & 0x3) << 4) |
-	      (frame.active_aspect & 0xf);
-	hdmi_writeb(hdmi, val, HDMI_FC_AVICONF1);
-
-	/* AVI data byte 3 differences: none */
-	val = ((frame.extended_colorimetry & 0x7) << 4) |
-	      ((frame.quantization_range & 0x3) << 2) |
-	      (frame.nups & 0x3);
-	if (frame.itc)
-		val |= HDMI_FC_AVICONF2_IT_CONTENT_VALID;
-	hdmi_writeb(hdmi, val, HDMI_FC_AVICONF2);
-
-	/* AVI data byte 4 differences: none */
-	val = frame.video_code & 0x7f;
-	hdmi_writeb(hdmi, val, HDMI_FC_AVIVID);
-
-	/* AVI Data Byte 5- set up input and output pixel repetition */
-	val = (((hdmi->hdmi_data.video_mode.mpixelrepetitioninput + 1) <<
-		HDMI_FC_PRCONF_INCOMING_PR_FACTOR_OFFSET) &
-		HDMI_FC_PRCONF_INCOMING_PR_FACTOR_MASK) |
-		((hdmi->hdmi_data.video_mode.mpixelrepetitionoutput <<
-		HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_OFFSET) &
-		HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_MASK);
-	hdmi_writeb(hdmi, val, HDMI_FC_PRCONF);
-
-	/*
-	 * AVI data byte 5 differences: content type in 0,1 rather than 4,5,
-	 * ycc range in bits 2,3 rather than 6,7
-	 */
-	val = ((frame.ycc_quantization_range & 0x3) << 2) |
-	      (frame.content_type & 0x3);
-	hdmi_writeb(hdmi, val, HDMI_FC_AVICONF3);
-
-	/* AVI Data Bytes 6-13 */
-	hdmi_writeb(hdmi, frame.top_bar & 0xff, HDMI_FC_AVIETB0);
-	hdmi_writeb(hdmi, (frame.top_bar >> 8) & 0xff, HDMI_FC_AVIETB1);
-	hdmi_writeb(hdmi, frame.bottom_bar & 0xff, HDMI_FC_AVISBB0);
-	hdmi_writeb(hdmi, (frame.bottom_bar >> 8) & 0xff, HDMI_FC_AVISBB1);
-	hdmi_writeb(hdmi, frame.left_bar & 0xff, HDMI_FC_AVIELB0);
-	hdmi_writeb(hdmi, (frame.left_bar >> 8) & 0xff, HDMI_FC_AVIELB1);
-	hdmi_writeb(hdmi, frame.right_bar & 0xff, HDMI_FC_AVISRB0);
-	hdmi_writeb(hdmi, (frame.right_bar >> 8) & 0xff, HDMI_FC_AVISRB1);
-}
-
-static void hdmi_config_vendor_specific_infoframe(struct dw_hdmi *hdmi,
-						  struct drm_display_mode *mode)
-{
-	struct hdmi_vendor_infoframe frame;
-	u8 buffer[10];
-	ssize_t err;
-
-	/* Disable HDMI vendor specific infoframe send */
-	hdmi_mask_writeb(hdmi, 0, HDMI_FC_DATAUTO0, HDMI_FC_DATAUTO0_VSD_OFFSET,
-			 HDMI_FC_DATAUTO0_VSD_MASK);
-
-	err = drm_hdmi_vendor_infoframe_from_display_mode(&frame, mode);
-	if (err < 0)
-		/*
-		 * Going into that statement does not means vendor infoframe
-		 * fails. It just informed us that vendor infoframe is not
-		 * needed for the selected mode. Only 4k or stereoscopic 3D
-		 * mode requires vendor infoframe. So just simply return.
-		 */
-		return;
-
-	err = hdmi_vendor_infoframe_pack(&frame, buffer, sizeof(buffer));
-	if (err < 0) {
-		printf("Failed to pack vendor infoframe: %zd\n", err);
-		return;
-	}
-
-	/* Set the length of HDMI vendor specific InfoFrame payload */
-	hdmi_writeb(hdmi, buffer[2], HDMI_FC_VSDSIZE);
-
-	/* Set 24bit IEEE Registration Identifier */
-	hdmi_writeb(hdmi, buffer[4], HDMI_FC_VSDIEEEID0);
-	hdmi_writeb(hdmi, buffer[5], HDMI_FC_VSDIEEEID1);
-	hdmi_writeb(hdmi, buffer[6], HDMI_FC_VSDIEEEID2);
-
-	/* Set HDMI_Video_Format and HDMI_VIC/3D_Structure */
-	hdmi_writeb(hdmi, buffer[7], HDMI_FC_VSDPAYLOAD0);
-	hdmi_writeb(hdmi, buffer[8], HDMI_FC_VSDPAYLOAD1);
-
-	if (frame.s3d_struct >= HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF)
-		hdmi_writeb(hdmi, buffer[9], HDMI_FC_VSDPAYLOAD2);
-
-	/* Packet frame interpolation */
-	hdmi_writeb(hdmi, 1, HDMI_FC_DATAUTO1);
-
-	/* Auto packets per frame and line spacing */
-	hdmi_writeb(hdmi, 0x11, HDMI_FC_DATAUTO2);
-
-	/* Configures the Frame Composer On RDRB mode */
-	hdmi_mask_writeb(hdmi, 1, HDMI_FC_DATAUTO0, HDMI_FC_DATAUTO0_VSD_OFFSET,
-			 HDMI_FC_DATAUTO0_VSD_MASK);
-}
-
-static void hdmi_set_cts_n(struct dw_hdmi *hdmi, unsigned int cts,
-			   unsigned int n)
-{
-	/* Must be set/cleared first */
-	hdmi_modb(hdmi, 0, HDMI_AUD_CTS3_CTS_MANUAL, HDMI_AUD_CTS3);
-
-	/* nshift factor = 0 */
-	hdmi_modb(hdmi, 0, HDMI_AUD_CTS3_N_SHIFT_MASK, HDMI_AUD_CTS3);
-
-	hdmi_writeb(hdmi, ((cts >> 16) & HDMI_AUD_CTS3_AUDCTS19_16_MASK) |
-		    HDMI_AUD_CTS3_CTS_MANUAL, HDMI_AUD_CTS3);
-	hdmi_writeb(hdmi, (cts >> 8) & 0xff, HDMI_AUD_CTS2);
-	hdmi_writeb(hdmi, cts & 0xff, HDMI_AUD_CTS1);
-
-	hdmi_writeb(hdmi, (n >> 16) & 0x0f, HDMI_AUD_N3);
-	hdmi_writeb(hdmi, (n >> 8) & 0xff, HDMI_AUD_N2);
-	hdmi_writeb(hdmi, n & 0xff, HDMI_AUD_N1);
-}
-
-static int hdmi_match_tmds_n_table(struct dw_hdmi *hdmi,
-				   unsigned long pixel_clk,
-				   unsigned long freq)
-{
-	const struct dw_hdmi_plat_data *plat_data = hdmi->plat_data;
-	const struct dw_hdmi_audio_tmds_n *tmds_n = NULL;
-	int i;
-
-	if (plat_data->tmds_n_table) {
-		for (i = 0; plat_data->tmds_n_table[i].tmds != 0; i++) {
-			if (pixel_clk == plat_data->tmds_n_table[i].tmds) {
-				tmds_n = &plat_data->tmds_n_table[i];
-				break;
-			}
-		}
-	}
-
-	if (!tmds_n) {
-		for (i = 0; common_tmds_n_table[i].tmds != 0; i++) {
-			if (pixel_clk == common_tmds_n_table[i].tmds) {
-				tmds_n = &common_tmds_n_table[i];
-				break;
-			}
-		}
-	}
-
-	if (!tmds_n)
-		return -ENOENT;
-
-	switch (freq) {
-	case 32000:
-		return tmds_n->n_32k;
-	case 44100:
-	case 88200:
-	case 176400:
-		return (freq / 44100) * tmds_n->n_44k1;
-	case 48000:
-	case 96000:
-	case 192000:
-		return (freq / 48000) * tmds_n->n_48k;
-	default:
-		return -ENOENT;
-	}
-}
-
-static u64 hdmi_audio_math_diff(unsigned int freq, unsigned int n,
-				unsigned int pixel_clk)
-{
-	u64 final, diff;
-	u64 cts;
-
-	final = (u64)pixel_clk * n;
-
-	cts = final;
-	do_div(cts, 128 * freq);
-
-	diff = final - (u64)cts * (128 * freq);
-
-	return diff;
-}
-
-static unsigned int hdmi_compute_n(struct dw_hdmi *hdmi,
-				   unsigned long pixel_clk,
-				   unsigned long freq)
-{
-	unsigned int min_n = DIV_ROUND_UP((128 * freq), 1500);
-	unsigned int max_n = (128 * freq) / 300;
-	unsigned int ideal_n = (128 * freq) / 1000;
-	unsigned int best_n_distance = ideal_n;
-	unsigned int best_n = 0;
-	u64 best_diff = U64_MAX;
-	int n;
-
-	/* If the ideal N could satisfy the audio math, then just take it */
-	if (hdmi_audio_math_diff(freq, ideal_n, pixel_clk) == 0)
-		return ideal_n;
-
-	for (n = min_n; n <= max_n; n++) {
-		u64 diff = hdmi_audio_math_diff(freq, n, pixel_clk);
-
-		if (diff < best_diff || (diff == best_diff &&
-					 abs(n - ideal_n) < best_n_distance)) {
-			best_n = n;
-			best_diff = diff;
-			best_n_distance = abs(best_n - ideal_n);
-		}
-
-		/*
-		 * The best N already satisfy the audio math, and also be
-		 * the closest value to ideal N, so just cut the loop.
-		 */
-		if ((best_diff == 0) && (abs(n - ideal_n) > best_n_distance))
-			break;
-	}
-
-	return best_n;
-}
-
-static unsigned int hdmi_find_n(struct dw_hdmi *hdmi, unsigned long pixel_clk,
-				unsigned long sample_rate)
-{
-	int n;
-
-	n = hdmi_match_tmds_n_table(hdmi, pixel_clk, sample_rate);
-	if (n > 0)
-		return n;
-
-	printf("Rate %lu missing; compute N dynamically\n",
-	       pixel_clk);
-
-	return hdmi_compute_n(hdmi, pixel_clk, sample_rate);
-}
-
-static
-void hdmi_set_clk_regenerator(struct dw_hdmi *hdmi, unsigned long pixel_clk,
-			      unsigned int sample_rate)
-{
-	unsigned long ftdms = pixel_clk;
-	unsigned int n, cts;
-	u64 tmp;
-
-	n = hdmi_find_n(hdmi, pixel_clk, sample_rate);
-
-	/*
-	 * Compute the CTS value from the N value.  Note that CTS and N
-	 * can be up to 20 bits in total, so we need 64-bit math.  Also
-	 * note that our TDMS clock is not fully accurate; it is accurate
-	 * to kHz.  This can introduce an unnecessary remainder in the
-	 * calculation below, so we don't try to warn about that.
-	 */
-	tmp = (u64)ftdms * n;
-	do_div(tmp, 128 * sample_rate);
-	cts = tmp;
-
-	printf("%s: fs=%uHz ftdms=%lu.%03luMHz N=%d cts=%d\n", __func__,
-	       sample_rate, ftdms / 1000000, (ftdms / 1000) % 1000, n, cts);
-
-	hdmi->audio_n = n;
-	hdmi->audio_cts = cts;
-	hdmi_set_cts_n(hdmi, cts, hdmi->audio_enable ? n : 0);
-}
-
-static void hdmi_clk_regenerator_update_pixel_clock(struct dw_hdmi *hdmi)
-{
-	hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
-				 hdmi->sample_rate);
-}
-
-static void hdmi_enable_audio_clk(struct dw_hdmi *hdmi)
-{
-	hdmi_modb(hdmi, 0, HDMI_MC_CLKDIS_AUDCLK_DISABLE, HDMI_MC_CLKDIS);
-}
-
-void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate)
-{
-	hdmi->sample_rate = rate;
-	hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
-				 hdmi->sample_rate);
-}
-
-static int dw_hdmi_hdcp_load_key(struct dw_hdmi *hdmi)
-{
-	int i, j, ret, val;
-	struct hdcp_keys *hdcp_keys;
-
-	val = sizeof(*hdcp_keys);
-	hdcp_keys = malloc(val);
-	if (!hdcp_keys)
-		return -ENOMEM;
-
-	memset(hdcp_keys, 0, val);
-
-	ret = vendor_storage_read(HDMI_HDCP1X_ID, hdcp_keys, val);
-	if (ret < val) {
-		printf("HDCP: read size %d\n", ret);
-		free(hdcp_keys);
-		return -EINVAL;
-	}
-
-	if (hdcp_keys->KSV[0] == 0x00 &&
-	    hdcp_keys->KSV[1] == 0x00 &&
-	    hdcp_keys->KSV[2] == 0x00 &&
-	    hdcp_keys->KSV[3] == 0x00 &&
-	    hdcp_keys->KSV[4] == 0x00) {
-		printf("HDCP: Invalid hdcp key\n");
-		free(hdcp_keys);
-		return -EINVAL;
-	}
-
-	/* Disable decryption logic */
-	hdmi_writeb(hdmi, 0, HDMI_HDCPREG_RMCTL);
-	/* Poll untile DPK write is allowed */
-	do {
-		val = hdmi_readb(hdmi, HDMI_HDCPREG_RMSTS);
-	} while ((val & DPK_WR_OK_STS) == 0);
-
-	hdmi_writeb(hdmi, 0, HDMI_HDCPREG_DPK6);
-	hdmi_writeb(hdmi, 0, HDMI_HDCPREG_DPK5);
-
-	/* The useful data in ksv should be 5 byte */
-	for (i = 4; i >= 0; i--)
-		hdmi_writeb(hdmi, hdcp_keys->KSV[i], HDMI_HDCPREG_DPK0 + i);
-	/* Poll untile DPK write is allowed */
-	do {
-		val = hdmi_readb(hdmi, HDMI_HDCPREG_RMSTS);
-	} while ((val & DPK_WR_OK_STS) == 0);
-
-	/* Enable decryption logic */
-	hdmi_writeb(hdmi, 1, HDMI_HDCPREG_RMCTL);
-	hdmi_writeb(hdmi, hdcp_keys->seeds[0], HDMI_HDCPREG_SEED1);
-	hdmi_writeb(hdmi, hdcp_keys->seeds[1], HDMI_HDCPREG_SEED0);
-
-	/* Write encrypt device private key */
-	for (i = 0; i < DW_HDMI_HDCP_DPK_LEN - 6; i += 7) {
-		for (j = 6; j >= 0; j--)
-			hdmi_writeb(hdmi, hdcp_keys->devicekey[i + j],
-				    HDMI_HDCPREG_DPK0 + j);
-		do {
-			val = hdmi_readb(hdmi, HDMI_HDCPREG_RMSTS);
-		} while ((val & DPK_WR_OK_STS) == 0);
-	}
-
-	free(hdcp_keys);
-	return 0;
-}
-
-static void hdmi_tx_hdcp_config(struct dw_hdmi *hdmi,
-				const struct drm_display_mode *mode)
-{
-	u8 vsync_pol, hsync_pol, data_pol, hdmi_dvi;
-
-	if (!hdmi->hdcp1x_enable)
-		return;
-
-	/* Configure the video polarity */
-	vsync_pol = mode->flags & DRM_MODE_FLAG_PVSYNC ?
-		    HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_HIGH :
-		    HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_LOW;
-	hsync_pol = mode->flags & DRM_MODE_FLAG_PHSYNC ?
-		    HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_HIGH :
-		    HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_LOW;
-	data_pol = HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH;
-	hdmi_modb(hdmi, vsync_pol | hsync_pol | data_pol,
-		  HDMI_A_VIDPOLCFG_VSYNCPOL_MASK |
-		  HDMI_A_VIDPOLCFG_HSYNCPOL_MASK |
-		  HDMI_A_VIDPOLCFG_DATAENPOL_MASK,
-		  HDMI_A_VIDPOLCFG);
-
-	/* Config the display mode */
-	hdmi_dvi = hdmi->sink_is_hdmi ? HDMI_A_HDCPCFG0_HDMIDVI_HDMI :
-		   HDMI_A_HDCPCFG0_HDMIDVI_DVI;
-	hdmi_modb(hdmi, hdmi_dvi, HDMI_A_HDCPCFG0_HDMIDVI_MASK,
-		  HDMI_A_HDCPCFG0);
-
-	if (!(hdmi_readb(hdmi, HDMI_HDCPREG_RMSTS) & 0x3f))
-		dw_hdmi_hdcp_load_key(hdmi);
-
-	hdmi_modb(hdmi, HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE,
-		  HDMI_FC_INVIDCONF_HDCP_KEEPOUT_MASK,
-		  HDMI_FC_INVIDCONF);
-
-	if (hdmi_readb(hdmi, HDMI_CONFIG1_ID) & HDMI_A_HDCP22_MASK) {
-		hdmi_modb(hdmi, HDMI_HDCP2_OVR_ENABLE |
-			  HDMI_HDCP2_FORCE_DISABLE,
-			  HDMI_HDCP2_OVR_EN_MASK |
-			  HDMI_HDCP2_FORCE_MASK,
-			  HDMI_HDCP2REG_CTRL);
-		hdmi_writeb(hdmi, 0xff, HDMI_HDCP2REG_MASK);
-		hdmi_writeb(hdmi, 0xff, HDMI_HDCP2REG_MUTE);
-	}
-
-	hdmi_writeb(hdmi, 0x40, HDMI_A_OESSWCFG);
-		    hdmi_modb(hdmi, HDMI_A_HDCPCFG0_BYPENCRYPTION_DISABLE |
-		    HDMI_A_HDCPCFG0_EN11FEATURE_DISABLE |
-		    HDMI_A_HDCPCFG0_SYNCRICHECK_ENABLE,
-		    HDMI_A_HDCPCFG0_BYPENCRYPTION_MASK |
-		    HDMI_A_HDCPCFG0_EN11FEATURE_MASK |
-		    HDMI_A_HDCPCFG0_SYNCRICHECK_MASK, HDMI_A_HDCPCFG0);
-
-	hdmi_modb(hdmi, HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_ENABLE |
-		  HDMI_A_HDCPCFG1_PH2UPSHFTENC_ENABLE,
-		  HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_MASK |
-		  HDMI_A_HDCPCFG1_PH2UPSHFTENC_MASK, HDMI_A_HDCPCFG1);
-
-	/* Reset HDCP Engine */
-	if (hdmi_readb(hdmi, HDMI_MC_CLKDIS) & HDMI_MC_CLKDIS_HDCPCLK_MASK) {
-		hdmi_modb(hdmi, HDMI_A_HDCPCFG1_SWRESET_ASSERT,
-			  HDMI_A_HDCPCFG1_SWRESET_MASK, HDMI_A_HDCPCFG1);
-	}
-
-	hdmi_writeb(hdmi, 0x00, HDMI_A_APIINTMSK);
-	hdmi_modb(hdmi, HDMI_A_HDCPCFG0_RXDETECT_ENABLE,
-		  HDMI_A_HDCPCFG0_RXDETECT_MASK, HDMI_A_HDCPCFG0);
-
-	hdmi_modb(hdmi, HDMI_MC_CLKDIS_HDCPCLK_ENABLE,
-		  HDMI_MC_CLKDIS_HDCPCLK_MASK, HDMI_MC_CLKDIS);
-
-	printf("%s success\n", __func__);
-}
-
-static int dw_hdmi_setup(struct dw_hdmi *hdmi,
-			 struct drm_display_mode *mode,
-			 struct display_state *state)
-{
-	int ret;
-	void *data = hdmi->plat_data->phy_data;
-
-	hdmi_disable_overflow_interrupts(hdmi);
-	if (!hdmi->vic)
-		printf("Non-CEA mode used in HDMI\n");
-	else
-		printf("CEA mode used vic=%d\n", hdmi->vic);
-
-	if (hdmi->plat_data->get_enc_out_encoding)
-		hdmi->hdmi_data.enc_out_encoding =
-			hdmi->plat_data->get_enc_out_encoding(data);
-	else if (hdmi->vic == 6 || hdmi->vic == 7 ||
-		 hdmi->vic == 21 || hdmi->vic == 22 ||
-		 hdmi->vic == 2 || hdmi->vic == 3 ||
-		 hdmi->vic == 17 || hdmi->vic == 18)
-		hdmi->hdmi_data.enc_out_encoding = V4L2_YCBCR_ENC_601;
-	else
-		hdmi->hdmi_data.enc_out_encoding = V4L2_YCBCR_ENC_709;
-
-	if (mode->flags & DRM_MODE_FLAG_DBLCLK) {
-		hdmi->hdmi_data.video_mode.mpixelrepetitionoutput = 1;
-		hdmi->hdmi_data.video_mode.mpixelrepetitioninput = 1;
-	} else {
-		hdmi->hdmi_data.video_mode.mpixelrepetitionoutput = 0;
-		hdmi->hdmi_data.video_mode.mpixelrepetitioninput = 0;
-	}
-
-	/* TOFIX: Get input encoding from plat data or fallback to none */
-	if (hdmi->plat_data->get_enc_in_encoding)
-		hdmi->hdmi_data.enc_in_encoding =
-			hdmi->plat_data->get_enc_in_encoding(data);
-	else if (hdmi->plat_data->input_bus_encoding)
-		hdmi->hdmi_data.enc_in_encoding =
-			hdmi->plat_data->input_bus_encoding;
-	else
-		hdmi->hdmi_data.enc_in_encoding = V4L2_YCBCR_ENC_DEFAULT;
-
-	if (hdmi->plat_data->get_quant_range)
-		hdmi->hdmi_data.quant_range =
-			hdmi->plat_data->get_quant_range(data);
-	else
-		hdmi->hdmi_data.quant_range = HDMI_QUANTIZATION_RANGE_DEFAULT;
-
-	/*
-	 * According to the dw-hdmi specification 6.4.2
-	 * vp_pr_cd[3:0]:
-	 * 0000b: No pixel repetition (pixel sent only once)
-	 * 0001b: Pixel sent two times (pixel repeated once)
-	 */
-	hdmi->hdmi_data.pix_repet_factor =
-		(mode->flags & DRM_MODE_FLAG_DBLCLK) ? 1 : 0;
-	hdmi->hdmi_data.video_mode.mdataenablepolarity = true;
-
-	/* HDMI Initialization Step B.1 */
-	hdmi_av_composer(hdmi, mode);
-
-	/* HDMI Initialization Step B.2 */
-	ret = hdmi->phy.ops->init(hdmi, state);
-	if (ret)
-		return ret;
-	hdmi->phy.enabled = true;
-
-	/* HDMI Initializateion Step B.3 */
-	dw_hdmi_enable_video_path(hdmi);
-
-	/* HDMI Initialization Step E - Configure audio */
-	if (hdmi->sink_has_audio) {
-		printf("sink has audio support\n");
-		hdmi_clk_regenerator_update_pixel_clock(hdmi);
-		hdmi_enable_audio_clk(hdmi);
-	}
-
-	/* not for DVI mode */
-	if (hdmi->sink_is_hdmi) {
-		/* HDMI Initialization Step F - Configure AVI InfoFrame */
-		hdmi_config_AVI(hdmi, mode);
-		hdmi_config_vendor_specific_infoframe(hdmi, mode);
-		hdmi_modb(hdmi, HDMI_A_HDCPCFG0_HDMIDVI_HDMI,
-			  HDMI_A_HDCPCFG0_HDMIDVI_MASK,
-			  HDMI_A_HDCPCFG0);
-	} else {
-		hdmi_modb(hdmi, HDMI_A_HDCPCFG0_HDMIDVI_DVI,
-			  HDMI_A_HDCPCFG0_HDMIDVI_MASK,
-			  HDMI_A_HDCPCFG0);
-		printf("%s DVI mode\n", __func__);
-	}
-
-	hdmi_video_packetize(hdmi);
-	hdmi_video_csc(hdmi);
-	hdmi_video_sample(hdmi);
-	hdmi_tx_hdcp_config(hdmi, mode);
-	dw_hdmi_clear_overflow(hdmi);
-
-	return 0;
-}
-
-int dw_hdmi_detect_hotplug(struct dw_hdmi *hdmi,
-			   struct display_state *state)
-{
-	return hdmi->phy.ops->read_hpd(hdmi, state);
-}
-
-static int dw_hdmi_set_reg_wr(struct dw_hdmi *hdmi)
-{
-	switch (hdmi->io_width) {
-	case 4:
-		hdmi->write = dw_hdmi_writel;
-		hdmi->read = dw_hdmi_readl;
-		break;
-	case 1:
-		hdmi->write = dw_hdmi_writeb;
-		hdmi->read = dw_hdmi_readb;
-		break;
-	default:
-		printf("reg-io-width must be 1 or 4\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static void initialize_hdmi_mutes(struct dw_hdmi *hdmi)
-{
-	/*mute unnecessary interrupt, only enable hpd */
-	hdmi_writeb(hdmi, 0xff, HDMI_FC_MASK0);
-	hdmi_writeb(hdmi, 0xff, HDMI_FC_MASK1);
-	hdmi_writeb(hdmi, 0xff, HDMI_FC_MASK2);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT0);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT1);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT2);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_AS_STAT0);
-	hdmi_writeb(hdmi, 0xfe, HDMI_IH_MUTE_PHY_STAT0);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_I2CM_STAT0);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_CEC_STAT0);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_VP_STAT0);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_I2CMPHY_STAT0);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_AHBDMAAUD_STAT0);
-	hdmi_writeb(hdmi, 0xf1, HDMI_PHY_MASK0);
-
-	/*Force output black*/
-	dw_hdmi_writel(hdmi, 0x00, HDMI_FC_DBGTMDS2);
-	dw_hdmi_writel(hdmi, 0x00, HDMI_FC_DBGTMDS1);
-	dw_hdmi_writel(hdmi, 0x00, HDMI_FC_DBGTMDS0);
-}
-
-static void dw_hdmi_dev_init(struct dw_hdmi *hdmi)
-{
-	hdmi->version = (hdmi_readb(hdmi, HDMI_DESIGN_ID) << 8)
-		      | (hdmi_readb(hdmi, HDMI_REVISION_ID) << 0);
-
-	initialize_hdmi_mutes(hdmi);
-}
-
-static void dw_hdmi_i2c_set_divs(struct dw_hdmi *hdmi)
-{
-	unsigned long low_ns, high_ns;
-	unsigned long div_low, div_high;
-
-	/* Standard-mode */
-	if (hdmi->i2c->scl_high_ns < 4000)
-		high_ns = 4708;
-	else
-		high_ns = hdmi->i2c->scl_high_ns;
-
-	if (hdmi->i2c->scl_low_ns < 4700)
-		low_ns = 4916;
-	else
-		low_ns = hdmi->i2c->scl_low_ns;
-
-	div_low = (24000 * low_ns) / 1000000;
-	if ((24000 * low_ns) % 1000000)
-		div_low++;
-
-	div_high = (24000 * high_ns) / 1000000;
-	if ((24000 * high_ns) % 1000000)
-		div_high++;
-
-	/* Maximum divider supported by hw is 0xffff */
-	if (div_low > 0xffff)
-		div_low = 0xffff;
-
-	if (div_high > 0xffff)
-		div_high = 0xffff;
-
-	hdmi_writeb(hdmi, div_high & 0xff, HDMI_I2CM_SS_SCL_HCNT_0_ADDR);
-	hdmi_writeb(hdmi, (div_high >> 8) & 0xff,
-		    HDMI_I2CM_SS_SCL_HCNT_1_ADDR);
-	hdmi_writeb(hdmi, div_low & 0xff, HDMI_I2CM_SS_SCL_LCNT_0_ADDR);
-	hdmi_writeb(hdmi, (div_low >> 8) & 0xff,
-		    HDMI_I2CM_SS_SCL_LCNT_1_ADDR);
-}
-
-static void dw_hdmi_i2c_init(struct dw_hdmi *hdmi)
-{
-	/* Software reset */
-	hdmi_writeb(hdmi, 0x00, HDMI_I2CM_SOFTRSTZ);
-
-	/* Set Standard Mode speed */
-	hdmi_modb(hdmi, HDMI_I2CM_DIV_STD_MODE,
-		  HDMI_I2CM_DIV_FAST_STD_MODE, HDMI_I2CM_DIV);
-
-	/* Set done, not acknowledged and arbitration interrupt polarities */
-	hdmi_writeb(hdmi, HDMI_I2CM_INT_DONE_POL, HDMI_I2CM_INT);
-	hdmi_writeb(hdmi, HDMI_I2CM_CTLINT_NAC_POL | HDMI_I2CM_CTLINT_ARB_POL,
-		    HDMI_I2CM_CTLINT);
-
-	/* Clear DONE and ERROR interrupts */
-	hdmi_writeb(hdmi, HDMI_IH_I2CM_STAT0_ERROR | HDMI_IH_I2CM_STAT0_DONE,
-		    HDMI_IH_I2CM_STAT0);
-
-	/* Mute DONE and ERROR interrupts */
-	hdmi_writeb(hdmi, HDMI_IH_I2CM_STAT0_ERROR | HDMI_IH_I2CM_STAT0_DONE,
-		    HDMI_IH_MUTE_I2CM_STAT0);
-
-	/* set SDA high level holding time */
-	hdmi_writeb(hdmi, 0x48, HDMI_I2CM_SDA_HOLD);
-
-	dw_hdmi_i2c_set_divs(hdmi);
-}
-
-void dw_hdmi_audio_enable(struct dw_hdmi *hdmi)
-{
-	hdmi->audio_enable = true;
-	hdmi_set_cts_n(hdmi, hdmi->audio_cts, hdmi->audio_n);
-}
-
-void dw_hdmi_audio_disable(struct dw_hdmi *hdmi)
-{
-	hdmi->audio_enable = false;
-	hdmi_set_cts_n(hdmi, hdmi->audio_cts, 0);
-}
-
-int rockchip_dw_hdmi_pre_init(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-
-	conn_state->type = DRM_MODE_CONNECTOR_HDMIA;
-
-	return 0;
-}
-
-int rockchip_dw_hdmi_init(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	const struct rockchip_connector *connector = conn_state->connector;
-	const struct dw_hdmi_plat_data *pdata = connector->data;
-	struct crtc_state *crtc_state = &state->crtc_state;
-	struct dw_hdmi *hdmi;
-	struct drm_display_mode *mode_buf;
-	ofnode hdmi_node = conn_state->node;
-	u32 val;
-	struct device_node *ddc_node;
-
-	hdmi = malloc(sizeof(struct dw_hdmi));
-	if (!hdmi)
-		return -ENOMEM;
-
-	memset(hdmi, 0, sizeof(struct dw_hdmi));
-	mode_buf = malloc(MODE_LEN * sizeof(struct drm_display_mode));
-	if (!mode_buf)
-		return -ENOMEM;
-	hdmi->id = of_alias_get_id(ofnode_to_np(hdmi_node), "hdmi");
-	if (hdmi->id < 0)
-		hdmi->id = 0;
-	conn_state->disp_info  = rockchip_get_disp_info(conn_state->type, hdmi->id);
-
-	memset(mode_buf, 0, MODE_LEN * sizeof(struct drm_display_mode));
-
-	hdmi->regs = dev_read_addr_ptr(conn_state->dev);
-	hdmi->io_width = ofnode_read_s32_default(hdmi_node, "reg-io-width", -1);
-
-	if (ofnode_read_bool(hdmi_node, "scramble-low-rates"))
-		hdmi->scramble_low_rates = true;
-
-	if (ofnode_read_bool(hdmi_node, "hdcp1x-enable"))
-		hdmi->hdcp1x_enable = true;
-	else
-		hdmi->hdcp1x_enable = false;
-
-	ddc_node = of_parse_phandle(ofnode_to_np(hdmi_node), "ddc-i2c-bus", 0);
-	if (ddc_node) {
-		uclass_get_device_by_ofnode(UCLASS_I2C, np_to_ofnode(ddc_node),
-					    &hdmi->adap.i2c_bus);
-		if (hdmi->adap.i2c_bus)
-			hdmi->adap.ops = i2c_get_ops(hdmi->adap.i2c_bus);
-	}
-
-	hdmi->grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
-	if (hdmi->grf <= 0) {
-		printf("%s: Get syscon grf failed (ret=%p)\n",
-		       __func__, hdmi->grf);
-		return -ENXIO;
-	}
-
-	dw_hdmi_set_reg_wr(hdmi);
-
-	if (pdata->grf_vop_sel_reg) {
-		if (crtc_state->crtc_id)
-			val = ((1 << pdata->vop_sel_bit) |
-			       (1 << (16 + pdata->vop_sel_bit)));
-		else
-			val = ((0 << pdata->vop_sel_bit) |
-			       (1 << (16 + pdata->vop_sel_bit)));
-		writel(val, hdmi->grf + pdata->grf_vop_sel_reg);
-	}
-
-	hdmi->i2c = malloc(sizeof(struct dw_hdmi_i2c));
-	if (!hdmi->i2c)
-		return -ENOMEM;
-	hdmi->adap.ddc_xfer = dw_hdmi_i2c_xfer;
-
-	/*
-	 * Read high and low time from device tree. If not available use
-	 * the default timing scl clock rate is about 99.6KHz.
-	 */
-	hdmi->i2c->scl_high_ns =
-		ofnode_read_s32_default(hdmi_node,
-					"ddc-i2c-scl-high-time-ns", 4708);
-	hdmi->i2c->scl_low_ns =
-		ofnode_read_s32_default(hdmi_node,
-					"ddc-i2c-scl-low-time-ns", 4916);
-
-	dw_hdmi_i2c_init(hdmi);
-	conn_state->output_if |= VOP_OUTPUT_IF_HDMI0;
-	conn_state->output_mode = ROCKCHIP_OUT_MODE_AAAA;
-
-	hdmi->dev_type = pdata->dev_type;
-	hdmi->plat_data = pdata;
-	hdmi->edid_data.mode_buf = mode_buf;
-	hdmi->sample_rate = 48000;
-
-	conn_state->private = hdmi;
-	dw_hdmi_set_iomux(hdmi->grf, hdmi->dev_type);
-	dw_hdmi_detect_phy(hdmi);
-	dw_hdmi_dev_init(hdmi);
-
-	return 0;
-}
-
-void rockchip_dw_hdmi_deinit(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	struct dw_hdmi *hdmi = conn_state->private;
-
-	if (hdmi->i2c)
-		free(hdmi->i2c);
-	if (hdmi->edid_data.mode_buf)
-		free(hdmi->edid_data.mode_buf);
-	if (hdmi)
-		free(hdmi);
-}
-
-int rockchip_dw_hdmi_prepare(struct display_state *state)
-{
-	return 0;
-}
-
-int rockchip_dw_hdmi_enable(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	struct drm_display_mode *mode = &conn_state->mode;
-	struct dw_hdmi *hdmi = conn_state->private;
-
-	if (!hdmi)
-		return -EFAULT;
-
-	/* Store the display mode for plugin/DKMS poweron events */
-	memcpy(&hdmi->previous_mode, mode, sizeof(hdmi->previous_mode));
-
-	dw_hdmi_setup(hdmi, mode, state);
-
-	return 0;
-}
-
-int rockchip_dw_hdmi_disable(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	struct dw_hdmi *hdmi = conn_state->private;
-
-	dw_hdmi_disable(hdmi, state);
-	return 0;
-}
-
-int rockchip_dw_hdmi_get_timing(struct display_state *state)
-{
-	int ret, i;
-	struct connector_state *conn_state = &state->conn_state;
-	struct drm_display_mode *mode = &conn_state->mode;
-	struct dw_hdmi *hdmi = conn_state->private;
-	struct edid *edid = (struct edid *)conn_state->edid;
-	unsigned int bus_format;
-	unsigned long enc_out_encoding;
-	struct overscan *overscan = &conn_state->overscan;
-	const u8 def_modes_vic[6] = {4, 16, 2, 17, 31, 19};
-
-	if (!hdmi)
-		return -EFAULT;
-
-	ret = drm_do_get_edid(&hdmi->adap, conn_state->edid);
-
-	if (!ret) {
-		hdmi->sink_is_hdmi =
-			drm_detect_hdmi_monitor(edid);
-		hdmi->sink_has_audio = drm_detect_monitor_audio(edid);
-		ret = drm_add_edid_modes(&hdmi->edid_data, conn_state->edid);
-	}
-	if (ret < 0) {
-		hdmi->sink_is_hdmi = true;
-		hdmi->sink_has_audio = true;
-		do_cea_modes(&hdmi->edid_data, def_modes_vic,
-			     sizeof(def_modes_vic));
-		hdmi->edid_data.preferred_mode = &hdmi->edid_data.mode_buf[0];
-		printf("failed to get edid\n");
-	}
-	drm_rk_filter_whitelist(&hdmi->edid_data);
-	if (hdmi->phy.ops->mode_valid)
-		hdmi->phy.ops->mode_valid(hdmi, state);
-	drm_mode_max_resolution_filter(&hdmi->edid_data,
-				       &state->crtc_state.max_output);
-	if (!drm_mode_prune_invalid(&hdmi->edid_data)) {
-		printf("can't find valid hdmi mode\n");
-		return -EINVAL;
-	}
-
-	for (i = 0; i < hdmi->edid_data.modes; i++)
-		hdmi->edid_data.mode_buf[i].vrefresh =
-			drm_mode_vrefresh(&hdmi->edid_data.mode_buf[i]);
-
-	drm_mode_sort(&hdmi->edid_data);
-	drm_rk_selete_output(&hdmi->edid_data, conn_state, &bus_format,
-			     overscan, hdmi->dev_type);
-
-	*mode = *hdmi->edid_data.preferred_mode;
-	hdmi->vic = drm_match_cea_mode(mode);
-
-	printf("mode:%dx%d\n", mode->hdisplay, mode->vdisplay);
-	conn_state->bus_format = bus_format;
-	hdmi->hdmi_data.enc_in_bus_format = bus_format;
-	hdmi->hdmi_data.enc_out_bus_format = bus_format;
-
-	switch (bus_format) {
-	case MEDIA_BUS_FMT_UYVY10_1X20:
-		conn_state->bus_format = MEDIA_BUS_FMT_YUV10_1X30;
-		hdmi->hdmi_data.enc_in_bus_format =
-			MEDIA_BUS_FMT_YUV10_1X30;
-		break;
-	case MEDIA_BUS_FMT_UYVY8_1X16:
-		conn_state->bus_format = MEDIA_BUS_FMT_YUV8_1X24;
-		hdmi->hdmi_data.enc_in_bus_format =
-			MEDIA_BUS_FMT_YUV8_1X24;
-		break;
-	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
-	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
-		conn_state->output_mode = ROCKCHIP_OUT_MODE_YUV420;
-		break;
-	}
-
-	if (hdmi->vic == 6 || hdmi->vic == 7 || hdmi->vic == 21 ||
-	    hdmi->vic == 22 || hdmi->vic == 2 || hdmi->vic == 3 ||
-	    hdmi->vic == 17 || hdmi->vic == 18)
-		enc_out_encoding = V4L2_YCBCR_ENC_601;
-	else
-		enc_out_encoding = V4L2_YCBCR_ENC_709;
-
-	if (enc_out_encoding == V4L2_YCBCR_ENC_BT2020)
-		conn_state->color_space = V4L2_COLORSPACE_BT2020;
-	else if (bus_format == MEDIA_BUS_FMT_RGB888_1X24 ||
-		 bus_format == MEDIA_BUS_FMT_RGB101010_1X30)
-		conn_state->color_space = V4L2_COLORSPACE_DEFAULT;
-	else if (enc_out_encoding == V4L2_YCBCR_ENC_709)
-		conn_state->color_space = V4L2_COLORSPACE_REC709;
-	else
-		conn_state->color_space = V4L2_COLORSPACE_SMPTE170M;
-
-	return 0;
-}
-
-int rockchip_dw_hdmi_detect(struct display_state *state)
-{
-	int ret;
-	struct connector_state *conn_state = &state->conn_state;
-	struct dw_hdmi *hdmi = conn_state->private;
-
-	if (!hdmi)
-		return -EFAULT;
-
-	ret = dw_hdmi_detect_hotplug(hdmi, state);
-
-	return ret;
-}
-
-int rockchip_dw_hdmi_get_edid(struct display_state *state)
-{
-	int ret;
-	struct connector_state *conn_state = &state->conn_state;
-	struct dw_hdmi *hdmi = conn_state->private;
-
-	ret = drm_do_get_edid(&hdmi->adap, conn_state->edid);
-
-	return ret;
-}
-
-int inno_dw_hdmi_phy_init(struct dw_hdmi *hdmi, void *data)
-{
-	struct display_state *state = (struct display_state *)data;
-	struct connector_state *conn_state = &state->conn_state;
-	u32 color_depth, bus_width;
-
-	color_depth =
-		hdmi_bus_fmt_color_depth(hdmi->hdmi_data.enc_out_bus_format);
-
-	if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format))
-		bus_width = color_depth / 2;
-	else if (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format))
-		bus_width = color_depth;
-	else
-		bus_width = 8;
-	rockchip_phy_set_bus_width(conn_state->phy, bus_width);
-	rockchip_phy_set_pll(conn_state->phy,
-			     conn_state->mode.crtc_clock * 1000);
-	if (hdmi->edid_data.display_info.hdmi.scdc.supported)
-		rockchip_dw_hdmi_scdc_set_tmds_rate(hdmi);
-	rockchip_phy_power_on(conn_state->phy);
-
-	return 0;
-}
-
-void inno_dw_hdmi_phy_disable(struct dw_hdmi *hdmi, void *data)
-{
-}
-
-enum drm_connector_status
-inno_dw_hdmi_phy_read_hpd(struct dw_hdmi *hdmi, void *data)
-{
-	enum drm_connector_status status;
-	struct display_state *state = (struct display_state *)data;
-
-	status = dw_hdmi_phy_read_hpd(hdmi, state);
-
-	if (hdmi->dev_type == RK3328_HDMI) {
-		if (status == connector_status_connected)
-			inno_dw_hdmi_set_domain(hdmi->grf, 1);
-		else
-			inno_dw_hdmi_set_domain(hdmi->grf, 0);
-	}
-
-	return status;
-}
-
-void inno_dw_hdmi_mode_valid(struct dw_hdmi *hdmi, void *data)
-{
-	struct display_state *state = (struct display_state *)data;
-	struct connector_state *conn_state = &state->conn_state;
-	struct hdmi_edid_data *edid_data = &hdmi->edid_data;
-	unsigned long rate;
-	int i, ret;
-	struct drm_display_mode *mode_buf = edid_data->mode_buf;
-
-	for (i = 0; i < edid_data->modes; i++) {
-		if (edid_data->mode_buf[i].invalid)
-			continue;
-		if (edid_data->mode_buf[i].flags & DRM_MODE_FLAG_DBLCLK)
-			rate = mode_buf[i].clock * 1000 * 2;
-		else
-			rate = mode_buf[i].clock * 1000;
-
-		/* Check whether mode is out of phy cfg range. */
-		ret = rockchip_phy_round_rate(conn_state->phy, rate);
-
-		if (ret < 0)
-			edid_data->mode_buf[i].invalid = true;
-	}
-}
+version https://git-lfs.github.com/spec/v1
+oid sha256:5f92cf6a5c8ff96c66c14d0e4bbd977a3a4dd903203ca7e15d43c2fd2b5382bd
+size 73688
diff --git a/u-boot/drivers/video/drm/inno_hdmi.c b/u-boot/drivers/video/drm/inno_hdmi.c
index f8bc0c9168..0d93fd1524 100644
--- a/u-boot/drivers/video/drm/inno_hdmi.c
+++ b/u-boot/drivers/video/drm/inno_hdmi.c
@@ -1,860 +1,3 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * (C) Copyright 2020 Rockchip Electronics Co., Ltd
- */
-#include <common.h>
-#include <clk.h>
-#include <syscon.h>
-#include <asm/io.h>
-#include <asm/arch-rockchip/clock.h>
-#include <dm/device.h>
-#include <dm/read.h>
-#include <linux/hdmi.h>
-#include <linux/media-bus-format.h>
-
-#include "inno_hdmi.h"
-#include "rockchip_connector.h"
-#include "rockchip_crtc.h"
-#include "rockchip_display.h"
-
-struct inno_hdmi_i2c {
-	u8			slave_reg;
-	u8			ddc_addr;
-	u8			segment_addr;
-	bool			is_regaddr;
-	bool			is_segment;
-
-	unsigned int		scl_high_ns;
-	unsigned int		scl_low_ns;
-};
-
-enum inno_hdmi_dev_type {
-	RK3036_HDMI,
-	RK3128_HDMI,
-};
-
-enum {
-	CSC_ITU601_16_235_TO_RGB_0_255_8BIT,
-	CSC_ITU601_0_255_TO_RGB_0_255_8BIT,
-	CSC_ITU709_16_235_TO_RGB_0_255_8BIT,
-	CSC_RGB_0_255_TO_ITU601_16_235_8BIT,
-	CSC_RGB_0_255_TO_ITU709_16_235_8BIT,
-	CSC_RGB_0_255_TO_RGB_16_235_8BIT,
-};
-
-static const char coeff_csc[][24] = {
-	/*
-	 * YUV2RGB:601 SD mode(Y[16:235], UV[16:240], RGB[0:255]):
-	 *   R = 1.164*Y + 1.596*V - 204
-	 *   G = 1.164*Y - 0.391*U - 0.813*V + 154
-	 *   B = 1.164*Y + 2.018*U - 258
-	 */
-	{
-		0x04, 0xa7, 0x00, 0x00, 0x06, 0x62, 0x02, 0xcc,
-		0x04, 0xa7, 0x11, 0x90, 0x13, 0x40, 0x00, 0x9a,
-		0x04, 0xa7, 0x08, 0x12, 0x00, 0x00, 0x03, 0x02
-	},
-	/*
-	 * YUV2RGB:601 SD mode(YUV[0:255],RGB[0:255]):
-	 *   R = Y + 1.402*V - 248
-	 *   G = Y - 0.344*U - 0.714*V + 135
-	 *   B = Y + 1.772*U - 227
-	 */
-	{
-		0x04, 0x00, 0x00, 0x00, 0x05, 0x9b, 0x02, 0xf8,
-		0x04, 0x00, 0x11, 0x60, 0x12, 0xdb, 0x00, 0x87,
-		0x04, 0x00, 0x07, 0x16, 0x00, 0x00, 0x02, 0xe3
-	},
-	/*
-	 * YUV2RGB:709 HD mode(Y[16:235],UV[16:240],RGB[0:255]):
-	 *   R = 1.164*Y + 1.793*V - 248
-	 *   G = 1.164*Y - 0.213*U - 0.534*V + 77
-	 *   B = 1.164*Y + 2.115*U - 289
-	 */
-	{
-		0x04, 0xa7, 0x00, 0x00, 0x07, 0x2c, 0x02, 0xf8,
-		0x04, 0xa7, 0x10, 0xda, 0x12, 0x22, 0x00, 0x4d,
-		0x04, 0xa7, 0x08, 0x74, 0x00, 0x00, 0x03, 0x21
-	},
-
-	/*
-	 * RGB2YUV:601 SD mode:
-	 *   Cb = -0.291G - 0.148R + 0.439B + 128
-	 *   Y  = 0.504G  + 0.257R + 0.098B + 16
-	 *   Cr = -0.368G + 0.439R - 0.071B + 128
-	 */
-	{
-		0x11, 0x5f, 0x01, 0x82, 0x10, 0x23, 0x00, 0x80,
-		0x02, 0x1c, 0x00, 0xa1, 0x00, 0x36, 0x00, 0x1e,
-		0x11, 0x29, 0x10, 0x59, 0x01, 0x82, 0x00, 0x80
-	},
-	/*
-	 * RGB2YUV:709 HD mode:
-	 *   Cb = - 0.338G - 0.101R + 0.439B + 128
-	 *   Y  = 0.614G   + 0.183R + 0.062B + 16
-	 *   Cr = - 0.399G + 0.439R - 0.040B + 128
-	 */
-	{
-		0x11, 0x98, 0x01, 0xc1, 0x10, 0x28, 0x00, 0x80,
-		0x02, 0x74, 0x00, 0xbb, 0x00, 0x3f, 0x00, 0x10,
-		0x11, 0x5a, 0x10, 0x67, 0x01, 0xc1, 0x00, 0x80
-	},
-	/*
-	 * RGB[0:255]2RGB[16:235]:
-	 *   R' = R x (235-16)/255 + 16;
-	 *   G' = G x (235-16)/255 + 16;
-	 *   B' = B x (235-16)/255 + 16;
-	 */
-	{
-		0x00, 0x00, 0x03, 0x6F, 0x00, 0x00, 0x00, 0x10,
-		0x03, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
-		0x00, 0x00, 0x00, 0x00, 0x03, 0x6F, 0x00, 0x10
-	},
-};
-
-struct hdmi_data_info {
-	int vic;
-	bool sink_is_hdmi;
-	bool sink_has_audio;
-	unsigned int enc_in_format;
-	unsigned int enc_out_format;
-	unsigned int colorimetry;
-};
-
-struct inno_hdmi_phy_config {
-	unsigned long mpixelclock;
-	u8 pre_emphasis;	/* pre-emphasis value */
-	u8 vlev_ctr;		/* voltage level control */
-};
-
-struct inno_hdmi_plat_data {
-	enum inno_hdmi_dev_type dev_type;
-	struct inno_hdmi_phy_config *phy_config;
-};
-
-struct inno_hdmi {
-	struct device *dev;
-	struct drm_device *drm_dev;
-	struct ddc_adapter adap;
-	struct hdmi_edid_data edid_data;
-	struct hdmi_data_info	hdmi_data;
-
-	struct clk pclk;
-	int vic;
-	void *regs;
-	void *grf;
-
-	struct inno_hdmi_i2c *i2c;
-
-	unsigned int tmds_rate;
-	const struct inno_hdmi_plat_data *plat_data;
-
-	unsigned int sample_rate;
-	unsigned int audio_cts;
-	unsigned int audio_n;
-	bool audio_enable;
-
-	struct drm_display_mode previous_mode;
-};
-
-static struct inno_hdmi_phy_config rk3036_hdmi_phy_config[] = {
-	/* pixelclk pre-emp vlev */
-	{ 74250000,  0x3f, 0xbb },
-	{ 165000000, 0x6f, 0xbb },
-	{ ~0UL,	     0x00, 0x00 }
-};
-
-static struct inno_hdmi_phy_config rk3128_hdmi_phy_config[] = {
-	/* pixelclk pre-emp vlev */
-	{ 74250000,  0x3f, 0xaa },
-	{ 165000000, 0x5f, 0xaa },
-	{ ~0UL,	     0x00, 0x00 }
-};
-
-static void hdmi_writeb(struct inno_hdmi *hdmi, u16 offset, u32 val)
-{
-	writel(val, hdmi->regs + (offset << 2));
-}
-
-static u32 hdmi_readb(struct inno_hdmi *hdmi, u16 offset)
-{
-	return readl(hdmi->regs + (offset << 2));
-}
-
-static void hdmi_modb(struct inno_hdmi *hdmi, u16 offset, u32 msk, u32 val)
-{
-	u32 temp = hdmi_readb(hdmi, offset) & ~msk;
-
-	temp |= val & msk;
-	hdmi_writeb(hdmi, offset, temp);
-}
-
-static void inno_hdmi_sys_power(struct inno_hdmi *hdmi, bool enable)
-{
-	if (enable)
-		hdmi_modb(hdmi, HDMI_SYS_CTRL, m_POWER, v_PWR_ON);
-	else
-		hdmi_modb(hdmi, HDMI_SYS_CTRL, m_POWER, v_PWR_OFF);
-}
-
-static void inno_hdmi_set_pwr_mode(struct inno_hdmi *hdmi, int mode)
-{
-	const struct inno_hdmi_phy_config *phy_config =
-						hdmi->plat_data->phy_config;
-
-	switch (mode) {
-	case NORMAL:
-		inno_hdmi_sys_power(hdmi, false);
-		for (; phy_config->mpixelclock != ~0UL; phy_config++)
-			if (hdmi->tmds_rate <= phy_config->mpixelclock)
-				break;
-		if (!phy_config->mpixelclock)
-			return;
-		hdmi_writeb(hdmi, HDMI_PHY_PRE_EMPHASIS,
-			    phy_config->pre_emphasis);
-		hdmi_writeb(hdmi, HDMI_PHY_DRIVER, phy_config->vlev_ctr);
-
-		hdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x15);
-		hdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x14);
-		hdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x10);
-
-		hdmi_writeb(hdmi, HDMI_PHY_CHG_PWR, 0x0f);
-		hdmi_writeb(hdmi, HDMI_PHY_SYNC, 0x00);
-		hdmi_writeb(hdmi, HDMI_PHY_SYNC, 0x01);
-		inno_hdmi_sys_power(hdmi, true);
-
-		break;
-
-	case LOWER_PWR:
-		inno_hdmi_sys_power(hdmi, false);
-		hdmi_writeb(hdmi, HDMI_PHY_DRIVER, 0x00);
-		hdmi_writeb(hdmi, HDMI_PHY_PRE_EMPHASIS, 0x00);
-		hdmi_writeb(hdmi, HDMI_PHY_CHG_PWR, 0x00);
-		hdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x15);
-
-		break;
-
-	default:
-		dev_err(hdmi->dev, "Unknown power mode %d\n", mode);
-	}
-}
-
-static void inno_hdmi_i2c_init(struct inno_hdmi *hdmi)
-{
-	int ddc_bus_freq;
-
-	ddc_bus_freq = (hdmi->tmds_rate >> 2) / HDMI_SCL_RATE;
-	hdmi_writeb(hdmi, DDC_BUS_FREQ_L, ddc_bus_freq & 0xFF);
-	hdmi_writeb(hdmi, DDC_BUS_FREQ_H, (ddc_bus_freq >> 8) & 0xFF);
-
-	/* Clear the EDID interrupt flag and mute the interrupt */
-	hdmi_writeb(hdmi, HDMI_INTERRUPT_MASK1, 0);
-	hdmi_writeb(hdmi, HDMI_INTERRUPT_STATUS1, m_INT_EDID_READY);
-}
-
-static void inno_hdmi_reset(struct inno_hdmi *hdmi)
-{
-	u32 val;
-	u32 msk;
-
-	hdmi_modb(hdmi, HDMI_SYS_CTRL, m_RST_DIGITAL, v_NOT_RST_DIGITAL);
-	udelay(100);
-
-	hdmi_modb(hdmi, HDMI_SYS_CTRL, m_RST_ANALOG, v_NOT_RST_ANALOG);
-	udelay(100);
-
-	msk = m_REG_CLK_INV | m_REG_CLK_SOURCE | m_POWER | m_INT_POL;
-	val = v_REG_CLK_INV | v_REG_CLK_SOURCE_SYS | v_PWR_ON | v_INT_POL_HIGH;
-
-	hdmi_modb(hdmi, HDMI_SYS_CTRL, msk, val);
-
-	inno_hdmi_set_pwr_mode(hdmi, NORMAL);
-}
-
-static int inno_hdmi_upload_frame(struct inno_hdmi *hdmi, int setup_rc,
-				  union hdmi_infoframe *frame, u32 frame_index,
-				  u32 mask, u32 disable, u32 enable)
-{
-	if (mask)
-		hdmi_modb(hdmi, HDMI_PACKET_SEND_AUTO, mask, disable);
-
-	hdmi_writeb(hdmi, HDMI_CONTROL_PACKET_BUF_INDEX, frame_index);
-
-	if (setup_rc >= 0) {
-		u8 packed_frame[HDMI_MAXIMUM_INFO_FRAME_SIZE];
-		ssize_t rc, i;
-
-		rc = hdmi_infoframe_pack(frame, packed_frame,
-					 sizeof(packed_frame));
-		if (rc < 0)
-			return rc;
-
-		for (i = 0; i < rc; i++)
-			hdmi_writeb(hdmi, HDMI_CONTROL_PACKET_ADDR + i,
-				    packed_frame[i]);
-
-		if (mask)
-			hdmi_modb(hdmi, HDMI_PACKET_SEND_AUTO, mask, enable);
-	}
-
-	return setup_rc;
-}
-
-static int inno_hdmi_config_video_vsi(struct inno_hdmi *hdmi,
-				      struct drm_display_mode *mode)
-{
-	union hdmi_infoframe frame;
-	int rc;
-
-	rc = drm_hdmi_vendor_infoframe_from_display_mode(&frame.vendor.hdmi,
-							 mode);
-
-	return inno_hdmi_upload_frame(hdmi, rc, &frame, INFOFRAME_VSI,
-		m_PACKET_VSI_EN, v_PACKET_VSI_EN(0), v_PACKET_VSI_EN(1));
-}
-
-static int inno_hdmi_config_video_avi(struct inno_hdmi *hdmi,
-				      struct drm_display_mode *mode)
-{
-	union hdmi_infoframe frame;
-	int rc;
-
-	rc = drm_hdmi_avi_infoframe_from_display_mode(&frame.avi, mode, false);
-
-	if (hdmi->hdmi_data.enc_out_format == HDMI_COLORSPACE_YUV444)
-		frame.avi.colorspace = HDMI_COLORSPACE_YUV444;
-	else if (hdmi->hdmi_data.enc_out_format == HDMI_COLORSPACE_YUV422)
-		frame.avi.colorspace = HDMI_COLORSPACE_YUV422;
-	else
-		frame.avi.colorspace = HDMI_COLORSPACE_RGB;
-
-	if (frame.avi.colorspace != HDMI_COLORSPACE_RGB)
-		frame.avi.colorimetry = hdmi->hdmi_data.colorimetry;
-
-	frame.avi.scan_mode = HDMI_SCAN_MODE_NONE;
-
-	return inno_hdmi_upload_frame(hdmi, rc, &frame, INFOFRAME_AVI, 0, 0, 0);
-}
-
-static int inno_hdmi_config_video_csc(struct inno_hdmi *hdmi)
-{
-	struct hdmi_data_info *data = &hdmi->hdmi_data;
-	int c0_c2_change = 0;
-	int csc_enable = 0;
-	int csc_mode = 0;
-	int auto_csc = 0;
-	int value;
-	int i;
-
-	/* Input video mode is SDR RGB24bit, data enable signal from external */
-	hdmi_writeb(hdmi, HDMI_VIDEO_CONTRL1, v_DE_EXTERNAL |
-		    v_VIDEO_INPUT_FORMAT(VIDEO_INPUT_SDR_RGB444));
-
-	/* Input color hardcode to RGB, and output color hardcode to RGB888 */
-	value = v_VIDEO_INPUT_BITS(VIDEO_INPUT_8BITS) |
-		v_VIDEO_OUTPUT_COLOR(0) |
-		v_VIDEO_INPUT_CSP(0);
-	hdmi_writeb(hdmi, HDMI_VIDEO_CONTRL2, value);
-
-	if (data->enc_in_format == data->enc_out_format) {
-		if (data->enc_in_format == HDMI_COLORSPACE_RGB ||
-		    data->enc_in_format >= HDMI_COLORSPACE_YUV444) {
-			value = v_SOF_DISABLE | v_COLOR_DEPTH_NOT_INDICATED(1);
-			hdmi_writeb(hdmi, HDMI_VIDEO_CONTRL3, value);
-
-			hdmi_modb(hdmi, HDMI_VIDEO_CONTRL,
-				  m_VIDEO_AUTO_CSC | m_VIDEO_C0_C2_SWAP,
-				  v_VIDEO_AUTO_CSC(AUTO_CSC_DISABLE) |
-				  v_VIDEO_C0_C2_SWAP(C0_C2_CHANGE_DISABLE));
-			return 0;
-		}
-	}
-
-	if (data->colorimetry == HDMI_COLORIMETRY_ITU_601) {
-		if (data->enc_in_format == HDMI_COLORSPACE_RGB &&
-		    data->enc_out_format == HDMI_COLORSPACE_YUV444) {
-			csc_mode = CSC_RGB_0_255_TO_ITU601_16_235_8BIT;
-			auto_csc = AUTO_CSC_DISABLE;
-			c0_c2_change = C0_C2_CHANGE_DISABLE;
-			csc_enable = v_CSC_ENABLE;
-		} else if ((data->enc_in_format == HDMI_COLORSPACE_YUV444) &&
-			   (data->enc_out_format == HDMI_COLORSPACE_RGB)) {
-			csc_mode = CSC_ITU601_16_235_TO_RGB_0_255_8BIT;
-			auto_csc = AUTO_CSC_ENABLE;
-			c0_c2_change = C0_C2_CHANGE_DISABLE;
-			csc_enable = v_CSC_DISABLE;
-		}
-	} else {
-		if (data->enc_in_format == HDMI_COLORSPACE_RGB &&
-		    data->enc_out_format == HDMI_COLORSPACE_YUV444) {
-			csc_mode = CSC_RGB_0_255_TO_ITU709_16_235_8BIT;
-			auto_csc = AUTO_CSC_DISABLE;
-			c0_c2_change = C0_C2_CHANGE_DISABLE;
-			csc_enable = v_CSC_ENABLE;
-		} else if ((data->enc_in_format == HDMI_COLORSPACE_YUV444) &&
-			   (data->enc_out_format == HDMI_COLORSPACE_RGB)) {
-			csc_mode = CSC_ITU709_16_235_TO_RGB_0_255_8BIT;
-			auto_csc = AUTO_CSC_ENABLE;
-			c0_c2_change = C0_C2_CHANGE_DISABLE;
-			csc_enable = v_CSC_DISABLE;
-		}
-	}
-
-	for (i = 0; i < 24; i++)
-		hdmi_writeb(hdmi, HDMI_VIDEO_CSC_COEF + i,
-			    coeff_csc[csc_mode][i]);
-
-	value = v_SOF_DISABLE | csc_enable | v_COLOR_DEPTH_NOT_INDICATED(1);
-	hdmi_writeb(hdmi, HDMI_VIDEO_CONTRL3, value);
-	hdmi_modb(hdmi, HDMI_VIDEO_CONTRL, m_VIDEO_AUTO_CSC |
-		  m_VIDEO_C0_C2_SWAP, v_VIDEO_AUTO_CSC(auto_csc) |
-		  v_VIDEO_C0_C2_SWAP(c0_c2_change));
-
-	return 0;
-}
-
-static int inno_hdmi_config_video_timing(struct inno_hdmi *hdmi,
-					 struct drm_display_mode *mode)
-{
-	int value;
-
-	if (hdmi->plat_data->dev_type == RK3036_HDMI) {
-		value = BIT(20) | BIT(21);
-		value |= mode->flags & DRM_MODE_FLAG_PHSYNC ? BIT(4) : 0;
-		value |= mode->flags & DRM_MODE_FLAG_PVSYNC ? BIT(5) : 0;
-		writel(value, hdmi->grf + 0x148);
-	}
-	/* Set detail external video timing polarity and interlace mode */
-	value = v_EXTERANL_VIDEO(1);
-	value |= mode->flags & DRM_MODE_FLAG_PHSYNC ?
-		 v_HSYNC_POLARITY(1) : v_HSYNC_POLARITY(0);
-	value |= mode->flags & DRM_MODE_FLAG_PVSYNC ?
-		 v_VSYNC_POLARITY(1) : v_VSYNC_POLARITY(0);
-	value |= mode->flags & DRM_MODE_FLAG_INTERLACE ?
-		 v_INETLACE(1) : v_INETLACE(0);
-	hdmi_writeb(hdmi, HDMI_VIDEO_TIMING_CTL, value);
-
-	/* Set detail external video timing */
-	value = mode->htotal;
-	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HTOTAL_L, value & 0xFF);
-	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HTOTAL_H, (value >> 8) & 0xFF);
-
-	value = mode->htotal - mode->hdisplay;
-	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HBLANK_L, value & 0xFF);
-	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HBLANK_H, (value >> 8) & 0xFF);
-
-	value = mode->htotal - mode->hsync_start;
-	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDELAY_L, value & 0xFF);
-	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDELAY_H, (value >> 8) & 0xFF);
-
-	value = mode->hsync_end - mode->hsync_start;
-	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDURATION_L, value & 0xFF);
-	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDURATION_H, (value >> 8) & 0xFF);
-
-	value = mode->vtotal;
-	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_VTOTAL_L, value & 0xFF);
-	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_VTOTAL_H, (value >> 8) & 0xFF);
-
-	value = mode->vtotal - mode->vdisplay;
-	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_VBLANK, value & 0xFF);
-
-	value = mode->vtotal - mode->vsync_start;
-	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_VDELAY, value & 0xFF);
-
-	value = mode->vsync_end - mode->vsync_start;
-	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_VDURATION, value & 0xFF);
-
-	hdmi_writeb(hdmi, HDMI_PHY_PRE_DIV_RATIO, 0x1e);
-	hdmi_writeb(hdmi, HDMI_PHY_FEEDBACK_DIV_RATIO_LOW, 0x2c);
-	hdmi_writeb(hdmi, HDMI_PHY_FEEDBACK_DIV_RATIO_HIGH, 0x01);
-
-	return 0;
-}
-
-static int inno_hdmi_setup(struct inno_hdmi *hdmi,
-			   struct drm_display_mode *mode)
-{
-	hdmi->hdmi_data.vic = drm_match_cea_mode(mode);
-
-	hdmi->hdmi_data.enc_in_format = HDMI_COLORSPACE_RGB;
-	hdmi->hdmi_data.enc_out_format = HDMI_COLORSPACE_RGB;
-
-	if (hdmi->hdmi_data.vic == 6 || hdmi->hdmi_data.vic == 7 ||
-	    hdmi->hdmi_data.vic == 21 || hdmi->hdmi_data.vic == 22 ||
-	    hdmi->hdmi_data.vic == 2 || hdmi->hdmi_data.vic == 3 ||
-	    hdmi->hdmi_data.vic == 17 || hdmi->hdmi_data.vic == 18)
-		hdmi->hdmi_data.colorimetry = HDMI_COLORIMETRY_ITU_601;
-	else
-		hdmi->hdmi_data.colorimetry = HDMI_COLORIMETRY_ITU_709;
-
-	/* Mute video and audio output */
-	hdmi_modb(hdmi, HDMI_AV_MUTE, m_AUDIO_MUTE | m_VIDEO_BLACK,
-		  v_AUDIO_MUTE(1) | v_VIDEO_MUTE(1));
-
-	/* Set HDMI Mode */
-	hdmi_writeb(hdmi, HDMI_HDCP_CTRL,
-		    v_HDMI_DVI(hdmi->hdmi_data.sink_is_hdmi));
-
-	inno_hdmi_config_video_timing(hdmi, mode);
-
-	inno_hdmi_config_video_csc(hdmi);
-
-	if (hdmi->hdmi_data.sink_is_hdmi) {
-		inno_hdmi_config_video_avi(hdmi, mode);
-		inno_hdmi_config_video_vsi(hdmi, mode);
-	}
-
-	/*
-	 * When IP controller have configured to an accurate video
-	 * timing, then the TMDS clock source would be switched to
-	 * DCLK_LCDC, so we need to init the TMDS rate to mode pixel
-	 * clock rate, and reconfigure the DDC clock.
-	 */
-	hdmi->tmds_rate = mode->clock * 1000;
-	inno_hdmi_i2c_init(hdmi);
-	/* Unmute video and audio output */
-	hdmi_modb(hdmi, HDMI_AV_MUTE, m_VIDEO_BLACK, v_VIDEO_MUTE(0));
-	if (hdmi->audio_enable)
-		hdmi_modb(hdmi, HDMI_AV_MUTE, m_AUDIO_MUTE, v_AUDIO_MUTE(0));
-
-	return 0;
-}
-
-static int inno_hdmi_i2c_read(struct inno_hdmi *hdmi,
-			      struct i2c_msg *msgs)
-{
-	struct inno_hdmi_i2c *i2c = hdmi->i2c;
-	unsigned int length = msgs->len;
-	unsigned char *buf = msgs->buf;
-	int interrupt = 0, i = 20;
-
-	while (i--) {
-		mdelay(50);
-		interrupt = 0;
-		interrupt = hdmi_readb(hdmi, HDMI_INTERRUPT_STATUS1);
-
-		if (interrupt & m_INT_EDID_READY)
-			break;
-	}
-
-	if (!interrupt) {
-		printf("[%s] i2c read reg[0x%02x] no interrupt\n",
-		       __func__, i2c->slave_reg);
-		return -EAGAIN;
-	}
-
-	/* Clear HDMI EDID interrupt flag */
-	hdmi_writeb(hdmi, HDMI_INTERRUPT_STATUS1, m_INT_EDID_READY);
-
-	while (length--)
-		*buf++ = hdmi_readb(hdmi, HDMI_EDID_FIFO_ADDR);
-
-	return 0;
-}
-
-static int inno_hdmi_i2c_write(struct inno_hdmi *hdmi,
-			       struct i2c_msg *msgs)
-{
-	unsigned int length = msgs->len;
-
-	hdmi->i2c->segment_addr = 0;
-	hdmi->i2c->ddc_addr = 0;
-
-	/*
-	 * The DDC module only support read EDID message, so
-	 * we assume that each word write to this i2c adapter
-	 * should be the offset of EDID word address.
-	 */
-	if (length != 1 ||
-	    (msgs->addr != DDC_ADDR && msgs->addr != DDC_SEGMENT_ADDR)) {
-		printf("DDC word write to i2c adapter is not EDID address\n");
-		return -EINVAL;
-	}
-
-	if (msgs->addr == DDC_SEGMENT_ADDR)
-		hdmi->i2c->segment_addr = msgs->buf[0];
-	if (msgs->addr == DDC_ADDR)
-		hdmi->i2c->ddc_addr = msgs->buf[0];
-
-	/* Set edid fifo first addr */
-	hdmi_writeb(hdmi, HDMI_EDID_FIFO_OFFSET, 0x00);
-
-	/* Set edid word address 0x00/0x80 */
-	hdmi_writeb(hdmi, HDMI_EDID_WORD_ADDR, hdmi->i2c->ddc_addr);
-
-	/* Set edid segment pointer */
-	hdmi_writeb(hdmi, HDMI_EDID_SEGMENT_POINTER, hdmi->i2c->segment_addr);
-
-	return 0;
-}
-
-static int inno_hdmi_i2c_xfer(struct ddc_adapter *adap,
-			      struct i2c_msg *msgs, int num)
-{
-	struct inno_hdmi *hdmi = container_of(adap, struct inno_hdmi, adap);
-	int i, ret = 0;
-
-	/* Clear the EDID interrupt flag and unmute the interrupt */
-	hdmi_writeb(hdmi, HDMI_INTERRUPT_MASK1, m_INT_EDID_READY);
-	hdmi_writeb(hdmi, HDMI_INTERRUPT_STATUS1, m_INT_EDID_READY);
-
-	for (i = 0; i < num; i++) {
-		dev_dbg(hdmi->dev, "xfer: num: %d/%d, len: %d, flags: %#x\n",
-			i + 1, num, msgs[i].len, msgs[i].flags);
-
-		if (msgs[i].flags & I2C_M_RD)
-			ret = inno_hdmi_i2c_read(hdmi, &msgs[i]);
-		else
-			ret = inno_hdmi_i2c_write(hdmi, &msgs[i]);
-
-		if (ret < 0)
-			break;
-	}
-
-	if (!ret)
-		ret = num;
-
-	/* Mute HDMI EDID interrupt */
-	hdmi_writeb(hdmi, HDMI_INTERRUPT_MASK1, 0);
-
-	return ret;
-}
-
-int rockchip_inno_hdmi_pre_init(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-
-	conn_state->type = DRM_MODE_CONNECTOR_HDMIA;
-
-	return 0;
-}
-
-static int rockchip_inno_hdmi_init(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	const struct rockchip_connector *connector = conn_state->connector;
-	struct inno_hdmi *hdmi;
-	struct drm_display_mode *mode_buf;
-	ofnode hdmi_node = conn_state->node;
-	int ret;
-
-	hdmi = calloc(1, sizeof(struct inno_hdmi));
-	if (!hdmi)
-		return -ENOMEM;
-
-	mode_buf = calloc(1, MODE_LEN * sizeof(struct drm_display_mode));
-	if (!mode_buf)
-		return -ENOMEM;
-
-	hdmi->regs = dev_read_addr_ptr(conn_state->dev);
-
-	hdmi->grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
-	if (hdmi->grf <= 0) {
-		printf("%s: Get syscon grf failed (ret=%p)\n",
-		       __func__, hdmi->grf);
-		return -ENXIO;
-	}
-
-	hdmi->i2c = malloc(sizeof(struct inno_hdmi_i2c));
-	if (!hdmi->i2c)
-		return -ENOMEM;
-
-	hdmi->adap.ddc_xfer = inno_hdmi_i2c_xfer;
-
-	/*
-	 * Read high and low time from device tree. If not available use
-	 * the default timing scl clock rate is about 99.6KHz.
-	 */
-	hdmi->i2c->scl_high_ns =
-		ofnode_read_s32_default(hdmi_node,
-					"ddc-i2c-scl-high-time-ns", 4708);
-	hdmi->i2c->scl_low_ns =
-		ofnode_read_s32_default(hdmi_node,
-					"ddc-i2c-scl-low-time-ns", 4916);
-
-	conn_state->type = DRM_MODE_CONNECTOR_HDMIA;
-	conn_state->output_mode = ROCKCHIP_OUT_MODE_AAAA;
-
-	hdmi->plat_data = (struct inno_hdmi_plat_data *)connector->data;
-	hdmi->edid_data.mode_buf = mode_buf;
-	hdmi->sample_rate = 48000;
-
-	conn_state->private = hdmi;
-
-	inno_hdmi_reset(hdmi);
-	ret = clk_get_by_name(conn_state->dev, "pclk", &hdmi->pclk);
-	if (ret < 0) {
-		dev_err(hdmi->dev, "failed to get pclk: %d\n", ret);
-		return ret;
-	}
-	hdmi->tmds_rate = clk_get_rate(&hdmi->pclk);
-	inno_hdmi_i2c_init(hdmi);
-
-	/* Unmute hotplug interrupt */
-	hdmi_modb(hdmi, HDMI_STATUS, m_MASK_INT_HOTPLUG, v_MASK_INT_HOTPLUG(1));
-
-	return 0;
-}
-
-static int rockchip_inno_hdmi_enable(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	struct drm_display_mode *mode = &conn_state->mode;
-	struct inno_hdmi *hdmi = conn_state->private;
-
-	if (!hdmi)
-		return -EFAULT;
-
-	/* Store the display mode for plugin/DKMS poweron events */
-	memcpy(&hdmi->previous_mode, mode, sizeof(hdmi->previous_mode));
-
-	inno_hdmi_setup(hdmi, mode);
-	inno_hdmi_set_pwr_mode(hdmi, NORMAL);
-
-	return 0;
-}
-
-static void rockchip_inno_hdmi_deinit(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	struct inno_hdmi *hdmi = conn_state->private;
-
-	if (hdmi->i2c)
-		free(hdmi->i2c);
-	if (hdmi)
-		free(hdmi);
-}
-
-static int rockchip_inno_hdmi_prepare(struct display_state *state)
-{
-	return 0;
-}
-
-static int rockchip_inno_hdmi_disable(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	struct inno_hdmi *hdmi = conn_state->private;
-
-	inno_hdmi_set_pwr_mode(hdmi, LOWER_PWR);
-	return 0;
-}
-
-static int rockchip_inno_hdmi_detect(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	struct inno_hdmi *hdmi = conn_state->private;
-
-	return (hdmi_readb(hdmi, HDMI_STATUS) & m_HOTPLUG) ?
-		connector_status_connected : connector_status_disconnected;
-}
-
-static int rockchip_inno_hdmi_get_timing(struct display_state *state)
-{
-	int  i, ret;
-	struct connector_state *conn_state = &state->conn_state;
-	struct drm_display_mode *mode = &conn_state->mode;
-	struct inno_hdmi *hdmi = conn_state->private;
-	struct edid *edid = (struct edid *)conn_state->edid;
-	const u8 def_modes_vic[6] = {16, 4, 2, 17, 31, 19};
-
-	if (!hdmi)
-		return -EFAULT;
-
-	ret = drm_do_get_edid(&hdmi->adap, conn_state->edid);
-	if (!ret) {
-		hdmi->hdmi_data.sink_is_hdmi =
-			drm_detect_hdmi_monitor(edid);
-		hdmi->hdmi_data.sink_has_audio = drm_detect_monitor_audio(edid);
-		ret = drm_add_edid_modes(&hdmi->edid_data, conn_state->edid);
-	}
-	if (ret <= 0) {
-		hdmi->hdmi_data.sink_is_hdmi = true;
-		hdmi->hdmi_data.sink_has_audio = true;
-		do_cea_modes(&hdmi->edid_data, def_modes_vic,
-			     sizeof(def_modes_vic));
-		hdmi->edid_data.preferred_mode = &hdmi->edid_data.mode_buf[0];
-		printf("failed to get edid\n");
-	}
-	drm_rk_filter_whitelist(&hdmi->edid_data);
-
-	if (!drm_mode_prune_invalid(&hdmi->edid_data)) {
-		printf("can't find valid hdmi mode\n");
-		return -EINVAL;
-	}
-
-	for (i = 0; i < hdmi->edid_data.modes; i++)
-		hdmi->edid_data.mode_buf[i].vrefresh =
-			drm_mode_vrefresh(&hdmi->edid_data.mode_buf[i]);
-
-	drm_mode_sort(&hdmi->edid_data);
-
-	*mode = *hdmi->edid_data.preferred_mode;
-	hdmi->vic = drm_match_cea_mode(mode);
-
-	printf("mode:%dx%d\n", mode->hdisplay, mode->vdisplay);
-
-	conn_state->bus_format = MEDIA_BUS_FMT_RGB888_1X24;
-
-	return 0;
-}
-
-static int rockchip_inno_hdmi_probe(struct udevice *dev)
-{
-	return 0;
-}
-
-static int rockchip_inno_hdmi_bind(struct udevice *dev)
-{
-	return 0;
-}
-
-const struct rockchip_connector_funcs rockchip_inno_hdmi_funcs = {
-	.pre_init = rockchip_inno_hdmi_pre_init,
-	.init = rockchip_inno_hdmi_init,
-	.deinit = rockchip_inno_hdmi_deinit,
-	.prepare = rockchip_inno_hdmi_prepare,
-	.enable = rockchip_inno_hdmi_enable,
-	.disable = rockchip_inno_hdmi_disable,
-	.get_timing = rockchip_inno_hdmi_get_timing,
-	.detect = rockchip_inno_hdmi_detect,
-};
-
-static const struct inno_hdmi_plat_data rk3036_hdmi_drv_data = {
-	.dev_type   = RK3036_HDMI,
-	.phy_config = rk3036_hdmi_phy_config,
-};
-
-static const struct inno_hdmi_plat_data rk3128_hdmi_drv_data = {
-	.dev_type   = RK3128_HDMI,
-	.phy_config = rk3128_hdmi_phy_config,
-};
-
-static const struct rockchip_connector rk3036_inno_hdmi_data = {
-	.funcs = &rockchip_inno_hdmi_funcs,
-	.data = &rk3036_hdmi_drv_data,
-};
-
-static const struct rockchip_connector rk3128_inno_hdmi_data = {
-	.funcs = &rockchip_inno_hdmi_funcs,
-	.data = &rk3128_hdmi_drv_data,
-};
-
-static const struct udevice_id rockchip_inno_hdmi_ids[] = {
-	{
-	 .compatible = "rockchip,rk3036-inno-hdmi",
-	 .data = (ulong)&rk3036_inno_hdmi_data,
-	},
-	{
-	 .compatible = "rockchip,rk3128-inno-hdmi",
-	 .data = (ulong)&rk3128_inno_hdmi_data,
-	}, {}
-
-};
-
-U_BOOT_DRIVER(rockchip_inno_hdmi) = {
-	.name = "rockchip_inno_hdmi",
-	.id = UCLASS_DISPLAY,
-	.of_match = rockchip_inno_hdmi_ids,
-	.probe	= rockchip_inno_hdmi_probe,
-	.bind	= rockchip_inno_hdmi_bind,
-};
+version https://git-lfs.github.com/spec/v1
+oid sha256:541ae7e29764edf525352ef6294aa3b01f1bc91dd3fb33e74ec62d5c1339b99d
+size 23736
diff --git a/u-boot/drivers/video/drm/rockchip_display.c b/u-boot/drivers/video/drm/rockchip_display.c
index add46a3901..1e8b612baa 100644
--- a/u-boot/drivers/video/drm/rockchip_display.c
+++ b/u-boot/drivers/video/drm/rockchip_display.c
@@ -1,1981 +1,3 @@
-/*
- * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <asm/unaligned.h>
-#include <boot_rkimg.h>
-#include <config.h>
-#include <common.h>
-#include <errno.h>
-#include <linux/libfdt.h>
-#include <fdtdec.h>
-#include <fdt_support.h>
-#include <linux/hdmi.h>
-#include <linux/list.h>
-#include <linux/compat.h>
-#include <linux/media-bus-format.h>
-#include <malloc.h>
-#include <video.h>
-#include <video_rockchip.h>
-#include <video_bridge.h>
-#include <dm/device.h>
-#include <dm/uclass-internal.h>
-#include <asm/arch-rockchip/resource_img.h>
-
-#include "bmp_helper.h"
-#include "rockchip_display.h"
-#include "rockchip_crtc.h"
-#include "rockchip_connector.h"
-#include "rockchip_bridge.h"
-#include "rockchip_phy.h"
-#include "rockchip_panel.h"
-#include <dm.h>
-#include <dm/of_access.h>
-#include <dm/ofnode.h>
-#include <asm/io.h>
-
-#define DRIVER_VERSION	"v1.0.1"
-
-/***********************************************************************
- *  Rockchip UBOOT DRM driver version
- *
- *  v1.0.0	: add basic version for rockchip drm driver(hjc)
- *  v1.0.1	: add much dsi update(hjc)
- *
- **********************************************************************/
-
-#define RK_BLK_SIZE 512
-#define BMP_PROCESSED_FLAG 8399
-
-DECLARE_GLOBAL_DATA_PTR;
-static LIST_HEAD(rockchip_display_list);
-static LIST_HEAD(logo_cache_list);
-
-static unsigned long memory_start;
-static unsigned long cubic_lut_memory_start;
-static unsigned long memory_end;
-static struct base2_info base_parameter;
-static uint32_t crc32_table[256];
-
-/*
- * the phy types are used by different connectors in public.
- * The current version only has inno hdmi phy for hdmi and tve.
- */
-enum public_use_phy {
-	NONE,
-	INNO_HDMI_PHY
-};
-
-/* save public phy data */
-struct public_phy_data {
-	const struct rockchip_phy *phy_drv;
-	int phy_node;
-	int public_phy_type;
-	bool phy_init;
-};
-
-void rockchip_display_make_crc32_table(void)
-{
-	uint32_t c;
-	int n, k;
-	unsigned long poly;		/* polynomial exclusive-or pattern */
-	/* terms of polynomial defining this crc (except x^32): */
-	static const char p[] = {0, 1, 2, 4, 5, 7, 8, 10, 11, 12, 16, 22, 23, 26};
-
-	/* make exclusive-or pattern from polynomial (0xedb88320L) */
-	poly = 0L;
-	for (n = 0; n < sizeof(p) / sizeof(char); n++)
-		poly |= 1L << (31 - p[n]);
-
-	for (n = 0; n < 256; n++) {
-		c = (unsigned long)n;
-		for (k = 0; k < 8; k++)
-		c = c & 1 ? poly ^ (c >> 1) : c >> 1;
-		crc32_table[n] = cpu_to_le32(c);
-	}
-}
-
-uint32_t rockchip_display_crc32c_cal(unsigned char *data, int length)
-{
-	int i;
-	uint32_t crc;
-	crc = 0xFFFFFFFF;
-
-	for (i = 0; i < length; i++) {
-		crc = crc32_table[(crc ^ *data) & 0xff] ^ (crc >> 8);
-		data++;
-	}
-
-	return crc ^ 0xffffffff;
-}
-
-int rockchip_get_baseparameter(void)
-{
-	struct blk_desc *dev_desc;
-	disk_partition_t part_info;
-	int block_num = 2048;
-	char baseparameter_buf[block_num * RK_BLK_SIZE] __aligned(ARCH_DMA_MINALIGN);
-	int ret = 0;
-
-	dev_desc = rockchip_get_bootdev();
-	if (!dev_desc) {
-		printf("%s: Could not find device\n", __func__);
-		return -ENOENT;
-	}
-
-	if (part_get_info_by_name(dev_desc, "baseparameter", &part_info) < 0) {
-		printf("Could not find baseparameter partition\n");
-		return -ENOENT;
-	}
-
-	ret = blk_dread(dev_desc, part_info.start, block_num, (void *)baseparameter_buf);
-	if (ret < 0) {
-		printf("read baseparameter failed\n");
-		return ret;
-	}
-
-	memcpy(&base_parameter, baseparameter_buf, sizeof(base_parameter));
-	if (strncasecmp(base_parameter.head_flag, "BASP", 4)) {
-		printf("warning: bad baseparameter\n");
-		memset(&base_parameter, 0, sizeof(base_parameter));
-	}
-	rockchip_display_make_crc32_table();
-
-	return ret;
-}
-
-struct base2_disp_info *rockchip_get_disp_info(int type, int id)
-{
-	struct base2_disp_info *disp_info;
-	struct base2_disp_header *disp_header;
-	int i = 0, offset = -1;
-	u32 crc_val;
-	void *base_parameter_addr = (void *)&base_parameter;
-
-	for (i = 0; i < 8; i++) {
-		disp_header = &base_parameter.disp_header[i];
-		if (disp_header->connector_type == type &&
-		    disp_header->connector_id == id) {
-			printf("disp info %d, type:%d, id:%d\n", i, type, id);
-			offset = disp_header->offset;
-			break;
-		}
-	}
-
-	if (offset < 0)
-		return NULL;
-	disp_info = base_parameter_addr + offset;
-	if (disp_info->screen_info[0].type != type ||
-	    disp_info->screen_info[0].id != id) {
-		printf("connector type or id is error, type:%d, id:%d\n",
-		       disp_info->screen_info[0].type,
-		       disp_info->screen_info[0].id);
-		return NULL;
-	}
-
-	if (strncasecmp(disp_info->disp_head_flag, "DISP", 4))
-		return NULL;
-
-	crc_val = rockchip_display_crc32c_cal((unsigned char *)disp_info, sizeof(struct base2_disp_info) - 4);
-
-	if (crc_val != disp_info->crc) {
-		printf("error: connector type[%d], id[%d] disp info crc check error\n", type, id);
-		return NULL;
-	}
-
-	return disp_info;
-}
-
-/* check which kind of public phy does connector use */
-static int check_public_use_phy(struct display_state *state)
-{
-	int ret = NONE;
-#ifdef CONFIG_ROCKCHIP_INNO_HDMI_PHY
-	struct connector_state *conn_state = &state->conn_state;
-
-	if (!strncmp(dev_read_name(conn_state->dev), "tve", 3) ||
-	    !strncmp(dev_read_name(conn_state->dev), "hdmi", 4))
-		ret = INNO_HDMI_PHY;
-#endif
-
-	return ret;
-}
-
-/*
- * get public phy driver and initialize it.
- * The current version only has inno hdmi phy for hdmi and tve.
- */
-static int get_public_phy(struct display_state *state,
-			  struct public_phy_data *data)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	struct rockchip_phy *phy;
-	struct udevice *dev;
-	int ret = 0;
-
-	switch (data->public_phy_type) {
-	case INNO_HDMI_PHY:
-#if defined(CONFIG_ROCKCHIP_RK3328)
-		ret = uclass_get_device_by_name(UCLASS_PHY,
-						"hdmiphy@ff430000", &dev);
-#elif defined(CONFIG_ROCKCHIP_RK322X)
-		ret = uclass_get_device_by_name(UCLASS_PHY,
-						"hdmi-phy@12030000", &dev);
-#else
-		ret = -EINVAL;
-#endif
-		if (ret) {
-			printf("Warn: can't find phy driver\n");
-			return 0;
-		}
-
-		phy = (struct rockchip_phy *)dev_get_driver_data(dev);
-		if (!phy) {
-			printf("failed to get phy driver\n");
-			return 0;
-		}
-
-		ret = rockchip_phy_init(phy);
-		if (ret) {
-			printf("failed to init phy driver\n");
-			return ret;
-		}
-		conn_state->phy = phy;
-
-		debug("inno hdmi phy init success, save it\n");
-		data->phy_drv = conn_state->phy;
-		data->phy_init = true;
-		return 0;
-	default:
-		return -EINVAL;
-	}
-}
-
-static void init_display_buffer(ulong base)
-{
-	memory_start = base + DRM_ROCKCHIP_FB_SIZE;
-	memory_end = memory_start;
-	cubic_lut_memory_start = memory_start + MEMORY_POOL_SIZE;
-}
-
-void *get_display_buffer(int size)
-{
-	unsigned long roundup_memory = roundup(memory_end, PAGE_SIZE);
-	void *buf;
-
-	if (roundup_memory + size > memory_start + MEMORY_POOL_SIZE) {
-		printf("failed to alloc %dbyte memory to display\n", size);
-		return NULL;
-	}
-	buf = (void *)roundup_memory;
-
-	memory_end = roundup_memory + size;
-
-	return buf;
-}
-
-static unsigned long get_display_size(void)
-{
-	return memory_end - memory_start;
-}
-
-static unsigned long get_single_cubic_lut_size(void)
-{
-	ulong cubic_lut_size;
-	int cubic_lut_step = CONFIG_ROCKCHIP_CUBIC_LUT_SIZE;
-
-	/* This is depend on IC designed */
-	cubic_lut_size = (cubic_lut_step * cubic_lut_step * cubic_lut_step + 1) / 2 * 16;
-	cubic_lut_size = roundup(cubic_lut_size, PAGE_SIZE);
-
-	return cubic_lut_size;
-}
-
-static unsigned long get_cubic_lut_offset(int crtc_id)
-{
-	return crtc_id * get_single_cubic_lut_size();
-}
-
-unsigned long get_cubic_lut_buffer(int crtc_id)
-{
-	return cubic_lut_memory_start + crtc_id * get_single_cubic_lut_size();
-}
-
-static unsigned long get_cubic_memory_size(void)
-{
-	/* Max support 4 cubic lut */
-	return get_single_cubic_lut_size() * 4;
-}
-
-bool can_direct_logo(int bpp)
-{
-	return bpp == 24 || bpp == 32;
-}
-
-static int connector_phy_init(struct display_state *state,
-			      struct public_phy_data *data)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	int type;
-
-	/* does this connector use public phy with others */
-	type = check_public_use_phy(state);
-	if (type == INNO_HDMI_PHY) {
-		/* there is no public phy was initialized */
-		if (!data->phy_init) {
-			debug("start get public phy\n");
-			data->public_phy_type = type;
-			if (get_public_phy(state, data)) {
-				printf("can't find correct public phy type\n");
-				free(data);
-				return -EINVAL;
-			}
-			return 0;
-		}
-
-		/* if this phy has been initialized, get it directly */
-		conn_state->phy = (struct rockchip_phy *)data->phy_drv;
-		return 0;
-	}
-
-	return 0;
-}
-
-static int connector_panel_init(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	struct panel_state *panel_state = &state->panel_state;
-	const struct rockchip_panel *panel = panel_state->panel;
-	ofnode dsp_lut_node;
-	int ret, len;
-
-	if (!panel)
-		return 0;
-
-	dsp_lut_node = dev_read_subnode(panel->dev, "dsp-lut");
-	if (!ofnode_valid(dsp_lut_node)) {
-		debug("%s can not find dsp-lut node\n", __func__);
-		return 0;
-	}
-
-	ofnode_get_property(dsp_lut_node, "gamma-lut", &len);
-	if (len > 0) {
-		conn_state->gamma.size = len / sizeof(u32);
-		conn_state->gamma.lut = malloc(len);
-		if (!conn_state->gamma.lut) {
-			printf("malloc gamma lut failed\n");
-			return -ENOMEM;
-		}
-		ret = ofnode_read_u32_array(dsp_lut_node, "gamma-lut",
-					    conn_state->gamma.lut,
-					    conn_state->gamma.size);
-		if (ret) {
-			printf("Cannot decode gamma_lut\n");
-			conn_state->gamma.lut = NULL;
-			return -EINVAL;
-		}
-		panel_state->dsp_lut_node = dsp_lut_node;
-	}
-
-	return 0;
-}
-
-int drm_mode_vrefresh(const struct drm_display_mode *mode)
-{
-	int refresh = 0;
-	unsigned int calc_val;
-
-	if (mode->vrefresh > 0) {
-		refresh = mode->vrefresh;
-	} else if (mode->htotal > 0 && mode->vtotal > 0) {
-		int vtotal;
-
-		vtotal = mode->vtotal;
-		/* work out vrefresh the value will be x1000 */
-		calc_val = (mode->clock * 1000);
-		calc_val /= mode->htotal;
-		refresh = (calc_val + vtotal / 2) / vtotal;
-
-		if (mode->flags & DRM_MODE_FLAG_INTERLACE)
-			refresh *= 2;
-		if (mode->flags & DRM_MODE_FLAG_DBLSCAN)
-			refresh /= 2;
-		if (mode->vscan > 1)
-			refresh /= mode->vscan;
-	}
-	return refresh;
-}
-
-static int display_get_timing_from_dts(struct panel_state *panel_state,
-				       struct drm_display_mode *mode)
-{
-	struct rockchip_panel *panel = panel_state->panel;
-	int phandle;
-	int hactive, vactive, pixelclock;
-	int hfront_porch, hback_porch, hsync_len;
-	int vfront_porch, vback_porch, vsync_len;
-	int val, flags = 0;
-	ofnode timing, native_mode;
-
-	timing = dev_read_subnode(panel->dev, "display-timings");
-	if (!ofnode_valid(timing))
-		return -ENODEV;
-
-	native_mode = ofnode_find_subnode(timing, "timing");
-	if (!ofnode_valid(native_mode)) {
-		phandle = ofnode_read_u32_default(timing, "native-mode", -1);
-		native_mode = np_to_ofnode(of_find_node_by_phandle(phandle));
-		if (!ofnode_valid(native_mode)) {
-			printf("failed to get display timings from DT\n");
-			return -ENXIO;
-		}
-	}
-
-#define FDT_GET_INT(val, name) \
-	val = ofnode_read_s32_default(native_mode, name, -1); \
-	if (val < 0) { \
-		printf("Can't get %s\n", name); \
-		return -ENXIO; \
-	}
-
-#define FDT_GET_INT_DEFAULT(val, name, default) \
-	val = ofnode_read_s32_default(native_mode, name, default);
-
-	FDT_GET_INT(hactive, "hactive");
-	FDT_GET_INT(vactive, "vactive");
-	FDT_GET_INT(pixelclock, "clock-frequency");
-	FDT_GET_INT(hsync_len, "hsync-len");
-	FDT_GET_INT(hfront_porch, "hfront-porch");
-	FDT_GET_INT(hback_porch, "hback-porch");
-	FDT_GET_INT(vsync_len, "vsync-len");
-	FDT_GET_INT(vfront_porch, "vfront-porch");
-	FDT_GET_INT(vback_porch, "vback-porch");
-	FDT_GET_INT(val, "hsync-active");
-	flags |= val ? DRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;
-	FDT_GET_INT(val, "vsync-active");
-	flags |= val ? DRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;
-	FDT_GET_INT(val, "pixelclk-active");
-	flags |= val ? DRM_MODE_FLAG_PPIXDATA : 0;
-
-	FDT_GET_INT_DEFAULT(val, "screen-rotate", 0);
-	if (val == DRM_MODE_FLAG_XMIRROR) {
-		flags |= DRM_MODE_FLAG_XMIRROR;
-	} else if (val == DRM_MODE_FLAG_YMIRROR) {
-		flags |= DRM_MODE_FLAG_YMIRROR;
-	} else if (val == DRM_MODE_FLAG_XYMIRROR) {
-		flags |= DRM_MODE_FLAG_XMIRROR;
-		flags |= DRM_MODE_FLAG_YMIRROR;
-	}
-	mode->hdisplay = hactive;
-	mode->hsync_start = mode->hdisplay + hfront_porch;
-	mode->hsync_end = mode->hsync_start + hsync_len;
-	mode->htotal = mode->hsync_end + hback_porch;
-
-	mode->vdisplay = vactive;
-	mode->vsync_start = mode->vdisplay + vfront_porch;
-	mode->vsync_end = mode->vsync_start + vsync_len;
-	mode->vtotal = mode->vsync_end + vback_porch;
-
-	mode->clock = pixelclock / 1000;
-	mode->flags = flags;
-
-	return 0;
-}
-
-/**
- * drm_mode_max_resolution_filter - mark modes out of vop max resolution
- * @edid_data: structure store mode list
- * @max_output: vop max output resolution
- */
-void drm_mode_max_resolution_filter(struct hdmi_edid_data *edid_data,
-				    struct vop_rect *max_output)
-{
-	int i;
-
-	for (i = 0; i < edid_data->modes; i++) {
-		if (edid_data->mode_buf[i].hdisplay > max_output->width ||
-		    edid_data->mode_buf[i].vdisplay > max_output->height)
-			edid_data->mode_buf[i].invalid = true;
-	}
-}
-
-/**
- * drm_mode_set_crtcinfo - set CRTC modesetting timing parameters
- * @p: mode
- * @adjust_flags: a combination of adjustment flags
- *
- * Setup the CRTC modesetting timing parameters for @p, adjusting if necessary.
- *
- * - The CRTC_INTERLACE_HALVE_V flag can be used to halve vertical timings of
- *   interlaced modes.
- * - The CRTC_STEREO_DOUBLE flag can be used to compute the timings for
- *   buffers containing two eyes (only adjust the timings when needed, eg. for
- *   "frame packing" or "side by side full").
- * - The CRTC_NO_DBLSCAN and CRTC_NO_VSCAN flags request that adjustment *not*
- *   be performed for doublescan and vscan > 1 modes respectively.
- */
-void drm_mode_set_crtcinfo(struct drm_display_mode *p, int adjust_flags)
-{
-	if ((p == NULL) || ((p->type & DRM_MODE_TYPE_CRTC_C) == DRM_MODE_TYPE_BUILTIN))
-		return;
-
-	if (p->flags & DRM_MODE_FLAG_DBLCLK)
-		p->crtc_clock = 2 * p->clock;
-	else
-		p->crtc_clock = p->clock;
-	p->crtc_hdisplay = p->hdisplay;
-	p->crtc_hsync_start = p->hsync_start;
-	p->crtc_hsync_end = p->hsync_end;
-	p->crtc_htotal = p->htotal;
-	p->crtc_hskew = p->hskew;
-	p->crtc_vdisplay = p->vdisplay;
-	p->crtc_vsync_start = p->vsync_start;
-	p->crtc_vsync_end = p->vsync_end;
-	p->crtc_vtotal = p->vtotal;
-
-	if (p->flags & DRM_MODE_FLAG_INTERLACE) {
-		if (adjust_flags & CRTC_INTERLACE_HALVE_V) {
-			p->crtc_vdisplay /= 2;
-			p->crtc_vsync_start /= 2;
-			p->crtc_vsync_end /= 2;
-			p->crtc_vtotal /= 2;
-		}
-	}
-
-	if (!(adjust_flags & CRTC_NO_DBLSCAN)) {
-		if (p->flags & DRM_MODE_FLAG_DBLSCAN) {
-			p->crtc_vdisplay *= 2;
-			p->crtc_vsync_start *= 2;
-			p->crtc_vsync_end *= 2;
-			p->crtc_vtotal *= 2;
-		}
-	}
-
-	if (!(adjust_flags & CRTC_NO_VSCAN)) {
-		if (p->vscan > 1) {
-			p->crtc_vdisplay *= p->vscan;
-			p->crtc_vsync_start *= p->vscan;
-			p->crtc_vsync_end *= p->vscan;
-			p->crtc_vtotal *= p->vscan;
-		}
-	}
-
-	if (adjust_flags & CRTC_STEREO_DOUBLE) {
-		unsigned int layout = p->flags & DRM_MODE_FLAG_3D_MASK;
-
-		switch (layout) {
-		case DRM_MODE_FLAG_3D_FRAME_PACKING:
-			p->crtc_clock *= 2;
-			p->crtc_vdisplay += p->crtc_vtotal;
-			p->crtc_vsync_start += p->crtc_vtotal;
-			p->crtc_vsync_end += p->crtc_vtotal;
-			p->crtc_vtotal += p->crtc_vtotal;
-			break;
-		}
-	}
-
-	p->crtc_vblank_start = min(p->crtc_vsync_start, p->crtc_vdisplay);
-	p->crtc_vblank_end = max(p->crtc_vsync_end, p->crtc_vtotal);
-	p->crtc_hblank_start = min(p->crtc_hsync_start, p->crtc_hdisplay);
-	p->crtc_hblank_end = max(p->crtc_hsync_end, p->crtc_htotal);
-}
-
-/**
- * drm_mode_is_420_only - if a given videomode can be only supported in YCBCR420
- * output format
- *
- * @connector: drm connector under action.
- * @mode: video mode to be tested.
- *
- * Returns:
- * true if the mode can be supported in YCBCR420 format
- * false if not.
- */
-bool drm_mode_is_420_only(const struct drm_display_info *display,
-			  struct drm_display_mode *mode)
-{
-	u8 vic = drm_match_cea_mode(mode);
-
-	return test_bit(vic, display->hdmi.y420_vdb_modes);
-}
-
-/**
- * drm_mode_is_420_also - if a given videomode can be supported in YCBCR420
- * output format also (along with RGB/YCBCR444/422)
- *
- * @display: display under action.
- * @mode: video mode to be tested.
- *
- * Returns:
- * true if the mode can be support YCBCR420 format
- * false if not.
- */
-bool drm_mode_is_420_also(const struct drm_display_info *display,
-			  struct drm_display_mode *mode)
-{
-	u8 vic = drm_match_cea_mode(mode);
-
-	return test_bit(vic, display->hdmi.y420_cmdb_modes);
-}
-
-/**
- * drm_mode_is_420 - if a given videomode can be supported in YCBCR420
- * output format
- *
- * @display: display under action.
- * @mode: video mode to be tested.
- *
- * Returns:
- * true if the mode can be supported in YCBCR420 format
- * false if not.
- */
-bool drm_mode_is_420(const struct drm_display_info *display,
-		     struct drm_display_mode *mode)
-{
-	return drm_mode_is_420_only(display, mode) ||
-		drm_mode_is_420_also(display, mode);
-}
-
-static int display_get_timing(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	struct drm_display_mode *mode = &conn_state->mode;
-	const struct drm_display_mode *m;
-	struct panel_state *panel_state = &state->panel_state;
-	const struct rockchip_panel *panel = panel_state->panel;
-
-	if (dev_of_valid(panel->dev) &&
-	    !display_get_timing_from_dts(panel_state, mode)) {
-		printf("Using display timing dts\n");
-		return 0;
-	}
-
-	if (panel->data) {
-		m = (const struct drm_display_mode *)panel->data;
-		memcpy(mode, m, sizeof(*m));
-		printf("Using display timing from compatible panel driver\n");
-		return 0;
-	}
-
-	return -ENODEV;
-}
-
-static int display_pre_init(void)
-{
-	struct display_state *state;
-	int ret = 0;
-
-	list_for_each_entry(state, &rockchip_display_list, head) {
-		struct connector_state *conn_state = &state->conn_state;
-		const struct rockchip_connector *conn = conn_state->connector;
-		const struct rockchip_connector_funcs *conn_funcs = conn->funcs;
-		struct crtc_state *crtc_state = &state->crtc_state;
-		struct rockchip_crtc *crtc = crtc_state->crtc;
-
-		if (conn_funcs->pre_init) {
-			ret = conn_funcs->pre_init(state);
-			if (ret)
-				printf("pre init conn error\n");
-		}
-		crtc->vps[crtc_state->crtc_id].output_type = conn_state->type;
-	}
-	return ret;
-}
-
-static int display_init(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	struct panel_state *panel_state = &state->panel_state;
-	const struct rockchip_connector *conn = conn_state->connector;
-	const struct rockchip_connector_funcs *conn_funcs = conn->funcs;
-	struct crtc_state *crtc_state = &state->crtc_state;
-	struct rockchip_crtc *crtc = crtc_state->crtc;
-	const struct rockchip_crtc_funcs *crtc_funcs = crtc->funcs;
-	struct drm_display_mode *mode = &conn_state->mode;
-	const char *compatible;
-	int ret = 0;
-	static bool __print_once = false;
-#if defined(CONFIG_I2C_EDID)
-	int bpc;
-#endif
-	if (!__print_once) {
-		__print_once = true;
-		printf("Rockchip UBOOT DRM driver version: %s\n", DRIVER_VERSION);
-	}
-
-	if (state->is_init)
-		return 0;
-
-	if (!conn_funcs || !crtc_funcs) {
-		printf("failed to find connector or crtc functions\n");
-		return -ENXIO;
-	}
-
-	if (crtc_state->crtc->active && !crtc_state->ports_node &&
-	    memcmp(&crtc_state->crtc->active_mode, &conn_state->mode,
-		   sizeof(struct drm_display_mode))) {
-		printf("%s has been used for output type: %d, mode: %dx%dp%d\n",
-			crtc_state->dev->name,
-			crtc_state->crtc->active_mode.type,
-			crtc_state->crtc->active_mode.hdisplay,
-			crtc_state->crtc->active_mode.vdisplay,
-			crtc_state->crtc->active_mode.vrefresh);
-		return -ENODEV;
-	}
-
-	if (crtc_funcs->preinit) {
-		ret = crtc_funcs->preinit(state);
-		if (ret)
-			return ret;
-	}
-
-	if (panel_state->panel)
-		rockchip_panel_init(panel_state->panel);
-
-	if (conn_funcs->init) {
-		ret = conn_funcs->init(state);
-		if (ret)
-			goto deinit;
-	}
-
-	if (conn_state->phy)
-		rockchip_phy_init(conn_state->phy);
-
-	/*
-	 * support hotplug, but not connect;
-	 */
-#ifdef CONFIG_ROCKCHIP_DRM_TVE
-	if (crtc->hdmi_hpd && conn_state->type == DRM_MODE_CONNECTOR_TV) {
-		printf("hdmi plugin ,skip tve\n");
-		goto deinit;
-	}
-#elif defined(CONFIG_DRM_ROCKCHIP_RK1000)
-	if (crtc->hdmi_hpd && conn_state->type == DRM_MODE_CONNECTOR_LVDS) {
-		printf("hdmi plugin ,skip tve\n");
-		goto deinit;
-	}
-#endif
-	if (conn_funcs->detect) {
-		ret = conn_funcs->detect(state);
-#if defined(CONFIG_ROCKCHIP_DRM_TVE) || defined(CONFIG_DRM_ROCKCHIP_RK1000)
-		if (conn_state->type == DRM_MODE_CONNECTOR_HDMIA)
-			crtc->hdmi_hpd = ret;
-#endif
-		if (!ret)
-			goto deinit;
-	}
-
-	if (panel_state->panel) {
-		ret = display_get_timing(state);
-		if (!ret)
-			conn_state->bpc = panel_state->panel->bpc;
-#if defined(CONFIG_I2C_EDID)
-		if (ret < 0 && conn_funcs->get_edid) {
-			rockchip_panel_prepare(panel_state->panel);
-
-			ret = conn_funcs->get_edid(state);
-			if (!ret) {
-				ret = edid_get_drm_mode((void *)&conn_state->edid,
-							sizeof(conn_state->edid),
-							mode, &bpc);
-				if (!ret) {
-					conn_state->bpc = bpc;
-					edid_print_info((void *)&conn_state->edid);
-				}
-			}
-		}
-#endif
-	} else if (conn_state->bridge) {
-		ret = video_bridge_read_edid(conn_state->bridge->dev,
-					     conn_state->edid, EDID_SIZE);
-		if (ret > 0) {
-#if defined(CONFIG_I2C_EDID)
-			ret = edid_get_drm_mode(conn_state->edid, ret, mode,
-						&bpc);
-			if (!ret) {
-				conn_state->bpc = bpc;
-				edid_print_info((void *)&conn_state->edid);
-			}
-#endif
-		} else {
-			ret = video_bridge_get_timing(conn_state->bridge->dev);
-		}
-	} else if (conn_funcs->get_timing) {
-		ret = conn_funcs->get_timing(state);
-	} else if (conn_funcs->get_edid) {
-		ret = conn_funcs->get_edid(state);
-#if defined(CONFIG_I2C_EDID)
-		if (!ret) {
-			ret = edid_get_drm_mode((void *)&conn_state->edid,
-						sizeof(conn_state->edid), mode,
-						&bpc);
-			if (!ret) {
-				conn_state->bpc = bpc;
-				edid_print_info((void *)&conn_state->edid);
-			}
-		}
-#endif
-	}
-
-	if (ret)
-		goto deinit;
-
-	/* rk356x series drive mipi pixdata on posedge */
-	compatible = dev_read_string(conn_state->dev, "compatible");
-	if (!strcmp(compatible, "rockchip,rk3568-mipi-dsi"))
-		conn_state->mode.flags |= DRM_MODE_FLAG_PPIXDATA;
-
-	printf("Detailed mode clock %u kHz, flags[%x]\n"
-	       "    H: %04d %04d %04d %04d\n"
-	       "    V: %04d %04d %04d %04d\n"
-	       "bus_format: %x\n",
-	       mode->clock, mode->flags,
-	       mode->hdisplay, mode->hsync_start,
-	       mode->hsync_end, mode->htotal,
-	       mode->vdisplay, mode->vsync_start,
-	       mode->vsync_end, mode->vtotal,
-	       conn_state->bus_format);
-
-	drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);
-
-	if (conn_state->bridge)
-		rockchip_bridge_mode_set(conn_state->bridge, &conn_state->mode);
-
-	if (crtc_funcs->init) {
-		ret = crtc_funcs->init(state);
-		if (ret)
-			goto deinit;
-	}
-	state->is_init = 1;
-
-	crtc_state->crtc->active = true;
-	memcpy(&crtc_state->crtc->active_mode,
-	       &conn_state->mode, sizeof(struct drm_display_mode));
-
-	return 0;
-
-deinit:
-	if (conn_funcs->deinit)
-		conn_funcs->deinit(state);
-	return ret;
-}
-
-int display_send_mcu_cmd(struct display_state *state, u32 type, u32 val)
-{
-	struct crtc_state *crtc_state = &state->crtc_state;
-	const struct rockchip_crtc *crtc = crtc_state->crtc;
-	const struct rockchip_crtc_funcs *crtc_funcs = crtc->funcs;
-	int ret;
-
-	if (!state->is_init)
-		return -EINVAL;
-
-	if (crtc_funcs->send_mcu_cmd) {
-		ret = crtc_funcs->send_mcu_cmd(state, type, val);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-static int display_set_plane(struct display_state *state)
-{
-	struct crtc_state *crtc_state = &state->crtc_state;
-	const struct rockchip_crtc *crtc = crtc_state->crtc;
-	const struct rockchip_crtc_funcs *crtc_funcs = crtc->funcs;
-	int ret;
-
-	if (!state->is_init)
-		return -EINVAL;
-
-	if (crtc_funcs->set_plane) {
-		ret = crtc_funcs->set_plane(state);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-static int display_enable(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	const struct rockchip_connector *conn = conn_state->connector;
-	const struct rockchip_connector_funcs *conn_funcs = conn->funcs;
-	struct crtc_state *crtc_state = &state->crtc_state;
-	const struct rockchip_crtc *crtc = crtc_state->crtc;
-	const struct rockchip_crtc_funcs *crtc_funcs = crtc->funcs;
-	struct panel_state *panel_state = &state->panel_state;
-
-	if (!state->is_init)
-		return -EINVAL;
-
-	if (state->is_enable)
-		return 0;
-
-	if (crtc_funcs->prepare)
-		crtc_funcs->prepare(state);
-
-	if (conn_funcs->prepare)
-		conn_funcs->prepare(state);
-
-	if (conn_state->bridge)
-		rockchip_bridge_pre_enable(conn_state->bridge);
-
-	if (panel_state->panel)
-		rockchip_panel_prepare(panel_state->panel);
-
-	if (crtc_funcs->enable)
-		crtc_funcs->enable(state);
-
-	if (conn_funcs->enable)
-		conn_funcs->enable(state);
-
-	if (conn_state->bridge)
-		rockchip_bridge_enable(conn_state->bridge);
-
-	if (panel_state->panel)
-		rockchip_panel_enable(panel_state->panel);
-
-	state->is_enable = true;
-
-	return 0;
-}
-
-static int display_disable(struct display_state *state)
-{
-	struct connector_state *conn_state = &state->conn_state;
-	const struct rockchip_connector *conn = conn_state->connector;
-	const struct rockchip_connector_funcs *conn_funcs = conn->funcs;
-	struct crtc_state *crtc_state = &state->crtc_state;
-	const struct rockchip_crtc *crtc = crtc_state->crtc;
-	const struct rockchip_crtc_funcs *crtc_funcs = crtc->funcs;
-	struct panel_state *panel_state = &state->panel_state;
-
-	if (!state->is_init)
-		return 0;
-
-	if (!state->is_enable)
-		return 0;
-
-	if (panel_state->panel)
-		rockchip_panel_disable(panel_state->panel);
-
-	if (conn_state->bridge)
-		rockchip_bridge_disable(conn_state->bridge);
-
-	if (conn_funcs->disable)
-		conn_funcs->disable(state);
-
-	if (crtc_funcs->disable)
-		crtc_funcs->disable(state);
-
-	if (panel_state->panel)
-		rockchip_panel_unprepare(panel_state->panel);
-
-	if (conn_state->bridge)
-		rockchip_bridge_post_disable(conn_state->bridge);
-
-	if (conn_funcs->unprepare)
-		conn_funcs->unprepare(state);
-
-	state->is_enable = 0;
-	state->is_init = 0;
-
-	return 0;
-}
-
-static int display_logo(struct display_state *state)
-{
-	struct crtc_state *crtc_state = &state->crtc_state;
-	struct connector_state *conn_state = &state->conn_state;
-	struct logo_info *logo = &state->logo;
-	int hdisplay, vdisplay, ret;
-
-	ret = display_init(state);
-	if (!state->is_init || ret)
-		return -ENODEV;
-
-	switch (logo->bpp) {
-	case 16:
-		crtc_state->format = ROCKCHIP_FMT_RGB565;
-		break;
-	case 24:
-		crtc_state->format = ROCKCHIP_FMT_RGB888;
-		break;
-	case 32:
-		crtc_state->format = ROCKCHIP_FMT_ARGB8888;
-		break;
-	default:
-		printf("can't support bmp bits[%d]\n", logo->bpp);
-		return -EINVAL;
-	}
-	hdisplay = conn_state->mode.hdisplay;
-	vdisplay = conn_state->mode.vdisplay;
-	crtc_state->src_w = logo->width;
-	crtc_state->src_h = logo->height;
-	crtc_state->src_x = 0;
-	crtc_state->src_y = 0;
-	crtc_state->ymirror = logo->ymirror;
-
-	crtc_state->dma_addr = (u32)(unsigned long)logo->mem + logo->offset;
-	crtc_state->xvir = ALIGN(crtc_state->src_w * logo->bpp, 32) >> 5;
-
-	if (logo->mode == ROCKCHIP_DISPLAY_FULLSCREEN) {
-		crtc_state->crtc_x = 0;
-		crtc_state->crtc_y = 0;
-		crtc_state->crtc_w = hdisplay;
-		crtc_state->crtc_h = vdisplay;
-	} else {
-		if (crtc_state->src_w >= hdisplay) {
-			crtc_state->crtc_x = 0;
-			crtc_state->crtc_w = hdisplay;
-		} else {
-			crtc_state->crtc_x = (hdisplay - crtc_state->src_w) / 2;
-			crtc_state->crtc_w = crtc_state->src_w;
-		}
-
-		if (crtc_state->src_h >= vdisplay) {
-			crtc_state->crtc_y = 0;
-			crtc_state->crtc_h = vdisplay;
-		} else {
-			crtc_state->crtc_y = (vdisplay - crtc_state->src_h) / 2;
-			crtc_state->crtc_h = crtc_state->src_h;
-		}
-	}
-
-	display_set_plane(state);
-	display_enable(state);
-
-	return 0;
-}
-
-static int get_crtc_id(ofnode connect)
-{
-	int phandle;
-	struct device_node *remote;
-	int val;
-
-	phandle = ofnode_read_u32_default(connect, "remote-endpoint", -1);
-	if (phandle < 0)
-		goto err;
-	remote = of_find_node_by_phandle(phandle);
-	val = ofnode_read_u32_default(np_to_ofnode(remote), "reg", -1);
-	if (val < 0)
-		goto err;
-
-	return val;
-err:
-	printf("Can't get crtc id, default set to id = 0\n");
-	return 0;
-}
-
-static int get_crtc_mcu_mode(struct crtc_state *crtc_state)
-{
-	ofnode mcu_node;
-	int total_pixel, cs_pst, cs_pend, rw_pst, rw_pend;
-
-	mcu_node = dev_read_subnode(crtc_state->dev, "mcu-timing");
-	if (!ofnode_valid(mcu_node))
-		return -ENODEV;
-
-#define FDT_GET_MCU_INT(val, name) \
-	do { \
-		val = ofnode_read_s32_default(mcu_node, name, -1); \
-		if (val < 0) { \
-			printf("Can't get %s\n", name); \
-			return -ENXIO; \
-		} \
-	} while (0)
-
-	FDT_GET_MCU_INT(total_pixel, "mcu-pix-total");
-	FDT_GET_MCU_INT(cs_pst, "mcu-cs-pst");
-	FDT_GET_MCU_INT(cs_pend, "mcu-cs-pend");
-	FDT_GET_MCU_INT(rw_pst, "mcu-rw-pst");
-	FDT_GET_MCU_INT(rw_pend, "mcu-rw-pend");
-
-	crtc_state->mcu_timing.mcu_pix_total = total_pixel;
-	crtc_state->mcu_timing.mcu_cs_pst = cs_pst;
-	crtc_state->mcu_timing.mcu_cs_pend = cs_pend;
-	crtc_state->mcu_timing.mcu_rw_pst = rw_pst;
-	crtc_state->mcu_timing.mcu_rw_pend = rw_pend;
-
-	return 0;
-}
-
-struct rockchip_logo_cache *find_or_alloc_logo_cache(const char *bmp)
-{
-	struct rockchip_logo_cache *tmp, *logo_cache = NULL;
-
-	list_for_each_entry(tmp, &logo_cache_list, head) {
-		if (!strcmp(tmp->name, bmp)) {
-			logo_cache = tmp;
-			break;
-		}
-	}
-
-	if (!logo_cache) {
-		logo_cache = malloc(sizeof(*logo_cache));
-		if (!logo_cache) {
-			printf("failed to alloc memory for logo cache\n");
-			return NULL;
-		}
-		memset(logo_cache, 0, sizeof(*logo_cache));
-		strcpy(logo_cache->name, bmp);
-		INIT_LIST_HEAD(&logo_cache->head);
-		list_add_tail(&logo_cache->head, &logo_cache_list);
-	}
-
-	return logo_cache;
-}
-
-/* Note: used only for rkfb kernel driver */
-static int load_kernel_bmp_logo(struct logo_info *logo, const char *bmp_name)
-{
-#ifdef CONFIG_ROCKCHIP_RESOURCE_IMAGE
-	void *dst = NULL;
-	int len, size;
-	struct bmp_header *header;
-
-	if (!logo || !bmp_name)
-		return -EINVAL;
-
-	header = malloc(RK_BLK_SIZE);
-	if (!header)
-		return -ENOMEM;
-
-	len = rockchip_read_resource_file(header, bmp_name, 0, RK_BLK_SIZE);
-	if (len != RK_BLK_SIZE) {
-		free(header);
-		return -EINVAL;
-	}
-	size = get_unaligned_le32(&header->file_size);
-	dst = (void *)(memory_start + MEMORY_POOL_SIZE / 2);
-	len = rockchip_read_resource_file(dst, bmp_name, 0, size);
-	if (len != size) {
-		printf("failed to load bmp %s\n", bmp_name);
-		free(header);
-		return -ENOENT;
-	}
-
-	logo->mem = dst;
-#endif
-
-	return 0;
-}
-
-static int load_bmp_logo(struct logo_info *logo, const char *bmp_name)
-{
-#ifdef CONFIG_ROCKCHIP_RESOURCE_IMAGE
-	struct rockchip_logo_cache *logo_cache;
-	struct bmp_header *header;
-	void *dst = NULL, *pdst;
-	int size, len;
-	int ret = 0;
-	int reserved = 0;
-
-	if (!logo || !bmp_name)
-		return -EINVAL;
-	logo_cache = find_or_alloc_logo_cache(bmp_name);
-	if (!logo_cache)
-		return -ENOMEM;
-
-	if (logo_cache->logo.mem) {
-		memcpy(logo, &logo_cache->logo, sizeof(*logo));
-		return 0;
-	}
-
-	header = malloc(RK_BLK_SIZE);
-	if (!header)
-		return -ENOMEM;
-
-	len = rockchip_read_resource_file(header, bmp_name, 0, RK_BLK_SIZE);
-	if (len != RK_BLK_SIZE) {
-		ret = -EINVAL;
-		goto free_header;
-	}
-
-	logo->bpp = get_unaligned_le16(&header->bit_count);
-	logo->width = get_unaligned_le32(&header->width);
-	logo->height = get_unaligned_le32(&header->height);
-	reserved = get_unaligned_le32(&header->reserved);
-	if (logo->height < 0)
-	    logo->height = -logo->height;
-	size = get_unaligned_le32(&header->file_size);
-	if (!can_direct_logo(logo->bpp)) {
-		if (size > MEMORY_POOL_SIZE) {
-			printf("failed to use boot buf as temp bmp buffer\n");
-			ret = -ENOMEM;
-			goto free_header;
-		}
-		pdst = get_display_buffer(size);
-
-	} else {
-		pdst = get_display_buffer(size);
-		dst = pdst;
-	}
-
-	len = rockchip_read_resource_file(pdst, bmp_name, 0, size);
-	if (len != size) {
-		printf("failed to load bmp %s\n", bmp_name);
-		ret = -ENOENT;
-		goto free_header;
-	}
-
-	if (!can_direct_logo(logo->bpp)) {
-		int dst_size;
-		/*
-		 * TODO: force use 16bpp if bpp less than 16;
-		 */
-		logo->bpp = (logo->bpp <= 16) ? 16 : logo->bpp;
-		dst_size = logo->width * logo->height * logo->bpp >> 3;
-
-		dst = get_display_buffer(dst_size);
-		if (!dst) {
-			ret = -ENOMEM;
-			goto free_header;
-		}
-		if (bmpdecoder(pdst, dst, logo->bpp)) {
-			printf("failed to decode bmp %s\n", bmp_name);
-			ret = -EINVAL;
-			goto free_header;
-		}
-		flush_dcache_range((ulong)dst,
-				   ALIGN((ulong)dst + dst_size,
-					 CONFIG_SYS_CACHELINE_SIZE));
-
-		logo->offset = 0;
-		logo->ymirror = 0;
-	} else {
-		logo->offset = get_unaligned_le32(&header->data_offset);
-		if (reserved == BMP_PROCESSED_FLAG)
-			logo->ymirror = 0;
-		else
-			logo->ymirror = 1;
-	}
-	logo->mem = dst;
-
-	memcpy(&logo_cache->logo, logo, sizeof(*logo));
-
-free_header:
-
-	free(header);
-
-	return ret;
-#else
-	return -EINVAL;
-#endif
-}
-
-void rockchip_show_fbbase(ulong fbbase)
-{
-	struct display_state *s;
-
-	list_for_each_entry(s, &rockchip_display_list, head) {
-		s->logo.mode = ROCKCHIP_DISPLAY_FULLSCREEN;
-		s->logo.mem = (char *)fbbase;
-		s->logo.width = DRM_ROCKCHIP_FB_WIDTH;
-		s->logo.height = DRM_ROCKCHIP_FB_HEIGHT;
-		s->logo.bpp = 32;
-		s->logo.ymirror = 0;
-
-		display_logo(s);
-	}
-}
-
-int rockchip_show_bmp(const char *bmp)
-{
-	struct display_state *s;
-	int ret = 0;
-
-	if (!bmp) {
-		list_for_each_entry(s, &rockchip_display_list, head)
-			display_disable(s);
-		return -ENOENT;
-	}
-
-	list_for_each_entry(s, &rockchip_display_list, head) {
-		s->logo.mode = s->charge_logo_mode;
-		if (load_bmp_logo(&s->logo, bmp))
-			continue;
-		ret = display_logo(s);
-	}
-
-	return ret;
-}
-
-int rockchip_show_logo(void)
-{
-	struct display_state *s;
-	int ret = 0;
-
-	list_for_each_entry(s, &rockchip_display_list, head) {
-		s->logo.mode = s->logo_mode;
-		if (load_bmp_logo(&s->logo, s->ulogo_name))
-			printf("failed to display uboot logo\n");
-		else
-			ret = display_logo(s);
-
-		/* Load kernel bmp in rockchip_display_fixup() later */
-	}
-
-	return ret;
-}
-
-enum {
-	PORT_DIR_IN,
-	PORT_DIR_OUT,
-};
-
-static struct rockchip_panel *rockchip_of_find_panel(struct udevice *dev)
-{
-	ofnode panel_node, ports, port, ep, port_parent_node;
-	struct udevice *panel_dev;
-	int ret;
-
-	panel_node = dev_read_subnode(dev, "panel");
-	if (ofnode_valid(panel_node) && ofnode_is_available(panel_node)) {
-		ret = uclass_get_device_by_ofnode(UCLASS_PANEL, panel_node,
-						  &panel_dev);
-		if (!ret)
-			goto found;
-	}
-
-	ports = dev_read_subnode(dev, "ports");
-	if (!ofnode_valid(ports))
-		return NULL;
-
-	ofnode_for_each_subnode(port, ports) {
-		u32 reg;
-
-		if (ofnode_read_u32(port, "reg", &reg))
-			continue;
-
-		if (reg != PORT_DIR_OUT)
-			continue;
-
-		ofnode_for_each_subnode(ep, port) {
-			ofnode _ep, _port;
-			uint phandle;
-			bool is_ports_node = false;
-
-			if (ofnode_read_u32(ep, "remote-endpoint", &phandle))
-				continue;
-
-			_ep = ofnode_get_by_phandle(phandle);
-			if (!ofnode_valid(_ep))
-				continue;
-
-			_port = ofnode_get_parent(_ep);
-			if (!ofnode_valid(_port))
-				continue;
-
-			port_parent_node = ofnode_get_parent(_port);
-			is_ports_node = strstr(port_parent_node.np->full_name, "ports") ? 1 : 0;
-			if (is_ports_node)
-				panel_node = ofnode_get_parent(port_parent_node);
-			else
-				panel_node = ofnode_get_parent(_port);
-			if (!ofnode_valid(panel_node))
-				continue;
-
-			ret = uclass_get_device_by_ofnode(UCLASS_PANEL,
-							  panel_node,
-							  &panel_dev);
-			if (!ret)
-				goto found;
-		}
-	}
-
-	return NULL;
-
-found:
-	return (struct rockchip_panel *)dev_get_driver_data(panel_dev);
-}
-
-static struct rockchip_bridge *rockchip_of_find_bridge(struct udevice *conn_dev)
-{
-	ofnode node, ports, port, ep;
-	struct udevice *dev;
-	int ret;
-
-	ports = dev_read_subnode(conn_dev, "ports");
-	if (!ofnode_valid(ports))
-		return NULL;
-
-	ofnode_for_each_subnode(port, ports) {
-		u32 reg;
-
-		if (ofnode_read_u32(port, "reg", &reg))
-			continue;
-
-		if (reg != PORT_DIR_OUT)
-			continue;
-
-		ofnode_for_each_subnode(ep, port) {
-			ofnode _ep, _port, _ports;
-			uint phandle;
-
-			if (ofnode_read_u32(ep, "remote-endpoint", &phandle))
-				continue;
-
-			_ep = ofnode_get_by_phandle(phandle);
-			if (!ofnode_valid(_ep))
-				continue;
-
-			_port = ofnode_get_parent(_ep);
-			if (!ofnode_valid(_port))
-				continue;
-
-			_ports = ofnode_get_parent(_port);
-			if (!ofnode_valid(_ports))
-				continue;
-
-			node = ofnode_get_parent(_ports);
-			if (!ofnode_valid(node))
-				continue;
-
-			ret = uclass_get_device_by_ofnode(UCLASS_VIDEO_BRIDGE,
-							  node, &dev);
-			if (!ret)
-				goto found;
-		}
-	}
-
-	return NULL;
-
-found:
-	return (struct rockchip_bridge *)dev_get_driver_data(dev);
-}
-
-static struct udevice *rockchip_of_find_connector(ofnode endpoint)
-{
-	ofnode ep, port, ports, conn;
-	uint phandle;
-	struct udevice *dev;
-	int ret;
-
-	if (ofnode_read_u32(endpoint, "remote-endpoint", &phandle))
-		return NULL;
-
-	ep = ofnode_get_by_phandle(phandle);
-	if (!ofnode_valid(ep) || !ofnode_is_available(ep))
-		return NULL;
-
-	port = ofnode_get_parent(ep);
-	if (!ofnode_valid(port))
-		return NULL;
-
-	ports = ofnode_get_parent(port);
-	if (!ofnode_valid(ports))
-		return NULL;
-
-	conn = ofnode_get_parent(ports);
-	if (!ofnode_valid(conn) || !ofnode_is_available(conn))
-		return NULL;
-
-	ret = uclass_get_device_by_ofnode(UCLASS_DISPLAY, conn, &dev);
-	if (ret)
-		return NULL;
-
-	return dev;
-}
-
-static bool rockchip_get_display_path_status(ofnode endpoint)
-{
-	ofnode ep;
-	uint phandle;
-
-	if (ofnode_read_u32(endpoint, "remote-endpoint", &phandle))
-		return false;
-
-	ep = ofnode_get_by_phandle(phandle);
-	if (!ofnode_valid(ep) || !ofnode_is_available(ep))
-		return false;
-
-	return true;
-}
-
-static struct rockchip_phy *rockchip_of_find_phy(struct udevice *dev)
-{
-	struct udevice *phy_dev;
-	int ret;
-
-	ret = uclass_get_device_by_phandle(UCLASS_PHY, dev, "phys", &phy_dev);
-	if (ret)
-		return NULL;
-
-	return (struct rockchip_phy *)dev_get_driver_data(phy_dev);
-}
-
-#if defined(CONFIG_ROCKCHIP_RK3568)
-static int rockchip_display_fixup_dts(void *blob)
-{
-	ofnode route_node, route_subnode, conn_ep, conn_port;
-	const struct device_node *route_sub_devnode;
-	const struct device_node *ep_node, *conn_ep_dev_node;
-	u32 phandle;
-	int conn_ep_offset;
-	const char *route_sub_path, *path;
-
-	/* Don't go further if new variant after
-	 * reading PMUGRF_SOC_CON15
-	 */
-	if ((readl(0xfdc20100) & GENMASK(15, 14)))
-		return 0;
-
-	route_node = ofnode_path("/display-subsystem/route");
-	if (!ofnode_valid(route_node))
-		return -EINVAL;
-
-	ofnode_for_each_subnode(route_subnode, route_node) {
-		if (!ofnode_is_available(route_subnode))
-			continue;
-
-		route_sub_devnode = ofnode_to_np(route_subnode);
-		route_sub_path = route_sub_devnode->full_name;
-		if (!strstr(ofnode_get_name(route_subnode), "dsi") &&
-		    !strstr(ofnode_get_name(route_subnode), "edp"))
-			return 0;
-
-		phandle = ofnode_read_u32_default(route_subnode, "connect", -1);
-		if (phandle < 0) {
-			printf("Warn: can't find connect node's handle\n");
-			continue;
-		}
-
-		ep_node = of_find_node_by_phandle(phandle);
-		if (!ofnode_valid(np_to_ofnode(ep_node))) {
-			printf("Warn: can't find endpoint node from phandle\n");
-			continue;
-		}
-
-		ofnode_read_u32(np_to_ofnode(ep_node), "remote-endpoint", &phandle);
-		conn_ep = ofnode_get_by_phandle(phandle);
-		if (!ofnode_valid(conn_ep) || !ofnode_is_available(conn_ep))
-			return -ENODEV;
-
-		conn_port = ofnode_get_parent(conn_ep);
-		if (!ofnode_valid(conn_port))
-			return -ENODEV;
-
-		ofnode_for_each_subnode(conn_ep, conn_port) {
-			conn_ep_dev_node = ofnode_to_np(conn_ep);
-			path = conn_ep_dev_node->full_name;
-			ofnode_read_u32(conn_ep, "remote-endpoint", &phandle);
-			conn_ep_offset = fdt_path_offset(blob, path);
-
-			if (!ofnode_is_available(conn_ep) &&
-			    strstr(ofnode_get_name(conn_ep), "endpoint@0")) {
-				do_fixup_by_path_u32(blob, route_sub_path,
-						     "connect", phandle, 1);
-				fdt_status_okay(blob, conn_ep_offset);
-
-			} else if (ofnode_is_available(conn_ep) &&
-				   strstr(ofnode_get_name(conn_ep), "endpoint@1")) {
-				fdt_status_disabled(blob, conn_ep_offset);
-			}
-		}
-	}
-
-	return 0;
-}
-#endif
-
-static int rockchip_display_probe(struct udevice *dev)
-{
-	struct video_priv *uc_priv = dev_get_uclass_priv(dev);
-	struct video_uc_platdata *plat = dev_get_uclass_platdata(dev);
-	const void *blob = gd->fdt_blob;
-	int phandle;
-	struct udevice *crtc_dev, *conn_dev;
-	struct rockchip_crtc *crtc;
-	const struct rockchip_connector *conn;
-	struct rockchip_panel *panel = NULL;
-	struct rockchip_bridge *bridge = NULL;
-	struct rockchip_phy *phy = NULL;
-	struct display_state *s;
-	const char *name;
-	int ret;
-	ofnode node, route_node;
-	struct device_node *port_node, *vop_node, *ep_node, *port_parent_node;
-	struct public_phy_data *data;
-	bool is_ports_node = false;
-
-#if defined(CONFIG_ROCKCHIP_RK3568)
-	rockchip_display_fixup_dts((void *)blob);
-#endif
-
-	/* Before relocation we don't need to do anything */
-	if (!(gd->flags & GD_FLG_RELOC))
-		return 0;
-
-	data = malloc(sizeof(struct public_phy_data));
-	if (!data) {
-		printf("failed to alloc phy data\n");
-		return -ENOMEM;
-	}
-	data->phy_init = false;
-
-	init_display_buffer(plat->base);
-
-	route_node = dev_read_subnode(dev, "route");
-	if (!ofnode_valid(route_node))
-		return -ENODEV;
-
-	ofnode_for_each_subnode(node, route_node) {
-		if (!ofnode_is_available(node))
-			continue;
-		phandle = ofnode_read_u32_default(node, "connect", -1);
-		if (phandle < 0) {
-			printf("Warn: can't find connect node's handle\n");
-			continue;
-		}
-		ep_node = of_find_node_by_phandle(phandle);
-		if (!ofnode_valid(np_to_ofnode(ep_node))) {
-			printf("Warn: can't find endpoint node from phandle\n");
-			continue;
-		}
-		port_node = of_get_parent(ep_node);
-		if (!ofnode_valid(np_to_ofnode(port_node))) {
-			printf("Warn: can't find port node from phandle\n");
-			continue;
-		}
-
-		port_parent_node = of_get_parent(port_node);
-		if (!ofnode_valid(np_to_ofnode(port_parent_node))) {
-			printf("Warn: can't find port parent node from phandle\n");
-			continue;
-		}
-
-		is_ports_node = strstr(port_parent_node->full_name, "ports") ? 1 : 0;
-		if (is_ports_node) {
-			vop_node = of_get_parent(port_parent_node);
-			if (!ofnode_valid(np_to_ofnode(vop_node))) {
-				printf("Warn: can't find crtc node from phandle\n");
-				continue;
-			}
-		} else {
-			vop_node = port_parent_node;
-		}
-
-		ret = uclass_get_device_by_ofnode(UCLASS_VIDEO_CRTC,
-						  np_to_ofnode(vop_node),
-						  &crtc_dev);
-		if (ret) {
-			printf("Warn: can't find crtc driver %d\n", ret);
-			continue;
-		}
-		crtc = (struct rockchip_crtc *)dev_get_driver_data(crtc_dev);
-
-		conn_dev = rockchip_of_find_connector(np_to_ofnode(ep_node));
-		if (!conn_dev) {
-			printf("Warn: can't find connect driver\n");
-			continue;
-		}
-
-		conn = (const struct rockchip_connector *)dev_get_driver_data(conn_dev);
-
-		phy = rockchip_of_find_phy(conn_dev);
-
-		bridge = rockchip_of_find_bridge(conn_dev);
-		if (bridge)
-			panel = rockchip_of_find_panel(bridge->dev);
-		else
-			panel = rockchip_of_find_panel(conn_dev);
-
-		s = malloc(sizeof(*s));
-		if (!s)
-			continue;
-
-		memset(s, 0, sizeof(*s));
-
-		INIT_LIST_HEAD(&s->head);
-		ret = ofnode_read_string_index(node, "logo,uboot", 0, &name);
-		if (!ret)
-			memcpy(s->ulogo_name, name, strlen(name));
-		ret = ofnode_read_string_index(node, "logo,kernel", 0, &name);
-		if (!ret)
-			memcpy(s->klogo_name, name, strlen(name));
-		ret = ofnode_read_string_index(node, "logo,mode", 0, &name);
-		if (!strcmp(name, "fullscreen"))
-			s->logo_mode = ROCKCHIP_DISPLAY_FULLSCREEN;
-		else
-			s->logo_mode = ROCKCHIP_DISPLAY_CENTER;
-		ret = ofnode_read_string_index(node, "charge_logo,mode", 0, &name);
-		if (!strcmp(name, "fullscreen"))
-			s->charge_logo_mode = ROCKCHIP_DISPLAY_FULLSCREEN;
-		else
-			s->charge_logo_mode = ROCKCHIP_DISPLAY_CENTER;
-
-		s->blob = blob;
-		s->panel_state.panel = panel;
-		s->conn_state.node = conn_dev->node;
-		s->conn_state.dev = conn_dev;
-		s->conn_state.connector = conn;
-		s->conn_state.phy = phy;
-		s->conn_state.bridge = bridge;
-		s->conn_state.overscan.left_margin = 100;
-		s->conn_state.overscan.right_margin = 100;
-		s->conn_state.overscan.top_margin = 100;
-		s->conn_state.overscan.bottom_margin = 100;
-		s->crtc_state.node = np_to_ofnode(vop_node);
-		s->crtc_state.dev = crtc_dev;
-		s->crtc_state.crtc = crtc;
-		s->crtc_state.crtc_id = get_crtc_id(np_to_ofnode(ep_node));
-		s->node = node;
-
-		if (is_ports_node) { /* only vop2 will get into here */
-			ofnode vp_node = np_to_ofnode(port_node);
-			static bool get_plane_mask_from_dts;
-
-			s->crtc_state.ports_node = port_parent_node;
-			if (!get_plane_mask_from_dts) {
-				ofnode vp_sub_node;
-				int vp_id = 0;
-				bool vp_enable = false;
-
-				ofnode_for_each_subnode(vp_node, np_to_ofnode(port_parent_node)) {
-					int cursor_plane = -1;
-
-					vp_id = ofnode_read_u32_default(vp_node, "reg", 0);
-					ret = ofnode_read_u32_default(vp_node, "rockchip,plane-mask", 0);
-
-					cursor_plane = ofnode_read_u32_default(vp_node, "cursor-win-id", -1);
-					s->crtc_state.crtc->vps[vp_id].cursor_plane = cursor_plane;
-					if (ret) {
-						int primary_plane = 0;
-
-						s->crtc_state.crtc->vps[vp_id].plane_mask = ret;
-						s->crtc_state.crtc->assign_plane |= true;
-						primary_plane = ofnode_read_u32_default(vp_node, "rockchip,primary-plane", 0);
-						printf("get vp%d plane mask:0x%x, primary id:%d, cursor_plane:%d, from dts\n",
-						       vp_id,
-						       s->crtc_state.crtc->vps[vp_id].plane_mask,
-						       primary_plane,
-						       cursor_plane);
-					}
-
-					/* To check current vp status */
-					vp_enable = false;
-					ofnode_for_each_subnode(vp_sub_node, vp_node)
-						vp_enable |= rockchip_get_display_path_status(vp_sub_node);
-					s->crtc_state.crtc->vps[vp_id].enable = vp_enable;
-				}
-				get_plane_mask_from_dts = true;
-			}
-		}
-
-		if (bridge)
-			bridge->state = s;
-
-		if (panel)
-			panel->state = s;
-
-		get_crtc_mcu_mode(&s->crtc_state);
-
-		ret = ofnode_read_u32_default(s->crtc_state.node,
-					      "rockchip,dual-channel-swap", 0);
-		s->crtc_state.dual_channel_swap = ret;
-		if (connector_panel_init(s)) {
-			printf("Warn: Failed to init panel drivers\n");
-			free(s);
-			continue;
-		}
-
-		if (connector_phy_init(s, data)) {
-			printf("Warn: Failed to init phy drivers\n");
-			free(s);
-			continue;
-		}
-		list_add_tail(&s->head, &rockchip_display_list);
-	}
-
-	if (list_empty(&rockchip_display_list)) {
-		debug("Failed to found available display route\n");
-		return -ENODEV;
-	}
-	rockchip_get_baseparameter();
-	display_pre_init();
-
-	uc_priv->xsize = DRM_ROCKCHIP_FB_WIDTH;
-	uc_priv->ysize = DRM_ROCKCHIP_FB_HEIGHT;
-	uc_priv->bpix = VIDEO_BPP32;
-
-	#ifdef CONFIG_DRM_ROCKCHIP_VIDEO_FRAMEBUFFER
-	rockchip_show_fbbase(plat->base);
-	video_set_flush_dcache(dev, true);
-	#endif
-
-	return 0;
-}
-
-void rockchip_display_fixup(void *blob)
-{
-	const struct rockchip_connector_funcs *conn_funcs;
-	const struct rockchip_crtc_funcs *crtc_funcs;
-	const struct rockchip_connector *conn;
-	const struct rockchip_crtc *crtc;
-	struct display_state *s;
-	int offset;
-	const struct device_node *np;
-	const char *path;
-
-	if (fdt_node_offset_by_compatible(blob, 0, "rockchip,drm-logo") >= 0) {
-		list_for_each_entry(s, &rockchip_display_list, head)
-			load_bmp_logo(&s->logo, s->klogo_name);
-
-		if (!get_display_size())
-			return;
-
-		offset = fdt_update_reserved_memory(blob, "rockchip,drm-logo",
-						    (u64)memory_start,
-						    (u64)get_display_size());
-		if (offset < 0)
-			printf("failed to reserve drm-loader-logo memory\n");
-
-		offset = fdt_update_reserved_memory(blob, "rockchip,drm-cubic-lut",
-						    (u64)cubic_lut_memory_start,
-						    (u64)get_cubic_memory_size());
-		if (offset < 0)
-			printf("failed to reserve drm-cubic-lut memory\n");
-	} else {
-		printf("can't found rockchip,drm-logo, use rockchip,fb-logo\n");
-		/* Compatible with rkfb display, only need reserve memory */
-		offset = fdt_update_reserved_memory(blob, "rockchip,fb-logo",
-						    (u64)memory_start,
-						    MEMORY_POOL_SIZE);
-		if (offset < 0)
-			printf("failed to reserve fb-loader-logo memory\n");
-		else
-			list_for_each_entry(s, &rockchip_display_list, head)
-				load_kernel_bmp_logo(&s->logo, s->klogo_name);
-		return;
-	}
-
-	list_for_each_entry(s, &rockchip_display_list, head) {
-		conn = s->conn_state.connector;
-		if (!conn)
-			continue;
-		conn_funcs = conn->funcs;
-		if (!conn_funcs) {
-			printf("failed to get exist connector\n");
-			continue;
-		}
-
-		crtc = s->crtc_state.crtc;
-		if (!crtc)
-			continue;
-
-		crtc_funcs = crtc->funcs;
-		if (!crtc_funcs) {
-			printf("failed to get exist crtc\n");
-			continue;
-		}
-
-		if (crtc_funcs->fixup_dts)
-			crtc_funcs->fixup_dts(s, blob);
-
-		if (conn_funcs->fixup_dts)
-			conn_funcs->fixup_dts(s, blob);
-
-		np = ofnode_to_np(s->node);
-		path = np->full_name;
-		fdt_increase_size(blob, 0x400);
-#define FDT_SET_U32(name, val) \
-		do_fixup_by_path_u32(blob, path, name, val, 1);
-
-		offset = s->logo.offset + (u32)(unsigned long)s->logo.mem
-			 - memory_start;
-		FDT_SET_U32("logo,offset", offset);
-		FDT_SET_U32("logo,width", s->logo.width);
-		FDT_SET_U32("logo,height", s->logo.height);
-		FDT_SET_U32("logo,bpp", s->logo.bpp);
-		FDT_SET_U32("logo,ymirror", s->logo.ymirror);
-		FDT_SET_U32("video,clock", s->conn_state.mode.clock);
-		FDT_SET_U32("video,hdisplay", s->conn_state.mode.hdisplay);
-		FDT_SET_U32("video,vdisplay", s->conn_state.mode.vdisplay);
-		FDT_SET_U32("video,crtc_hsync_end", s->conn_state.mode.crtc_hsync_end);
-		FDT_SET_U32("video,crtc_vsync_end", s->conn_state.mode.crtc_vsync_end);
-		FDT_SET_U32("video,vrefresh",
-			    drm_mode_vrefresh(&s->conn_state.mode));
-		FDT_SET_U32("video,flags", s->conn_state.mode.flags);
-		FDT_SET_U32("video,aspect_ratio", s->conn_state.mode.picture_aspect_ratio);
-		FDT_SET_U32("overscan,left_margin", s->conn_state.overscan.left_margin);
-		FDT_SET_U32("overscan,right_margin", s->conn_state.overscan.right_margin);
-		FDT_SET_U32("overscan,top_margin", s->conn_state.overscan.top_margin);
-		FDT_SET_U32("overscan,bottom_margin", s->conn_state.overscan.bottom_margin);
-
-		if (s->conn_state.disp_info) {
-			FDT_SET_U32("bcsh,brightness", s->conn_state.disp_info->bcsh_info.brightness);
-			FDT_SET_U32("bcsh,contrast", s->conn_state.disp_info->bcsh_info.contrast);
-			FDT_SET_U32("bcsh,saturation", s->conn_state.disp_info->bcsh_info.saturation);
-			FDT_SET_U32("bcsh,hue", s->conn_state.disp_info->bcsh_info.hue);
-		}
-
-		if (s->conn_state.disp_info->cubic_lut_data.size &&
-		    CONFIG_ROCKCHIP_CUBIC_LUT_SIZE)
-			FDT_SET_U32("cubic_lut,offset", get_cubic_lut_offset(s->crtc_state.crtc_id));
-
-#undef FDT_SET_U32
-	}
-}
-
-int rockchip_display_bind(struct udevice *dev)
-{
-	struct video_uc_platdata *plat = dev_get_uclass_platdata(dev);
-
-	plat->size = DRM_ROCKCHIP_FB_SIZE + MEMORY_POOL_SIZE;
-
-	return 0;
-}
-
-static const struct udevice_id rockchip_display_ids[] = {
-	{ .compatible = "rockchip,display-subsystem" },
-	{ }
-};
-
-U_BOOT_DRIVER(rockchip_display) = {
-	.name	= "rockchip_display",
-	.id	= UCLASS_VIDEO,
-	.of_match = rockchip_display_ids,
-	.bind	= rockchip_display_bind,
-	.probe	= rockchip_display_probe,
-};
-
-static int do_rockchip_logo_show(cmd_tbl_t *cmdtp, int flag, int argc,
-			char *const argv[])
-{
-	if (argc != 1)
-		return CMD_RET_USAGE;
-
-	rockchip_show_logo();
-
-	return 0;
-}
-
-static int do_rockchip_show_bmp(cmd_tbl_t *cmdtp, int flag, int argc,
-				char *const argv[])
-{
-	if (argc != 2)
-		return CMD_RET_USAGE;
-
-	rockchip_show_bmp(argv[1]);
-
-	return 0;
-}
-
-U_BOOT_CMD(
-	rockchip_show_logo, 1, 1, do_rockchip_logo_show,
-	"load and display log from resource partition",
-	NULL
-);
-
-U_BOOT_CMD(
-	rockchip_show_bmp, 2, 1, do_rockchip_show_bmp,
-	"load and display bmp from resource partition",
-	"    <bmp_name>"
-);
+version https://git-lfs.github.com/spec/v1
+oid sha256:fffde7b145018f698bdc02228450f353dc12f3c9902a91ba21bd8e47d1f2429f
+size 54126
diff --git a/u-boot/drivers/video/drm/rockchip_dw_hdmi.c b/u-boot/drivers/video/drm/rockchip_dw_hdmi.c
index 42707e2ae6..e6fbdcfb65 100644
--- a/u-boot/drivers/video/drm/rockchip_dw_hdmi.c
+++ b/u-boot/drivers/video/drm/rockchip_dw_hdmi.c
@@ -1,620 +1,3 @@
-/*
- * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <boot_rkimg.h>
-#include <asm/io.h>
-#include <dm/device.h>
-#include <linux/dw_hdmi.h>
-#include <linux/hdmi.h>
-#include <linux/media-bus-format.h>
-#include "rockchip_display.h"
-#include "rockchip_crtc.h"
-#include "rockchip_connector.h"
-#include "dw_hdmi.h"
-#include "rockchip_dw_hdmi.h"
-
-#define HDMI_SEL_LCDC(x, bit)  ((((x) & 1) << bit) | (1 << (16 + bit)))
-#define RK3288_GRF_SOC_CON6		0x025C
-#define RK3288_HDMI_LCDC_SEL		BIT(4)
-#define RK3399_GRF_SOC_CON20		0x6250
-#define RK3399_HDMI_LCDC_SEL		BIT(6)
-
-#define RK3228_IO_3V_DOMAIN              ((7 << 4) | (7 << (4 + 16)))
-#define RK3328_IO_3V_DOMAIN              (7 << (9 + 16))
-#define RK3328_IO_5V_DOMAIN              ((7 << 9) | (3 << (9 + 16)))
-#define RK3328_IO_CTRL_BY_HDMI           ((1 << 13) | (1 << (13 + 16)))
-#define RK3328_IO_DDC_IN_MSK             ((3 << 10) | (3 << (10 + 16)))
-#define RK3228_IO_DDC_IN_MSK             ((3 << 13) | (3 << (13 + 16)))
-#define RK3228_GRF_SOC_CON2              0x0408
-#define RK3228_GRF_SOC_CON6              0x0418
-#define RK3328_GRF_SOC_CON2              0x0408
-#define RK3328_GRF_SOC_CON3              0x040c
-#define RK3328_GRF_SOC_CON4              0x0410
-
-#define RK3568_GRF_VO_CON1               0x0364
-#define RK3568_HDMI_SDAIN_MSK            ((1 << 15) | (1 << (15 + 16)))
-#define RK3568_HDMI_SCLIN_MSK            ((1 << 14) | (1 << (14 + 16)))
-
-static const struct dw_hdmi_mpll_config rockchip_mpll_cfg[] = {
-	{
-		30666000, {
-			{ 0x00b3, 0x0000 },
-			{ 0x2153, 0x0000 },
-			{ 0x40f3, 0x0000 },
-		},
-	},  {
-		36800000, {
-			{ 0x00b3, 0x0000 },
-			{ 0x2153, 0x0000 },
-			{ 0x40a2, 0x0001 },
-		},
-	},  {
-		46000000, {
-			{ 0x00b3, 0x0000 },
-			{ 0x2142, 0x0001 },
-			{ 0x40a2, 0x0001 },
-		},
-	},  {
-		61333000, {
-			{ 0x0072, 0x0001 },
-			{ 0x2142, 0x0001 },
-			{ 0x40a2, 0x0001 },
-		},
-	},  {
-		73600000, {
-			{ 0x0072, 0x0001 },
-			{ 0x2142, 0x0001 },
-			{ 0x4061, 0x0002 },
-		},
-	},  {
-		92000000, {
-			{ 0x0072, 0x0001 },
-			{ 0x2145, 0x0002 },
-			{ 0x4061, 0x0002 },
-		},
-	},  {
-		122666000, {
-			{ 0x0051, 0x0002 },
-			{ 0x2145, 0x0002 },
-			{ 0x4061, 0x0002 },
-		},
-	},  {
-		147200000, {
-			{ 0x0051, 0x0002 },
-			{ 0x2145, 0x0002 },
-			{ 0x4064, 0x0003 },
-		},
-	},  {
-		184000000, {
-			{ 0x0051, 0x0002 },
-			{ 0x214c, 0x0003 },
-			{ 0x4064, 0x0003 },
-		},
-	},  {
-		226666000, {
-			{ 0x0040, 0x0003 },
-			{ 0x214c, 0x0003 },
-			{ 0x4064, 0x0003 },
-		},
-	},  {
-		272000000, {
-			{ 0x0040, 0x0003 },
-			{ 0x214c, 0x0003 },
-			{ 0x5a64, 0x0003 },
-		},
-	},  {
-		340000000, {
-			{ 0x0040, 0x0003 },
-			{ 0x3b4c, 0x0003 },
-			{ 0x5a64, 0x0003 },
-		},
-	},  {
-		600000000, {
-			{ 0x1a40, 0x0003 },
-			{ 0x3b4c, 0x0003 },
-			{ 0x5a64, 0x0003 },
-		},
-	},  {
-		~0UL, {
-			{ 0x0000, 0x0000 },
-			{ 0x0000, 0x0000 },
-			{ 0x0000, 0x0000 },
-		},
-	}
-};
-
-static const struct dw_hdmi_mpll_config rockchip_mpll_cfg_420[] = {
-	{
-		30666000, {
-			{ 0x00b7, 0x0000 },
-			{ 0x2157, 0x0000 },
-			{ 0x40f7, 0x0000 },
-		},
-	},  {
-		92000000, {
-			{ 0x00b7, 0x0000 },
-			{ 0x2143, 0x0001 },
-			{ 0x40a3, 0x0001 },
-		},
-	},  {
-		184000000, {
-			{ 0x0073, 0x0001 },
-			{ 0x2146, 0x0002 },
-			{ 0x4062, 0x0002 },
-		},
-	},  {
-		340000000, {
-			{ 0x0052, 0x0003 },
-			{ 0x214d, 0x0003 },
-			{ 0x4065, 0x0003 },
-		},
-	},  {
-		600000000, {
-			{ 0x0041, 0x0003 },
-			{ 0x3b4d, 0x0003 },
-			{ 0x5a65, 0x0003 },
-		},
-	},  {
-		~0UL, {
-			{ 0x0000, 0x0000 },
-			{ 0x0000, 0x0000 },
-			{ 0x0000, 0x0000 },
-		},
-	}
-};
-
-static const struct dw_hdmi_curr_ctrl rockchip_cur_ctr[] = {
-	/*      pixelclk    bpp8    bpp10   bpp12 */
-	{
-		600000000, { 0x0000, 0x0000, 0x0000 },
-	},  {
-		~0UL,      { 0x0000, 0x0000, 0x0000},
-	}
-};
-
-static const struct dw_hdmi_phy_config rockchip_phy_config[] = {
-	/*pixelclk   symbol   term   vlev*/
-	{ 74250000,  0x8009, 0x0004, 0x0272},
-	{ 165000000, 0x802b, 0x0004, 0x0209},
-	{ 297000000, 0x8039, 0x0005, 0x028d},
-	{ 594000000, 0x8039, 0x0000, 0x019d},
-	{ ~0UL,	     0x0000, 0x0000, 0x0000},
-	{ ~0UL,	     0x0000, 0x0000, 0x0000}
-};
-
-static unsigned int drm_rk_select_color(struct hdmi_edid_data *edid_data,
-					struct base_screen_info *screen_info,
-					enum dw_hdmi_devtype dev_type)
-{
-	struct drm_display_info *info = &edid_data->display_info;
-	struct drm_display_mode *mode = edid_data->preferred_mode;
-	int max_tmds_clock = info->max_tmds_clock;
-	bool support_dc = false;
-	bool mode_420 = drm_mode_is_420(info, mode);
-	unsigned int color_depth = 8;
-	unsigned int base_color = DRM_HDMI_OUTPUT_YCBCR444;
-	unsigned int color_format = DRM_HDMI_OUTPUT_DEFAULT_RGB;
-	unsigned long tmdsclock, pixclock = mode->clock;
-
-	if (screen_info)
-		base_color = screen_info->format;
-
-	switch (base_color) {
-	case DRM_HDMI_OUTPUT_YCBCR_HQ:
-		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
-			color_format = DRM_HDMI_OUTPUT_YCBCR444;
-		else if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
-			color_format = DRM_HDMI_OUTPUT_YCBCR422;
-		else if (mode_420)
-			color_format = DRM_HDMI_OUTPUT_YCBCR420;
-		break;
-	case DRM_HDMI_OUTPUT_YCBCR_LQ:
-		if (mode_420)
-			color_format = DRM_HDMI_OUTPUT_YCBCR420;
-		else if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
-			color_format = DRM_HDMI_OUTPUT_YCBCR422;
-		else if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
-			color_format = DRM_HDMI_OUTPUT_YCBCR444;
-		break;
-	case DRM_HDMI_OUTPUT_YCBCR420:
-		if (mode_420)
-			color_format = DRM_HDMI_OUTPUT_YCBCR420;
-		break;
-	case DRM_HDMI_OUTPUT_YCBCR422:
-		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
-			color_format = DRM_HDMI_OUTPUT_YCBCR422;
-		break;
-	case DRM_HDMI_OUTPUT_YCBCR444:
-		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
-			color_format = DRM_HDMI_OUTPUT_YCBCR444;
-		break;
-	case DRM_HDMI_OUTPUT_DEFAULT_RGB:
-	default:
-		break;
-	}
-
-	if (color_format == DRM_HDMI_OUTPUT_DEFAULT_RGB &&
-	    info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_30)
-		support_dc = true;
-	if (color_format == DRM_HDMI_OUTPUT_YCBCR444 &&
-	    (info->edid_hdmi_dc_modes &
-	     (DRM_EDID_HDMI_DC_Y444 | DRM_EDID_HDMI_DC_30)))
-		support_dc = true;
-	if (color_format == DRM_HDMI_OUTPUT_YCBCR422)
-		support_dc = true;
-	if (color_format == DRM_HDMI_OUTPUT_YCBCR420 &&
-	    info->hdmi.y420_dc_modes & DRM_EDID_YCBCR420_DC_30)
-		support_dc = true;
-
-	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
-		pixclock *= 2;
-
-	if (screen_info && screen_info->depth == 10)
-		color_depth = screen_info->depth;
-
-	if (color_format == DRM_HDMI_OUTPUT_YCBCR422 || color_depth == 8)
-		tmdsclock = pixclock;
-	else
-		tmdsclock = pixclock * color_depth / 8;
-
-	if (color_format == DRM_HDMI_OUTPUT_YCBCR420)
-		tmdsclock /= 2;
-
-	if (!max_tmds_clock)
-		max_tmds_clock = 340000;
-
-	switch (dev_type) {
-	case RK3368_HDMI:
-		max_tmds_clock = min(max_tmds_clock, 340000);
-		break;
-	case RK3328_HDMI:
-	case RK3228_HDMI:
-		max_tmds_clock = min(max_tmds_clock, 371250);
-		break;
-	default:
-		max_tmds_clock = min(max_tmds_clock, 594000);
-		break;
-	}
-
-	if (tmdsclock > max_tmds_clock) {
-		if (max_tmds_clock >= 594000) {
-			color_depth = 8;
-		} else if (max_tmds_clock > 340000) {
-			if (drm_mode_is_420(info, mode))
-				color_format = DRM_HDMI_OUTPUT_YCBCR420;
-		} else {
-			color_depth = 8;
-			if (drm_mode_is_420(info, mode))
-				color_format = DRM_HDMI_OUTPUT_YCBCR420;
-		}
-	}
-
-	if (color_depth > 8 && support_dc) {
-		if (dev_type == RK3288_HDMI)
-			return MEDIA_BUS_FMT_RGB101010_1X30;
-		switch (color_format) {
-		case DRM_HDMI_OUTPUT_YCBCR444:
-			return MEDIA_BUS_FMT_YUV10_1X30;
-		case DRM_HDMI_OUTPUT_YCBCR422:
-			return MEDIA_BUS_FMT_UYVY10_1X20;
-		case DRM_HDMI_OUTPUT_YCBCR420:
-			return MEDIA_BUS_FMT_UYYVYY10_0_5X30;
-		default:
-			return MEDIA_BUS_FMT_RGB101010_1X30;
-		}
-	} else {
-		if (dev_type == RK3288_HDMI)
-			return MEDIA_BUS_FMT_RGB888_1X24;
-		switch (color_format) {
-		case DRM_HDMI_OUTPUT_YCBCR444:
-			return MEDIA_BUS_FMT_YUV8_1X24;
-		case DRM_HDMI_OUTPUT_YCBCR422:
-			return MEDIA_BUS_FMT_UYVY8_1X16;
-		case DRM_HDMI_OUTPUT_YCBCR420:
-			return MEDIA_BUS_FMT_UYYVYY8_0_5X24;
-		default:
-			return MEDIA_BUS_FMT_RGB888_1X24;
-		}
-	}
-}
-
-void drm_rk_selete_output(struct hdmi_edid_data *edid_data,
-			  struct connector_state *conn_state,
-			  unsigned int *bus_format,
-			  struct overscan *overscan,
-			  enum dw_hdmi_devtype dev_type)
-{
-	int ret, i, screen_size;
-	struct base_disp_info base_parameter;
-	struct base2_disp_info *base2_parameter = conn_state->disp_info;
-	const struct base_overscan *scan;
-	struct base_screen_info *screen_info = NULL;
-	struct base2_screen_info *screen_info2 = NULL;
-	int max_scan = 100;
-	int min_scan = 51;
-	int offset = 0;
-	bool found = false;
-	struct blk_desc *dev_desc;
-	disk_partition_t part_info;
-	char baseparameter_buf[8 * RK_BLK_SIZE] __aligned(ARCH_DMA_MINALIGN);
-
-	overscan->left_margin = max_scan;
-	overscan->right_margin = max_scan;
-	overscan->top_margin = max_scan;
-	overscan->bottom_margin = max_scan;
-
-	if (dev_type == RK3288_HDMI)
-		*bus_format = MEDIA_BUS_FMT_RGB888_1X24;
-	else
-		*bus_format = MEDIA_BUS_FMT_YUV8_1X24;
-
-
-	*bus_format = MEDIA_BUS_FMT_RGB888_1X24;
-
-	if (!base2_parameter) {
-		dev_desc = rockchip_get_bootdev();
-		if (!dev_desc) {
-			printf("%s: Could not find device\n", __func__);
-			return;
-		}
-
-		ret = part_get_info_by_name(dev_desc, "baseparameter",
-					    &part_info);
-		if (ret < 0) {
-			printf("Could not find baseparameter partition\n");
-			return;
-		}
-
-read_aux:
-		ret = blk_dread(dev_desc, part_info.start + offset, 1,
-				(void *)baseparameter_buf);
-		if (ret < 0) {
-			printf("read baseparameter failed\n");
-			return;
-		}
-
-		memcpy(&base_parameter, baseparameter_buf,
-		       sizeof(base_parameter));
-		scan = &base_parameter.scan;
-
-		screen_size = sizeof(base_parameter.screen_list) /
-			sizeof(base_parameter.screen_list[0]);
-
-		for (i = 0; i < screen_size; i++) {
-			if (base_parameter.screen_list[i].type ==
-			    DRM_MODE_CONNECTOR_HDMIA) {
-				found = true;
-				screen_info = &base_parameter.screen_list[i];
-				break;
-			}
-		}
-
-		if (!found && !offset) {
-			printf("hdmi info isn't saved in main block\n");
-			offset += 16;
-			goto read_aux;
-		}
-	} else {
-		scan = &base2_parameter->overscan_info;
-		screen_size = sizeof(base2_parameter->screen_info) /
-			sizeof(base2_parameter->screen_info[0]);
-
-		for (i = 0; i < screen_size; i++) {
-			if (base2_parameter->screen_info[i].type ==
-			    DRM_MODE_CONNECTOR_HDMIA) {
-				screen_info2 =
-					&base2_parameter->screen_info[i];
-				break;
-			}
-		}
-		screen_info = malloc(sizeof(*screen_info));
-
-		screen_info->type = screen_info2->type;
-		screen_info->mode = screen_info2->resolution;
-		screen_info->format = screen_info2->format;
-		screen_info->depth = screen_info2->depthc;
-		screen_info->feature = screen_info2->feature;
-	}
-
-	if (scan->leftscale < min_scan && scan->leftscale > 0)
-		overscan->left_margin = min_scan;
-	else if (scan->leftscale < max_scan && scan->leftscale > 0)
-		overscan->left_margin = scan->leftscale;
-
-	if (scan->rightscale < min_scan && scan->rightscale > 0)
-		overscan->right_margin = min_scan;
-	else if (scan->rightscale < max_scan && scan->rightscale > 0)
-		overscan->right_margin = scan->rightscale;
-
-	if (scan->topscale < min_scan && scan->topscale > 0)
-		overscan->top_margin = min_scan;
-	else if (scan->topscale < max_scan && scan->topscale > 0)
-		overscan->top_margin = scan->topscale;
-
-	if (scan->bottomscale < min_scan && scan->bottomscale > 0)
-		overscan->bottom_margin = min_scan;
-	else if (scan->bottomscale < max_scan && scan->bottomscale > 0)
-		overscan->bottom_margin = scan->bottomscale;
-
-
-
-	if (screen_info)
-		printf("base_parameter.mode:%dx%d\n",
-		       screen_info->mode.hdisplay,
-		       screen_info->mode.vdisplay);
-	drm_rk_select_mode(edid_data, screen_info);
-
-	*bus_format = drm_rk_select_color(edid_data, screen_info,
-					  dev_type);
-}
-
-void inno_dw_hdmi_set_domain(void *grf, int status)
-{
-	if (status)
-		writel(RK3328_IO_5V_DOMAIN, grf + RK3328_GRF_SOC_CON4);
-	else
-		writel(RK3328_IO_3V_DOMAIN, grf + RK3328_GRF_SOC_CON4);
-}
-
-void dw_hdmi_set_iomux(void *grf, int dev_type)
-{
-	switch (dev_type) {
-	case RK3328_HDMI:
-		writel(RK3328_IO_DDC_IN_MSK, grf + RK3328_GRF_SOC_CON2);
-		writel(RK3328_IO_CTRL_BY_HDMI, grf + RK3328_GRF_SOC_CON3);
-		break;
-	case RK3228_HDMI:
-		writel(RK3228_IO_3V_DOMAIN, grf + RK3228_GRF_SOC_CON6);
-		writel(RK3228_IO_DDC_IN_MSK, grf + RK3228_GRF_SOC_CON2);
-		break;
-	case RK3568_HDMI:
-		writel(RK3568_HDMI_SDAIN_MSK | RK3568_HDMI_SCLIN_MSK,
-		       grf + RK3568_GRF_VO_CON1);
-		break;
-	default:
-		break;
-	}
-}
-
-static const struct dw_hdmi_phy_ops inno_dw_hdmi_phy_ops = {
-	.init = inno_dw_hdmi_phy_init,
-	.disable = inno_dw_hdmi_phy_disable,
-	.read_hpd = inno_dw_hdmi_phy_read_hpd,
-	.mode_valid = inno_dw_hdmi_mode_valid,
-};
-
-static const struct rockchip_connector_funcs rockchip_dw_hdmi_funcs = {
-	.pre_init = rockchip_dw_hdmi_pre_init,
-	.init = rockchip_dw_hdmi_init,
-	.deinit = rockchip_dw_hdmi_deinit,
-	.prepare = rockchip_dw_hdmi_prepare,
-	.enable = rockchip_dw_hdmi_enable,
-	.disable = rockchip_dw_hdmi_disable,
-	.get_timing = rockchip_dw_hdmi_get_timing,
-	.detect = rockchip_dw_hdmi_detect,
-	.get_edid = rockchip_dw_hdmi_get_edid,
-};
-
-const struct dw_hdmi_plat_data rk3288_hdmi_drv_data = {
-	.vop_sel_bit = 4,
-	.grf_vop_sel_reg = RK3288_GRF_SOC_CON6,
-	.mpll_cfg   = rockchip_mpll_cfg,
-	.cur_ctr    = rockchip_cur_ctr,
-	.phy_config = rockchip_phy_config,
-	.dev_type   = RK3288_HDMI,
-};
-
-const struct dw_hdmi_plat_data rk3328_hdmi_drv_data = {
-	.vop_sel_bit = 0,
-	.grf_vop_sel_reg = 0,
-	.phy_ops    = &inno_dw_hdmi_phy_ops,
-	.phy_name   = "inno_dw_hdmi_phy2",
-	.dev_type   = RK3328_HDMI,
-};
-
-const struct dw_hdmi_plat_data rk3228_hdmi_drv_data = {
-	.vop_sel_bit = 0,
-	.grf_vop_sel_reg = 0,
-	.phy_ops    = &inno_dw_hdmi_phy_ops,
-	.phy_name   = "inno_dw_hdmi_phy",
-	.dev_type   = RK3228_HDMI,
-};
-
-const struct dw_hdmi_plat_data rk3368_hdmi_drv_data = {
-	.mpll_cfg   = rockchip_mpll_cfg,
-	.cur_ctr    = rockchip_cur_ctr,
-	.phy_config = rockchip_phy_config,
-	.mpll_cfg_420 = rockchip_mpll_cfg_420,
-	.dev_type   = RK3368_HDMI,
-};
-
-const struct dw_hdmi_plat_data rk3399_hdmi_drv_data = {
-	.vop_sel_bit = 6,
-	.grf_vop_sel_reg = RK3399_GRF_SOC_CON20,
-	.mpll_cfg   = rockchip_mpll_cfg,
-	.cur_ctr    = rockchip_cur_ctr,
-	.phy_config = rockchip_phy_config,
-	.mpll_cfg_420 = rockchip_mpll_cfg_420,
-	.dev_type   = RK3399_HDMI,
-};
-
-const struct dw_hdmi_plat_data rk3568_hdmi_drv_data = {
-	.vop_sel_bit = 0,
-	.grf_vop_sel_reg = 0,
-	.mpll_cfg   = rockchip_mpll_cfg,
-	.cur_ctr    = rockchip_cur_ctr,
-	.phy_config = rockchip_phy_config,
-	.mpll_cfg_420 = rockchip_mpll_cfg_420,
-	.dev_type   = RK3568_HDMI,
-};
-
-static int rockchip_dw_hdmi_probe(struct udevice *dev)
-{
-	return 0;
-}
-
-static const struct rockchip_connector rk3568_dw_hdmi_data = {
-	.funcs = &rockchip_dw_hdmi_funcs,
-	.data = &rk3568_hdmi_drv_data,
-};
-
-static const struct rockchip_connector rk3399_dw_hdmi_data = {
-	.funcs = &rockchip_dw_hdmi_funcs,
-	.data = &rk3399_hdmi_drv_data,
-};
-
-static const struct rockchip_connector rk3368_dw_hdmi_data = {
-	.funcs = &rockchip_dw_hdmi_funcs,
-	.data = &rk3368_hdmi_drv_data,
-};
-
-static const struct rockchip_connector rk3288_dw_hdmi_data = {
-	.funcs = &rockchip_dw_hdmi_funcs,
-	.data = &rk3288_hdmi_drv_data,
-};
-
-static const struct rockchip_connector rk3328_dw_hdmi_data = {
-	.funcs = &rockchip_dw_hdmi_funcs,
-	.data = &rk3328_hdmi_drv_data,
-};
-
-static const struct rockchip_connector rk3228_dw_hdmi_data = {
-	.funcs = &rockchip_dw_hdmi_funcs,
-	.data = &rk3228_hdmi_drv_data,
-};
-
-static const struct udevice_id rockchip_dw_hdmi_ids[] = {
-	{
-	 .compatible = "rockchip,rk3568-dw-hdmi",
-	 .data = (ulong)&rk3568_dw_hdmi_data,
-	}, {
-	 .compatible = "rockchip,rk3399-dw-hdmi",
-	 .data = (ulong)&rk3399_dw_hdmi_data,
-	}, {
-	 .compatible = "rockchip,rk3368-dw-hdmi",
-	 .data = (ulong)&rk3368_dw_hdmi_data,
-	}, {
-	 .compatible = "rockchip,rk3288-dw-hdmi",
-	 .data = (ulong)&rk3288_dw_hdmi_data,
-	}, {
-	 .compatible = "rockchip,rk3328-dw-hdmi",
-	 .data = (ulong)&rk3328_dw_hdmi_data,
-	}, {
-	 .compatible = "rockchip,rk3128-inno-hdmi",
-	 .data = (ulong)&rk3228_dw_hdmi_data,
-	}, {
-	 .compatible = "rockchip,rk3228-dw-hdmi",
-	 .data = (ulong)&rk3228_dw_hdmi_data,
-	}, {}
-};
-
-U_BOOT_DRIVER(rockchip_dw_hdmi) = {
-	.name = "rockchip_dw_hdmi",
-	.id = UCLASS_DISPLAY,
-	.of_match = rockchip_dw_hdmi_ids,
-	.probe	= rockchip_dw_hdmi_probe,
-};
+version https://git-lfs.github.com/spec/v1
+oid sha256:8b382ee6736a6b37e2660f3a57420a017442557c398d0ff40222655bdd55615c
+size 16290
diff --git a/u-boot/drivers/video/drm/rockchip_panel.c b/u-boot/drivers/video/drm/rockchip_panel.c
index 7488ffff55..d272a5cf22 100644
--- a/u-boot/drivers/video/drm/rockchip_panel.c
+++ b/u-boot/drivers/video/drm/rockchip_panel.c
@@ -1,581 +1,3 @@
-/*
- * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <drm/drm_mipi_dsi.h>
-
-#include <config.h>
-#include <common.h>
-#include <errno.h>
-#include <malloc.h>
-#include <video.h>
-#include <backlight.h>
-#include <asm/gpio.h>
-#include <dm/device.h>
-#include <dm/read.h>
-#include <dm/uclass.h>
-#include <dm/uclass-id.h>
-#include <linux/media-bus-format.h>
-#include <power/regulator.h>
-
-#include "rockchip_display.h"
-#include "rockchip_crtc.h"
-#include "rockchip_connector.h"
-#include "rockchip_panel.h"
-
-struct rockchip_cmd_header {
-	u8 data_type;
-	u8 delay_ms;
-	u8 payload_length;
-} __packed;
-
-struct rockchip_cmd_desc {
-	struct rockchip_cmd_header header;
-	const u8 *payload;
-};
-
-struct rockchip_panel_cmds {
-	struct rockchip_cmd_desc *cmds;
-	int cmd_cnt;
-};
-
-struct rockchip_panel_plat {
-	bool power_invert;
-	u32 bus_format;
-	unsigned int bpc;
-
-	struct {
-		unsigned int prepare;
-		unsigned int unprepare;
-		unsigned int enable;
-		unsigned int disable;
-		unsigned int reset;
-		unsigned int init;
-	} delay;
-
-	struct rockchip_panel_cmds *on_cmds;
-	struct rockchip_panel_cmds *off_cmds;
-};
-
-struct rockchip_panel_priv {
-	bool prepared;
-	bool enabled;
-	struct udevice *power_supply;
-	struct udevice *backlight;
-	struct gpio_desc enable_gpio;
-	struct gpio_desc reset_gpio;
-	struct gpio_desc enable_5v_gpio;
-	struct gpio_desc enable_tc_gpio;
-
-	int cmd_type;
-	struct gpio_desc spi_sdi_gpio;
-	struct gpio_desc spi_scl_gpio;
-	struct gpio_desc spi_cs_gpio;
-};
-
-static inline int get_panel_cmd_type(const char *s)
-{
-	if (!s)
-		return -EINVAL;
-
-	if (strncmp(s, "spi", 3) == 0)
-		return CMD_TYPE_SPI;
-	else if (strncmp(s, "mcu", 3) == 0)
-		return CMD_TYPE_MCU;
-
-	return CMD_TYPE_DEFAULT;
-}
-
-static int rockchip_panel_parse_cmds(const u8 *data, int length,
-				     struct rockchip_panel_cmds *pcmds)
-{
-	int len;
-	const u8 *buf;
-	const struct rockchip_cmd_header *header;
-	int i, cnt = 0;
-
-	/* scan commands */
-	cnt = 0;
-	buf = data;
-	len = length;
-	while (len > sizeof(*header)) {
-		header = (const struct rockchip_cmd_header *)buf;
-		buf += sizeof(*header) + header->payload_length;
-		len -= sizeof(*header) + header->payload_length;
-		cnt++;
-	}
-
-	pcmds->cmds = calloc(cnt, sizeof(struct rockchip_cmd_desc));
-	if (!pcmds->cmds)
-		return -ENOMEM;
-
-	pcmds->cmd_cnt = cnt;
-
-	buf = data;
-	len = length;
-	for (i = 0; i < cnt; i++) {
-		struct rockchip_cmd_desc *desc = &pcmds->cmds[i];
-
-		header = (const struct rockchip_cmd_header *)buf;
-		length -= sizeof(*header);
-		buf += sizeof(*header);
-		desc->header.data_type = header->data_type;
-		desc->header.delay_ms = header->delay_ms;
-		desc->header.payload_length = header->payload_length;
-		desc->payload = buf;
-		buf += header->payload_length;
-		length -= header->payload_length;
-	}
-
-	return 0;
-}
-
-static void rockchip_panel_write_spi_cmds(struct rockchip_panel_priv *priv,
-					  u8 type, int value)
-{
-	int i;
-
-	dm_gpio_set_value(&priv->spi_cs_gpio, 0);
-
-	if (type == 0)
-		value &= (~(1 << 8));
-	else
-		value |= (1 << 8);
-
-	for (i = 0; i < 9; i++) {
-		if (value & 0x100)
-			dm_gpio_set_value(&priv->spi_sdi_gpio, 1);
-		else
-			dm_gpio_set_value(&priv->spi_sdi_gpio, 0);
-
-		dm_gpio_set_value(&priv->spi_scl_gpio, 0);
-		udelay(10);
-		dm_gpio_set_value(&priv->spi_scl_gpio, 1);
-		value <<= 1;
-		udelay(10);
-	}
-
-	dm_gpio_set_value(&priv->spi_cs_gpio, 1);
-}
-
-static int rockchip_panel_send_mcu_cmds(struct display_state *state,
-					struct rockchip_panel_cmds *cmds)
-{
-	int i;
-
-	if (!cmds)
-		return -EINVAL;
-
-	display_send_mcu_cmd(state, MCU_SETBYPASS, 1);
-	for (i = 0; i < cmds->cmd_cnt; i++) {
-		struct rockchip_cmd_desc *desc = &cmds->cmds[i];
-		int value = 0;
-
-		value = desc->payload[0];
-		display_send_mcu_cmd(state, desc->header.data_type, value);
-
-		if (desc->header.delay_ms)
-			mdelay(desc->header.delay_ms);
-	}
-	display_send_mcu_cmd(state, MCU_SETBYPASS, 0);
-
-	return 0;
-}
-
-static int rockchip_panel_send_spi_cmds(struct display_state *state,
-					struct rockchip_panel_cmds *cmds)
-{
-	struct rockchip_panel *panel = state_get_panel(state);
-	struct rockchip_panel_priv *priv = dev_get_priv(panel->dev);
-	int i;
-
-	if (!cmds)
-		return -EINVAL;
-
-	for (i = 0; i < cmds->cmd_cnt; i++) {
-		struct rockchip_cmd_desc *desc = &cmds->cmds[i];
-		int value = 0;
-
-		if (desc->header.payload_length == 2)
-			value = (desc->payload[0] << 8) | desc->payload[1];
-		else
-			value = desc->payload[0];
-		rockchip_panel_write_spi_cmds(priv,
-					      desc->header.data_type, value);
-
-		if (desc->header.delay_ms)
-			mdelay(desc->header.delay_ms);
-	}
-
-	return 0;
-}
-
-static int rockchip_panel_send_dsi_cmds(struct mipi_dsi_device *dsi,
-					struct rockchip_panel_cmds *cmds)
-{
-	int i, ret;
-
-	if (!cmds)
-		return -EINVAL;
-
-	for (i = 0; i < cmds->cmd_cnt; i++) {
-		struct rockchip_cmd_desc *desc = &cmds->cmds[i];
-		const struct rockchip_cmd_header *header = &desc->header;
-
-		switch (header->data_type) {
-		case MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:
-		case MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:
-		case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:
-		case MIPI_DSI_GENERIC_LONG_WRITE:
-			ret = mipi_dsi_generic_write(dsi, desc->payload,
-						     header->payload_length);
-			break;
-		case MIPI_DSI_DCS_SHORT_WRITE:
-		case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
-		case MIPI_DSI_DCS_LONG_WRITE:
-			ret = mipi_dsi_dcs_write_buffer(dsi, desc->payload,
-							header->payload_length);
-			break;
-		default:
-			printf("unsupport command data type: %d\n",
-			       header->data_type);
-			return -EINVAL;
-		}
-
-		if (ret < 0) {
-			printf("failed to write cmd%d: %d\n", i, ret);
-			return ret;
-		}
-
-		if (header->delay_ms)
-			mdelay(header->delay_ms);
-	}
-
-	return 0;
-}
-
-static void panel_simple_prepare(struct rockchip_panel *panel)
-{
-	struct rockchip_panel_plat *plat = dev_get_platdata(panel->dev);
-	struct rockchip_panel_priv *priv = dev_get_priv(panel->dev);
-	struct mipi_dsi_device *dsi = dev_get_parent_platdata(panel->dev);
-	int ret;
-
-	if (priv->prepared)
-		return;
-
-	if (priv->power_supply)
-		regulator_set_enable(priv->power_supply, !plat->power_invert);
-
-	if (dm_gpio_is_valid(&priv->enable_5v_gpio))
-		dm_gpio_set_value(&priv->enable_5v_gpio, 1);
-
-	if (dm_gpio_is_valid(&priv->enable_gpio))
-		dm_gpio_set_value(&priv->enable_gpio, 1);
-
-	if (plat->delay.prepare)
-		mdelay(plat->delay.prepare);
-
-	if (dm_gpio_is_valid(&priv->enable_tc_gpio))
-		dm_gpio_set_value(&priv->enable_tc_gpio, 1);
-
-	if (dm_gpio_is_valid(&priv->reset_gpio))
-		dm_gpio_set_value(&priv->reset_gpio, 0);
-
-	if (plat->delay.reset)
-		mdelay(plat->delay.reset);
-
-	if (dm_gpio_is_valid(&priv->reset_gpio))
-		dm_gpio_set_value(&priv->reset_gpio, 1);
-
-	if (plat->delay.init)
-		mdelay(plat->delay.init);
-
-	if (plat->on_cmds) {
-		if (priv->cmd_type == CMD_TYPE_SPI)
-			ret = rockchip_panel_send_spi_cmds(panel->state,
-							   plat->on_cmds);
-		else if (priv->cmd_type == CMD_TYPE_MCU)
-			ret = rockchip_panel_send_mcu_cmds(panel->state,
-							   plat->on_cmds);
-		else
-			ret = rockchip_panel_send_dsi_cmds(dsi, plat->on_cmds);
-		if (ret)
-			printf("failed to send on cmds: %d\n", ret);
-	}
-
-	priv->prepared = true;
-}
-
-static void panel_simple_unprepare(struct rockchip_panel *panel)
-{
-	struct rockchip_panel_plat *plat = dev_get_platdata(panel->dev);
-	struct rockchip_panel_priv *priv = dev_get_priv(panel->dev);
-	struct mipi_dsi_device *dsi = dev_get_parent_platdata(panel->dev);
-	int ret;
-
-	if (!priv->prepared)
-		return;
-
-	if (plat->off_cmds) {
-		if (priv->cmd_type == CMD_TYPE_SPI)
-			ret = rockchip_panel_send_spi_cmds(panel->state,
-							   plat->off_cmds);
-		else if (priv->cmd_type == CMD_TYPE_MCU)
-			ret = rockchip_panel_send_mcu_cmds(panel->state,
-							   plat->off_cmds);
-		else
-			ret = rockchip_panel_send_dsi_cmds(dsi, plat->off_cmds);
-		if (ret)
-			printf("failed to send off cmds: %d\n", ret);
-	}
-
-	if (dm_gpio_is_valid(&priv->reset_gpio))
-		dm_gpio_set_value(&priv->reset_gpio, 1);
-
-	if (dm_gpio_is_valid(&priv->enable_gpio))
-		dm_gpio_set_value(&priv->enable_gpio, 0);
-
-	if (dm_gpio_is_valid(&priv->enable_tc_gpio))
-		dm_gpio_set_value(&priv->enable_tc_gpio, 0);
-
-	if (priv->power_supply)
-		regulator_set_enable(priv->power_supply, plat->power_invert);
-
-	if (plat->delay.unprepare)
-		mdelay(plat->delay.unprepare);
-
-	priv->prepared = false;
-}
-
-static void panel_simple_enable(struct rockchip_panel *panel)
-{
-	struct rockchip_panel_plat *plat = dev_get_platdata(panel->dev);
-	struct rockchip_panel_priv *priv = dev_get_priv(panel->dev);
-
-	if (priv->enabled)
-		return;
-
-	if (plat->delay.enable)
-		mdelay(plat->delay.enable);
-
-	if (priv->backlight)
-		backlight_enable(priv->backlight);
-
-	priv->enabled = true;
-}
-
-static void panel_simple_disable(struct rockchip_panel *panel)
-{
-	struct rockchip_panel_plat *plat = dev_get_platdata(panel->dev);
-	struct rockchip_panel_priv *priv = dev_get_priv(panel->dev);
-
-	if (!priv->enabled)
-		return;
-
-	if (priv->backlight)
-		backlight_disable(priv->backlight);
-
-	if (plat->delay.disable)
-		mdelay(plat->delay.disable);
-
-	priv->enabled = false;
-}
-
-static void panel_simple_init(struct rockchip_panel *panel)
-{
-	struct display_state *state = panel->state;
-	struct connector_state *conn_state = &state->conn_state;
-
-	conn_state->bus_format = panel->bus_format;
-}
-
-static const struct rockchip_panel_funcs rockchip_panel_funcs = {
-	.init = panel_simple_init,
-	.prepare = panel_simple_prepare,
-	.unprepare = panel_simple_unprepare,
-	.enable = panel_simple_enable,
-	.disable = panel_simple_disable,
-};
-
-static int rockchip_panel_ofdata_to_platdata(struct udevice *dev)
-{
-	struct rockchip_panel_plat *plat = dev_get_platdata(dev);
-	const void *data;
-	int len = 0;
-	int ret;
-
-	plat->power_invert = dev_read_bool(dev, "power-invert");
-
-	plat->delay.prepare = dev_read_u32_default(dev, "prepare-delay-ms", 0);
-	plat->delay.unprepare = dev_read_u32_default(dev, "unprepare-delay-ms", 0);
-	plat->delay.enable = dev_read_u32_default(dev, "enable-delay-ms", 0);
-	plat->delay.disable = dev_read_u32_default(dev, "disable-delay-ms", 0);
-	plat->delay.init = dev_read_u32_default(dev, "init-delay-ms", 0);
-	plat->delay.reset = dev_read_u32_default(dev, "reset-delay-ms", 0);
-
-	plat->bus_format = dev_read_u32_default(dev, "bus-format",
-						MEDIA_BUS_FMT_RBG888_1X24);
-	plat->bpc = dev_read_u32_default(dev, "bpc", 8);
-
-	data = dev_read_prop(dev, "panel-init-sequence", &len);
-	if (data) {
-		plat->on_cmds = calloc(1, sizeof(*plat->on_cmds));
-		if (!plat->on_cmds)
-			return -ENOMEM;
-
-		ret = rockchip_panel_parse_cmds(data, len, plat->on_cmds);
-		if (ret) {
-			printf("failed to parse panel init sequence\n");
-			goto free_on_cmds;
-		}
-	}
-
-	data = dev_read_prop(dev, "panel-exit-sequence", &len);
-	if (data) {
-		plat->off_cmds = calloc(1, sizeof(*plat->off_cmds));
-		if (!plat->off_cmds) {
-			ret = -ENOMEM;
-			goto free_on_cmds;
-		}
-
-		ret = rockchip_panel_parse_cmds(data, len, plat->off_cmds);
-		if (ret) {
-			printf("failed to parse panel exit sequence\n");
-			goto free_cmds;
-		}
-	}
-
-	return 0;
-
-free_cmds:
-	free(plat->off_cmds);
-free_on_cmds:
-	free(plat->on_cmds);
-	return ret;
-}
-
-static int rockchip_panel_probe(struct udevice *dev)
-{
-	struct rockchip_panel_priv *priv = dev_get_priv(dev);
-	struct rockchip_panel_plat *plat = dev_get_platdata(dev);
-	struct rockchip_panel *panel;
-	int ret;
-	const char *cmd_type;
-
-	ret = gpio_request_by_name(dev, "enable-gpios", 0,
-				   &priv->enable_gpio, GPIOD_IS_OUT);
-	if (ret && ret != -ENOENT) {
-		printf("%s: Cannot get enable GPIO: %d\n", __func__, ret);
-		return ret;
-	}
-		       
-	if (dm_gpio_is_valid(&priv->enable_gpio))
-	{
-		dm_gpio_set_value(&priv->enable_gpio, 1);
-		if (plat->delay.prepare)
-			mdelay(plat->delay.prepare);
-		dm_gpio_set_value(&priv->enable_gpio, 0);
-		if (plat->delay.prepare)
-			mdelay(plat->delay.prepare);
-		dm_gpio_set_value(&priv->enable_gpio, 1);
-	}
-
-	ret = gpio_request_by_name(dev, "enable-5v-gpios", 0,
-				   &priv->enable_5v_gpio, GPIOD_IS_OUT);
-	if (ret && ret != -ENOENT) {
-		printf("%s: Cannot get enable 5v GPIO: %d\n", __func__, ret);
-	}
-
-	ret = gpio_request_by_name(dev, "enable-tc-gpios", 0,
-				   &priv->enable_tc_gpio, GPIOD_IS_OUT);
-	if (ret && ret != -ENOENT) {
-		printf("%s: Cannot get enable tc GPIO: %d\n", __func__, ret);
-	}
-
-	ret = gpio_request_by_name(dev, "reset-gpios", 0,
-				   &priv->reset_gpio, GPIOD_IS_OUT);
-	if (ret && ret != -ENOENT) {
-		printf("%s: Cannot get reset GPIO: %d\n", __func__, ret);
-		return ret;
-	}
-
-	dm_gpio_set_value(&priv->reset_gpio, 1);
-	ret = uclass_get_device_by_phandle(UCLASS_PANEL_BACKLIGHT, dev,
-					   "backlight", &priv->backlight);
-	if (ret && ret != -ENOENT) {
-		printf("%s: Cannot get backlight: %d\n", __func__, ret);
-		return ret;
-	}
-
-	ret = uclass_get_device_by_phandle(UCLASS_REGULATOR, dev,
-					   "power-supply", &priv->power_supply);
-	if (ret && ret != -ENOENT) {
-		printf("%s: Cannot get power supply: %d\n", __func__, ret);
-		return ret;
-	}
-
-	ret = dev_read_string_index(dev, "rockchip,cmd-type", 0, &cmd_type);
-	if (ret)
-		priv->cmd_type = CMD_TYPE_DEFAULT;
-	else
-		priv->cmd_type = get_panel_cmd_type(cmd_type);
-
-	if (priv->cmd_type == CMD_TYPE_SPI) {
-		ret = gpio_request_by_name(dev, "spi-sdi-gpios", 0,
-					   &priv->spi_sdi_gpio, GPIOD_IS_OUT);
-		if (ret && ret != -ENOENT) {
-			printf("%s: Cannot get spi sdi GPIO: %d\n",
-			       __func__, ret);
-			return ret;
-		}
-		ret = gpio_request_by_name(dev, "spi-scl-gpios", 0,
-					   &priv->spi_scl_gpio, GPIOD_IS_OUT);
-		if (ret && ret != -ENOENT) {
-			printf("%s: Cannot get spi scl GPIO: %d\n",
-			       __func__, ret);
-			return ret;
-		}
-		ret = gpio_request_by_name(dev, "spi-cs-gpios", 0,
-					   &priv->spi_cs_gpio, GPIOD_IS_OUT);
-		if (ret && ret != -ENOENT) {
-			printf("%s: Cannot get spi cs GPIO: %d\n",
-			       __func__, ret);
-			return ret;
-		}
-		dm_gpio_set_value(&priv->spi_sdi_gpio, 1);
-		dm_gpio_set_value(&priv->spi_scl_gpio, 1);
-		dm_gpio_set_value(&priv->spi_cs_gpio, 1);
-		dm_gpio_set_value(&priv->reset_gpio, 0);
-	}
-
-	panel = calloc(1, sizeof(*panel));
-	if (!panel)
-		return -ENOMEM;
-
-	dev->driver_data = (ulong)panel;
-	panel->dev = dev;
-	panel->bus_format = plat->bus_format;
-	panel->bpc = plat->bpc;
-	panel->funcs = &rockchip_panel_funcs;
-
-	return 0;
-}
-
-static const struct udevice_id rockchip_panel_ids[] = {
-	{ .compatible = "simple-panel", },
-	{ .compatible = "simple-panel-dsi", },
-	{}
-};
-
-U_BOOT_DRIVER(rockchip_panel) = {
-	.name = "rockchip_panel",
-	.id = UCLASS_PANEL,
-	.of_match = rockchip_panel_ids,
-	.ofdata_to_platdata = rockchip_panel_ofdata_to_platdata,
-	.probe = rockchip_panel_probe,
-	.priv_auto_alloc_size = sizeof(struct rockchip_panel_priv),
-	.platdata_auto_alloc_size = sizeof(struct rockchip_panel_plat),
-};
+version https://git-lfs.github.com/spec/v1
+oid sha256:fcf4e7b1754e0ab46a8769570b94dfa3e609732ed8393be39ac6c1b594ebe6d8
+size 14581
diff --git a/u-boot/drivers/video/drm/rockchip_panel.h b/u-boot/drivers/video/drm/rockchip_panel.h
index 3a7587f710..f2b9e68dc7 100644
--- a/u-boot/drivers/video/drm/rockchip_panel.h
+++ b/u-boot/drivers/video/drm/rockchip_panel.h
@@ -1,76 +1,3 @@
-/*
- * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef _ROCKCHIP_PANEL_H_
-#define _ROCKCHIP_PANEL_H_
-
-struct display_state;
-struct rockchip_panel;
-
-struct rockchip_panel_funcs {
-	void (*init)(struct rockchip_panel *panel);
-	void (*prepare)(struct rockchip_panel *panel);
-	void (*unprepare)(struct rockchip_panel *panel);
-	void (*enable)(struct rockchip_panel *panel);
-	void (*disable)(struct rockchip_panel *panel);
-};
-
-struct rockchip_panel {
-	struct udevice *dev;
-	u32 bus_format;
-	unsigned int bpc;
-	const struct rockchip_panel_funcs *funcs;
-	const void *data;
-
-	struct display_state *state;
-};
-
-static inline void rockchip_panel_init(struct rockchip_panel *panel)
-{
-	if (!panel)
-		return;
-
-	if (panel->funcs && panel->funcs->init)
-		panel->funcs->init(panel);
-}
-
-static inline void rockchip_panel_prepare(struct rockchip_panel *panel)
-{
-	if (!panel)
-		return;
-
-	if (panel->funcs && panel->funcs->prepare)
-		panel->funcs->prepare(panel);
-}
-
-static inline void rockchip_panel_enable(struct rockchip_panel *panel)
-{
-	if (!panel)
-		return;
-
-	if (panel->funcs && panel->funcs->enable)
-		panel->funcs->enable(panel);
-}
-
-static inline void rockchip_panel_unprepare(struct rockchip_panel *panel)
-{
-	if (!panel)
-		return;
-
-	if (panel->funcs && panel->funcs->unprepare)
-		panel->funcs->unprepare(panel);
-}
-
-static inline void rockchip_panel_disable(struct rockchip_panel *panel)
-{
-	if (!panel)
-		return;
-
-	if (panel->funcs && panel->funcs->disable)
-		panel->funcs->disable(panel);
-}
-
-#endif	/* _ROCKCHIP_PANEL_H_ */
+version https://git-lfs.github.com/spec/v1
+oid sha256:9a2ae34c16a2e5c0ffaad742964978f7eb667a4b8951af91bcfbb1803fabfbe2
+size 1624
diff --git a/u-boot/include/log.h b/u-boot/include/log.h
index b63058f211..955794bb1e 100644
--- a/u-boot/include/log.h
+++ b/u-boot/include/log.h
@@ -1,326 +1,3 @@
-/*
- * Logging support
- *
- * Copyright (c) 2017 Google, Inc
- * Written by Simon Glass <sjg@chromium.org>
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __LOG_H
-#define __LOG_H
-
-#include <dm/uclass-id.h>
-#include <linux/list.h>
-
-/** Log levels supported, ranging from most to least important */
-enum log_level_t {
-	LOGL_EMERG = 0,		/*U-Boot is unstable */
-	LOGL_ALERT,		/* Action must be taken immediately */
-	LOGL_CRIT,		/* Critical conditions */
-	LOGL_ERR,		/* Error that prevents something from working */
-	LOGL_WARNING,		/* Warning may prevent optimial operation */
-	LOGL_NOTICE,		/* Normal but significant condition, printf() */
-	LOGL_INFO,		/* General information message */
-	LOGL_DEBUG,		/* Basic debug-level message */
-	LOGL_DEBUG_CONTENT,	/* Debug message showing full message content */
-	LOGL_DEBUG_IO,		/* Debug message showing hardware I/O access */
-
-	LOGL_COUNT,
-	LOGL_FIRST = LOGL_EMERG,
-	LOGL_MAX = LOGL_DEBUG,
-};
-
-/**
- * Log categories supported. Most of these correspond to uclasses (i.e.
- * enum uclass_id) but there are also some more generic categories
- */
-enum log_category_t {
-	LOGC_FIRST = 0,	/* First part mirrors UCLASS_... */
-
-	LOGC_NONE = UCLASS_COUNT,
-	LOGC_ARCH,
-	LOGC_BOARD,
-	LOGC_CORE,
-	LOGC_DM,	/* Core driver-model */
-	LOGC_DT,	/* Device-tree */
-	LOGC_EFI,	/* EFI implementation */
-	LOGC_ALLOC,	/* Memory allocation */
-
-	LOGC_COUNT,
-	LOGC_END,
-};
-
-/* Helper to cast a uclass ID to a log category */
-static inline int log_uc_cat(enum uclass_id id)
-{
-	return (enum log_category_t)id;
-}
-
-/**
- * _log() - Internal function to emit a new log record
- *
- * @cat: Category of log record (indicating which subsystem generated it)
- * @level: Level of log record (indicating its severity)
- * @file: File name of file where log record was generated
- * @line: Line number in file where log record was generated
- * @func: Function where log record was generated
- * @fmt: printf() format string for log record
- * @...: Optional parameters, according to the format string @fmt
- * @return 0 if log record was emitted, -ve on error
- */
-int _log(enum log_category_t cat, enum log_level_t level, const char *file,
-	 int line, const char *func, const char *fmt, ...);
-
-/* Define this at the top of a file to add a prefix to debug messages */
-#ifndef pr_fmt
-#define pr_fmt(fmt) fmt
-#endif
-
-/* Use a default category if this file does not supply one */
-#ifndef LOG_CATEGORY
-#define LOG_CATEGORY LOGC_NONE
-#endif
-
-/*
- * This header may be including when CONFIG_LOG is disabled, in which case
- * CONFIG_LOG_MAX_LEVEL is not defined. Add a check for this.
- */
-#if CONFIG_IS_ENABLED(LOG)
-#define _LOG_MAX_LEVEL CONFIG_VAL(LOG_MAX_LEVEL)
-#else
-#define _LOG_MAX_LEVEL LOGL_INFO
-#endif
-
-/* Emit a log record if the level is less that the maximum */
-#define log(_cat, _level, _fmt, _args...) ({ \
-	int _l = _level; \
-	if (_l <= _LOG_MAX_LEVEL) \
-		_log((enum log_category_t)(_cat), _l, __FILE__, __LINE__, \
-		      __func__, \
-		      pr_fmt(_fmt), ##_args); \
-	})
-
-#ifdef DEBUG
-#define _DEBUG	1
-#else
-#define _DEBUG	0
-#endif
-
-#ifdef CONFIG_SPL_BUILD
-#define _SPL_BUILD	1
-#else
-#define _SPL_BUILD	0
-#endif
-
-#if !_DEBUG && CONFIG_IS_ENABLED(LOG)
-
-#define debug_cond(cond, fmt, args...)			\
-	do {						\
-		if (1)					\
-			log(LOG_CATEGORY, LOGL_DEBUG, fmt, ##args); \
-	} while (0)
-
-#else /* _DEBUG */
-
-/*
- * Output a debug text when condition "cond" is met. The "cond" should be
- * computed by a preprocessor in the best case, allowing for the best
- * optimization.
- */
-#define debug_cond(cond, fmt, args...)			\
-	do {						\
-		if (cond)				\
-			printf(pr_fmt(fmt), ##args);	\
-	} while (0)
-
-#endif /* _DEBUG */
-
-/* Show a message if DEBUG is defined in a file */
-#define debug(fmt, args...)			\
-	debug_cond(_DEBUG, fmt, ##args)
-
-/* Show a message if not in SPL */
-#define warn_non_spl(fmt, args...)			\
-	debug_cond(!_SPL_BUILD, fmt, ##args)
-
-/*
- * An assertion is run-time check done in debug mode only. If DEBUG is not
- * defined then it is skipped. If DEBUG is defined and the assertion fails,
- * then it calls panic*( which may or may not reset/halt U-Boot (see
- * CONFIG_PANIC_HANG), It is hoped that all failing assertions are found
- * before release, and after release it is hoped that they don't matter. But
- * in any case these failing assertions cannot be fixed with a reset (which
- * may just do the same assertion again).
- */
-void __assert_fail(const char *assertion, const char *file, unsigned int line,
-		   const char *function);
-#define assert(x) \
-	({ if (!(x) && _DEBUG) \
-		__assert_fail(#x, __FILE__, __LINE__, __func__); })
-
-#ifdef CONFIG_LOG_ERROR_RETURN
-#define log_ret(_ret) ({ \
-	int __ret = (_ret); \
-	if (__ret < 0) \
-		log(LOG_CATEGORY, LOGL_ERR, "returning err=%d\n", __ret); \
-	__ret; \
-	})
-#define log_msg_ret(_msg, _ret) ({ \
-	int __ret = (_ret); \
-	if (__ret < 0) \
-		log(LOG_CATEGORY, LOGL_ERR, "%s: returning err=%d\n", _msg, \
-		    __ret); \
-	__ret; \
-	})
-#else
-#define log_ret(_ret) (_ret)
-#define log_msg_ret(_msg, _ret) (_ret)
-#endif
-
-/**
- * struct log_rec - a single log record
- *
- * Holds information about a single record in the log
- *
- * Members marked as 'not allocated' are stored as pointers and the caller is
- * responsible for making sure that the data pointed to is not overwritten.
- * Memebers marked as 'allocated' are allocated (e.g. via strdup()) by the log
- * system.
- *
- * @cat: Category, representing a uclass or part of U-Boot
- * @level: Severity level, less severe is higher
- * @file: Name of file where the log record was generated (not allocated)
- * @line: Line number where the log record was generated
- * @func: Function where the log record was generated (not allocated)
- * @msg: Log message (allocated)
- */
-struct log_rec {
-	enum log_category_t cat;
-	enum log_level_t level;
-	const char *file;
-	int line;
-	const char *func;
-	const char *msg;
-};
-
-struct log_device;
-
-/**
- * struct log_driver - a driver which accepts and processes log records
- *
- * @name: Name of driver
- */
-struct log_driver {
-	const char *name;
-	/**
-	 * emit() - emit a log record
-	 *
-	 * Called by the log system to pass a log record to a particular driver
-	 * for processing. The filter is checked before calling this function.
-	 */
-	int (*emit)(struct log_device *ldev, struct log_rec *rec);
-};
-
-/**
- * struct log_device - an instance of a log driver
- *
- * Since drivers are set up at build-time we need to have a separate device for
- * the run-time aspects of drivers (currently just a list of filters to apply
- * to records send to this device).
- *
- * @next_filter_num: Seqence number of next filter filter added (0=no filters
- *	yet). This increments with each new filter on the device, but never
- *	decrements
- * @drv: Pointer to driver for this device
- * @filter_head: List of filters for this device
- * @sibling_node: Next device in the list of all devices
- */
-struct log_device {
-	int next_filter_num;
-	struct log_driver *drv;
-	struct list_head filter_head;
-	struct list_head sibling_node;
-};
-
-enum {
-	LOGF_MAX_CATEGORIES = 5,	/* maximum categories per filter */
-};
-
-enum log_filter_flags {
-	LOGFF_HAS_CAT		= 1 << 0,	/* Filter has a category list */
-};
-
-/**
- * struct log_filter - criterial to filter out log messages
- *
- * @filter_num: Sequence number of this filter.  This is returned when adding a
- *	new filter, and must be provided when removing a previously added
- *	filter.
- * @flags: Flags for this filter (LOGFF_...)
- * @cat_list: List of categories to allow (terminated by LOGC_none). If empty
- *	then all categories are permitted. Up to LOGF_MAX_CATEGORIES entries
- *	can be provided
- * @max_level: Maximum log level to allow
- * @file_list: List of files to allow, separated by comma. If NULL then all
- *	files are permitted
- * @sibling_node: Next filter in the list of filters for this log device
- */
-struct log_filter {
-	int filter_num;
-	int flags;
-	enum log_category_t cat_list[LOGF_MAX_CATEGORIES];
-	enum log_level_t max_level;
-	const char *file_list;
-	struct list_head sibling_node;
-};
-
-#define LOG_DRIVER(_name) \
-	ll_entry_declare(struct log_driver, _name, log_driver)
-
-/* Handle the 'log test' command */
-int do_log_test(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[]);
-
-/**
- * log_add_filter() - Add a new filter to a log device
- *
- * @drv_name: Driver name to add the filter to (since each driver only has a
- *	single device)
- * @cat_list: List of categories to allow (terminated by LOGC_none). If empty
- *	then all categories are permitted. Up to LOGF_MAX_CATEGORIES entries
- *	can be provided
- * @max_level: Maximum log level to allow
- * @file_list: List of files to allow, separated by comma. If NULL then all
- *	files are permitted
- * @return the sequence number of the new filter (>=0) if the filter was added,
- *	or a -ve value on error
- */
-int log_add_filter(const char *drv_name, enum log_category_t cat_list[],
-		   enum log_level_t max_level, const char *file_list);
-
-/**
- * log_remove_filter() - Remove a filter from a log device
- *
- * @drv_name: Driver name to remove the filter from (since each driver only has
- *	a single device)
- * @filter_num: Filter number to remove (as returned by log_add_filter())
- * @return 0 if the filter was removed, -ENOENT if either the driver or the
- *	filter number was not found
- */
-int log_remove_filter(const char *drv_name, int filter_num);
-
-#if CONFIG_IS_ENABLED(LOG)
-/**
- * log_init() - Set up the log system ready for use
- *
- * @return 0 if OK, -ENOMEM if out of memory
- */
-int log_init(void);
-#else
-static inline int log_init(void)
-{
-	return 0;
-}
-#endif
-
-#endif
+version https://git-lfs.github.com/spec/v1
+oid sha256:91872c7ccea8b737177670e59fc542a5edad2d2b1d3f4e611f2063be74759f93
+size 9493
diff --git a/u-boot/lib/avb/libavb/avb_vbmeta_image.c b/u-boot/lib/avb/libavb/avb_vbmeta_image.c
index 5d0179eced..2d1e2ba4a4 100644
--- a/u-boot/lib/avb/libavb/avb_vbmeta_image.c
+++ b/u-boot/lib/avb/libavb/avb_vbmeta_image.c
@@ -1,314 +1,3 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy,
- * modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-#include <android_avb/avb_vbmeta_image.h>
-#include <android_avb/avb_crypto.h>
-#include <android_avb/avb_rsa.h>
-#include <android_avb/avb_sha.h>
-#include <android_avb/avb_util.h>
-#include <android_avb/avb_version.h>
-
-AvbVBMetaVerifyResult avb_vbmeta_image_verify(
-    const uint8_t* data,
-    size_t length,
-    const uint8_t** out_public_key_data,
-    size_t* out_public_key_length) {
-  AvbVBMetaVerifyResult ret;
-  AvbVBMetaImageHeader h;
-  uint8_t* computed_hash;
-  const AvbAlgorithmData* algorithm;
-  AvbSHA256Ctx sha256_ctx;
-  AvbSHA512Ctx sha512_ctx;
-  const uint8_t* header_block;
-  const uint8_t* authentication_block;
-  const uint8_t* auxiliary_block;
-  int verification_result;
-
-  ret = AVB_VBMETA_VERIFY_RESULT_INVALID_VBMETA_HEADER;
-
-  if (out_public_key_data != NULL) {
-    *out_public_key_data = NULL;
-  }
-  if (out_public_key_length != NULL) {
-    *out_public_key_length = 0;
-  }
-
-  /* Before we byteswap or compare Magic, ensure length is long enough. */
-  if (length < sizeof(AvbVBMetaImageHeader)) {
-    avb_error("Length is smaller than header.\n");
-    goto out;
-  }
-
-  /* Ensure magic is correct. */
-  if (avb_safe_memcmp(data, AVB_MAGIC, AVB_MAGIC_LEN) != 0) {
-    avb_error("Magic is incorrect.\n");
-    goto out;
-  }
-
-  avb_vbmeta_image_header_to_host_byte_order((const AvbVBMetaImageHeader*)data,
-                                             &h);
-
-  /* Ensure we don't attempt to access any fields if we do not meet
-   * the specified minimum version of libavb.
-   */
-  if ((h.required_libavb_version_major != AVB_VERSION_MAJOR) ||
-      (h.required_libavb_version_minor > AVB_VERSION_MINOR)) {
-    avb_error("Mismatch between image version and libavb version.\n");
-    ret = AVB_VBMETA_VERIFY_RESULT_UNSUPPORTED_VERSION;
-    goto out;
-  }
-
-  /* Ensure |release_string| ends with a NUL byte. */
-  if (h.release_string[AVB_RELEASE_STRING_SIZE - 1] != '\0') {
-    avb_error("Release string does not end with a NUL byte.\n");
-    goto out;
-  }
-
-  /* Ensure inner block sizes are multiple of 64. */
-  if ((h.authentication_data_block_size & 0x3f) != 0 ||
-      (h.auxiliary_data_block_size & 0x3f) != 0) {
-    avb_error("Block size is not a multiple of 64.\n");
-    goto out;
-  }
-
-  /* Ensure block sizes all add up to at most |length|. */
-  uint64_t block_total = sizeof(AvbVBMetaImageHeader);
-  if (!avb_safe_add_to(&block_total, h.authentication_data_block_size) ||
-      !avb_safe_add_to(&block_total, h.auxiliary_data_block_size)) {
-    avb_error("Overflow while computing size of boot image.\n");
-    goto out;
-  }
-  if (block_total > length) {
-    avb_error("Block sizes add up to more than given length.\n");
-    goto out;
-  }
-
-  uintptr_t data_ptr = (uintptr_t)data;
-  /* Ensure passed in memory doesn't wrap. */
-  if (!avb_safe_add(NULL, (uint64_t)data_ptr, length)) {
-    avb_error("Boot image location and length mismatch.\n");
-    goto out;
-  }
-
-  /* Ensure hash and signature are entirely in the Authentication data block. */
-  uint64_t hash_end;
-  if (!avb_safe_add(&hash_end, h.hash_offset, h.hash_size) ||
-      hash_end > h.authentication_data_block_size) {
-    avb_error("Hash is not entirely in its block.\n");
-    goto out;
-  }
-  uint64_t signature_end;
-  if (!avb_safe_add(&signature_end, h.signature_offset, h.signature_size) ||
-      signature_end > h.authentication_data_block_size) {
-    avb_error("Signature is not entirely in its block.\n");
-    goto out;
-  }
-
-  /* Ensure public key is entirely in the Auxiliary data block. */
-  uint64_t pubkey_end;
-  if (!avb_safe_add(&pubkey_end, h.public_key_offset, h.public_key_size) ||
-      pubkey_end > h.auxiliary_data_block_size) {
-    avb_error("Public key is not entirely in its block.\n");
-    goto out;
-  }
-
-  /* Ensure public key metadata (if set) is entirely in the Auxiliary
-   * data block. */
-  if (h.public_key_metadata_size > 0) {
-    uint64_t pubkey_md_end;
-    if (!avb_safe_add(&pubkey_md_end,
-                      h.public_key_metadata_offset,
-                      h.public_key_metadata_size) ||
-        pubkey_md_end > h.auxiliary_data_block_size) {
-      avb_error("Public key metadata is not entirely in its block.\n");
-      goto out;
-    }
-  }
-
-  /* Bail early if there's no hash or signature. */
-  if (h.algorithm_type == AVB_ALGORITHM_TYPE_NONE) {
-    ret = AVB_VBMETA_VERIFY_RESULT_OK_NOT_SIGNED;
-    goto out;
-  }
-
-  /* Ensure algorithm field is supported. */
-  algorithm = avb_get_algorithm_data(h.algorithm_type);
-  if (!algorithm) {
-    avb_error("Invalid or unknown algorithm.\n");
-    goto out;
-  }
-
-  /* Bail if the embedded hash size doesn't match the chosen algorithm. */
-  if (h.hash_size != algorithm->hash_len) {
-    avb_error("Embedded hash has wrong size.\n");
-    goto out;
-  }
-
-  /* No overflow checks needed from here-on after since all block
-   * sizes and offsets have been verified above.
-   */
-
-  header_block = data;
-  authentication_block = header_block + sizeof(AvbVBMetaImageHeader);
-  auxiliary_block = authentication_block + h.authentication_data_block_size;
-
-  switch (h.algorithm_type) {
-    /* Explicit fall-through: */
-    case AVB_ALGORITHM_TYPE_SHA256_RSA2048:
-    case AVB_ALGORITHM_TYPE_SHA256_RSA4096:
-    case AVB_ALGORITHM_TYPE_SHA256_RSA8192:
-
-      sha256_ctx.tot_len = sizeof(AvbVBMetaImageHeader) +
-                                      h.auxiliary_data_block_size;
-      avb_sha256_init(&sha256_ctx);
-      avb_sha256_update(
-          &sha256_ctx, header_block, sizeof(AvbVBMetaImageHeader));
-      avb_sha256_update(
-          &sha256_ctx, auxiliary_block, h.auxiliary_data_block_size);
-      computed_hash = avb_sha256_final(&sha256_ctx);
-      break;
-    /* Explicit fall-through: */
-    case AVB_ALGORITHM_TYPE_SHA512_RSA2048:
-    case AVB_ALGORITHM_TYPE_SHA512_RSA4096:
-    case AVB_ALGORITHM_TYPE_SHA512_RSA8192:
-      sha512_ctx.tot_len = sizeof(AvbVBMetaImageHeader) +
-                                      h.auxiliary_data_block_size;
-      avb_sha512_init(&sha512_ctx);
-      avb_sha512_update(
-          &sha512_ctx, header_block, sizeof(AvbVBMetaImageHeader));
-      avb_sha512_update(
-          &sha512_ctx, auxiliary_block, h.auxiliary_data_block_size);
-      computed_hash = avb_sha512_final(&sha512_ctx);
-      break;
-    default:
-      avb_error("Unknown algorithm.\n");
-      goto out;
-  }
-
-  if (avb_safe_memcmp(authentication_block + h.hash_offset,
-                      computed_hash,
-                      h.hash_size) != 0) {
-    avb_error("Hash does not match!\n");
-    ret = AVB_VBMETA_VERIFY_RESULT_HASH_MISMATCH;
-    goto out;
-  }
-
-  verification_result =
-      avb_rsa_verify(auxiliary_block + h.public_key_offset,
-                     h.public_key_size,
-                     authentication_block + h.signature_offset,
-                     h.signature_size,
-                     authentication_block + h.hash_offset,
-                     h.hash_size,
-                     algorithm->padding,
-                     algorithm->padding_len);
-
-  if (verification_result == 0) {
-    ret = AVB_VBMETA_VERIFY_RESULT_SIGNATURE_MISMATCH;
-    goto out;
-  }
-
-  if (h.public_key_size > 0) {
-    if (out_public_key_data != NULL) {
-      *out_public_key_data = auxiliary_block + h.public_key_offset;
-    }
-    if (out_public_key_length != NULL) {
-      *out_public_key_length = h.public_key_size;
-    }
-  }
-
-  ret = AVB_VBMETA_VERIFY_RESULT_OK;
-
-out:
-  return ret;
-}
-
-void avb_vbmeta_image_header_to_host_byte_order(const AvbVBMetaImageHeader* src,
-                                                AvbVBMetaImageHeader* dest) {
-  avb_memcpy(dest, src, sizeof(AvbVBMetaImageHeader));
-
-  dest->required_libavb_version_major =
-      avb_be32toh(dest->required_libavb_version_major);
-  dest->required_libavb_version_minor =
-      avb_be32toh(dest->required_libavb_version_minor);
-
-  dest->authentication_data_block_size =
-      avb_be64toh(dest->authentication_data_block_size);
-  dest->auxiliary_data_block_size =
-      avb_be64toh(dest->auxiliary_data_block_size);
-
-  dest->algorithm_type = avb_be32toh(dest->algorithm_type);
-
-  dest->hash_offset = avb_be64toh(dest->hash_offset);
-  dest->hash_size = avb_be64toh(dest->hash_size);
-
-  dest->signature_offset = avb_be64toh(dest->signature_offset);
-  dest->signature_size = avb_be64toh(dest->signature_size);
-
-  dest->public_key_offset = avb_be64toh(dest->public_key_offset);
-  dest->public_key_size = avb_be64toh(dest->public_key_size);
-
-  dest->public_key_metadata_offset =
-      avb_be64toh(dest->public_key_metadata_offset);
-  dest->public_key_metadata_size = avb_be64toh(dest->public_key_metadata_size);
-
-  dest->descriptors_offset = avb_be64toh(dest->descriptors_offset);
-  dest->descriptors_size = avb_be64toh(dest->descriptors_size);
-
-  dest->rollback_index = avb_be64toh(dest->rollback_index);
-  dest->flags = avb_be32toh(dest->flags);
-}
-
-const char* avb_vbmeta_verify_result_to_string(AvbVBMetaVerifyResult result) {
-  const char* ret = NULL;
-
-  switch (result) {
-    case AVB_VBMETA_VERIFY_RESULT_OK:
-      ret = "OK";
-      break;
-    case AVB_VBMETA_VERIFY_RESULT_OK_NOT_SIGNED:
-      ret = "OK_NOT_SIGNED";
-      break;
-    case AVB_VBMETA_VERIFY_RESULT_INVALID_VBMETA_HEADER:
-      ret = "INVALID_VBMETA_HEADER";
-      break;
-    case AVB_VBMETA_VERIFY_RESULT_UNSUPPORTED_VERSION:
-      ret = "UNSUPPORTED_VERSION";
-      break;
-    case AVB_VBMETA_VERIFY_RESULT_HASH_MISMATCH:
-      ret = "HASH_MISMATCH";
-      break;
-    case AVB_VBMETA_VERIFY_RESULT_SIGNATURE_MISMATCH:
-      ret = "SIGNATURE_MISMATCH";
-      break;
-      /* Do not add a 'default:' case here because of -Wswitch. */
-  }
-
-  if (ret == NULL) {
-    avb_error("Unknown AvbVBMetaVerifyResult value.\n");
-    ret = "(unknown)";
-  }
-
-  return ret;
-}
+version https://git-lfs.github.com/spec/v1
+oid sha256:767bae2430561960e2028a06538506a1bd72220d2a65c5a61653abe54f7ffab2
+size 10797
diff --git a/u-boot/lib/avb/rk_avb_user/rk_avb_ops_user.c b/u-boot/lib/avb/rk_avb_user/rk_avb_ops_user.c
index 98bf5ceead..feea8a3d4e 100644
--- a/u-boot/lib/avb/rk_avb_user/rk_avb_ops_user.c
+++ b/u-boot/lib/avb/rk_avb_user/rk_avb_ops_user.c
@@ -1,811 +1,3 @@
-/*
- * (C) Copyright 2017 Rockchip Electronics Co., Ltd
- *
- * SPDX-License-Identifier:     GPL-2.0+
- */
-
-#include <common.h>
-#include <image.h>
-#include <android_image.h>
-#include <malloc.h>
-#include <mapmem.h>
-#include <errno.h>
-#include <command.h>
-#include <mmc.h>
-#include <blk.h>
-#include <part.h>
-#include <android_avb/avb_ops_user.h>
-#include <android_avb/libavb_ab.h>
-#include <android_avb/avb_atx_validate.h>
-#include <android_avb/avb_atx_types.h>
-#include <optee_include/OpteeClientInterface.h>
-#include <optee_include/tee_api_defines.h>
-#include <android_avb/avb_vbmeta_image.h>
-#include <android_avb/avb_atx_validate.h>
-#include <android_avb/rk_avb_ops_user.h>
-#include <boot_rkimg.h>
-#include <u-boot/sha256.h>
-#include <asm/arch/rk_atags.h>
-
-/* rk used */
-int rk_avb_get_pub_key(struct rk_pub_key *pub_key)
-{
-	struct tag *t = NULL;
-
-	t = atags_get_tag(ATAG_PUB_KEY);
-	if (!t)
-		return -1;
-
-	memcpy(pub_key, t->u.pub_key.data, sizeof(struct rk_pub_key));
-
-	return 0;
-}
-
-int rk_avb_get_perm_attr_cer(uint8_t *cer, uint32_t size)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	if (trusty_read_permanent_attributes_cer((uint8_t *)cer, size)) {
-		printf("AVB: perm attr cer is not exist.\n");
-		return -EIO;
-	}
-
-	return 0;
-#else
-	return -1;
-#endif
-}
-
-int rk_avb_set_perm_attr_cer(uint8_t *cer, uint32_t size)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	if (trusty_write_permanent_attributes_cer((uint8_t *)cer, size))
-		return -EIO;
-
-	return 0;
-#else
-	return -1;
-#endif
-}
-
-int rk_avb_read_permanent_attributes(uint8_t *attributes, uint32_t size)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	if(trusty_read_permanent_attributes(attributes, size) != 0) {
-		printf("trusty_read_permanent_attributes failed!\n");
-		return -1;
-	}
-
-	return 0;
-#else
-	return -1;
-#endif
-}
-
-int rk_avb_write_permanent_attributes(uint8_t *attributes, uint32_t size)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	if(trusty_write_permanent_attributes(attributes, size) != 0) {
-		printf("trusty_write_permanent_attributes failed!\n");
-		return -1;
-	}
-
-	return 0;
-#else
-	return -1;
-#endif
-}
-
-int rk_avb_read_flash_lock_state(uint8_t *flash_lock_state)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	int ret;
-
-	ret = trusty_read_flash_lock_state(flash_lock_state);
-	switch (ret) {
-	case TEE_SUCCESS:
-		break;
-	case TEE_ERROR_GENERIC:
-	case TEE_ERROR_NO_DATA:
-	case TEE_ERROR_ITEM_NOT_FOUND:
-		*flash_lock_state = 1;
-		if (trusty_write_flash_lock_state(*flash_lock_state)) {
-			avb_error("trusty_write_flash_lock_state error!");
-			ret = -1;
-		} else {
-			ret = trusty_read_flash_lock_state(flash_lock_state);
-		}
-		break;
-	default:
-		printf("%s: trusty_read_flash_lock_state failed\n", __FILE__);
-	}
-
-	return ret;
-#else
-	*flash_lock_state = 1;
-
-	return 0;
-#endif
-}
-
-int rk_avb_write_flash_lock_state(uint8_t flash_lock_state)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	if (trusty_write_flash_lock_state(flash_lock_state)) {
-		printf("trusty_write_flash_lock_state error!\n");
-		return -1;
-	}
-
-	return 0;
-#else
-	return -1;
-#endif
-}
-
-int rk_avb_write_lock_state(uint8_t lock_state)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	if (trusty_write_lock_state(lock_state)) {
-		printf("trusty_write_lock_state error!\n");
-		return -1;
-	}
-
-	return 0;
-#else
-	return -1;
-#endif
-}
-
-int rk_avb_read_lock_state(uint8_t *lock_state)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	int ret;
-
-	ret = trusty_read_lock_state(lock_state);
-	switch (ret) {
-	case TEE_SUCCESS:
-		break;
-	case TEE_ERROR_GENERIC:
-	case TEE_ERROR_NO_DATA:
-	case TEE_ERROR_ITEM_NOT_FOUND:
-		*lock_state = 1;
-		if (rk_avb_write_lock_state(*lock_state)) {
-			avb_error("avb_write_lock_state error!");
-			ret = -1;
-		} else {
-			ret = trusty_read_lock_state(lock_state);
-		}
-		break;
-	default:
-		printf("%s: trusty_read_lock_state failed\n", __FILE__);
-	}
-
-	return ret;
-#else
-	return -1;
-#endif
-}
-
-int rk_avb_write_perm_attr_flag(uint8_t flag)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	if (trusty_write_permanent_attributes_flag(flag)) {
-		printf("trusty_write_permanent_attributes_flag error!\n");
-		return -1;
-	}
-
-	return 0;
-#else
-	return -1;
-#endif
-}
-
-int rk_avb_read_perm_attr_flag(uint8_t *flag)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	int ret;
-
-	ret = trusty_read_permanent_attributes_flag(flag);
-	switch (ret) {
-	case TEE_SUCCESS:
-		break;
-	case TEE_ERROR_GENERIC:
-	case TEE_ERROR_NO_DATA:
-	case TEE_ERROR_ITEM_NOT_FOUND:
-		*flag = 0;
-		if (rk_avb_write_perm_attr_flag(*flag)) {
-			avb_error("avb_write_perm_attr_flag error!");
-			ret = -1;
-		} else {
-			ret = trusty_read_permanent_attributes_flag(flag);
-		}
-		break;
-	default:
-		printf("%s: trusty_read_permanent_attributes_flag failed",
-		       __FILE__);
-	}
-
-	return ret;
-#else
-	return -1;
-#endif
-}
-
-int rk_avb_read_vbootkey_hash(uint8_t *buf, uint8_t length)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	if (trusty_read_vbootkey_hash((uint32_t *)buf,
-				      (uint32_t)length / sizeof(uint32_t))) {
-		printf("trusty_read_vbootkey_hash error!\n");
-		return -1;
-	}
-
-	return 0;
-#else
-	return -1;
-#endif
-}
-
-int rk_avb_write_vbootkey_hash(uint8_t *buf, uint8_t length)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	if (trusty_write_vbootkey_hash((uint32_t *)buf,
-				       (uint32_t)length / sizeof(uint32_t))) {
-		printf("trusty_write_vbootkey_hash error!\n");
-		return -1;
-	}
-
-	return 0;
-#else
-	return -1;
-#endif
-}
-
-int rk_avb_close_optee_client(void)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	if(trusty_notify_optee_uboot_end()) {
-		printf("trusty_notify_optee_uboot_end error!\n");
-		return -1;
-	}
-
-	return 0;
-#else
-	return -1;
-#endif
-}
-
-int rk_avb_read_attribute_hash(uint8_t *buf, uint8_t length)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	if (trusty_read_attribute_hash((uint32_t *)buf,
-	    (uint32_t)(length/sizeof(uint32_t)))) {
-		printf("trusty_read_attribute_hash error!\n");
-		return -1;
-	}
-
-	return 0;
-#else
-	return -1;
-#endif
-}
-
-int rk_avb_write_attribute_hash(uint8_t *buf, uint8_t length)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	if (trusty_write_attribute_hash((uint32_t *)buf,
-	    (uint32_t)(length/sizeof(uint32_t)))) {
-		printf("trusty_write_attribute_hash error!\n");
-		return -1;
-	}
-
-	return 0;
-#else
-	return -1;
-#endif
-}
-
-int rk_avb_read_all_rollback_index(char *buffer)
-{
-	AvbOps* ops;
-	uint64_t stored_rollback_index = 0;
-	AvbIOResult io_ret;
-	char temp[ROLLBACK_MAX_SIZE] = {0};
-
-	ops = avb_ops_user_new();
-	if (ops == NULL) {
-		printf("avb_ops_user_new() failed!\n");
-		return -1;
-	}
-
-	/* Actually the rollback_index_location 0 is used. */
-	io_ret = ops->read_rollback_index(ops, 0, &stored_rollback_index);
-	if (io_ret != AVB_IO_RESULT_OK)
-		goto out;
-	snprintf(temp, sizeof(int) + 1, "%d", 0);
-	strncat(buffer, temp, ROLLBACK_MAX_SIZE);
-	strncat(buffer, ":", 1);
-	snprintf(temp, sizeof(uint64_t) + 1, "%lld",
-		 stored_rollback_index);
-	strncat(buffer, temp, ROLLBACK_MAX_SIZE);
-	strncat(buffer, ",", 1);
-
-	io_ret =
-		ops->read_rollback_index(ops,
-					 AVB_ATX_PIK_VERSION_LOCATION,
-					 &stored_rollback_index);
-	if (io_ret != AVB_IO_RESULT_OK) {
-		avb_error("Failed to read PIK minimum version.\n");
-		goto out;
-	}
-	/* PIK rollback index */
-	snprintf(temp, sizeof(int) + 1, "%d", AVB_ATX_PIK_VERSION_LOCATION);
-	strncat(buffer, temp, ROLLBACK_MAX_SIZE);
-	strncat(buffer, ":", 1);
-	snprintf(temp, sizeof(uint64_t) + 1, "%lld", stored_rollback_index);
-	strncat(buffer, temp, ROLLBACK_MAX_SIZE);
-	strncat(buffer, ",", 1);
-	io_ret = ops->read_rollback_index(ops,
-					  AVB_ATX_PSK_VERSION_LOCATION,
-					  &stored_rollback_index);
-	if (io_ret != AVB_IO_RESULT_OK) {
-		avb_error("Failed to read PSK minimum version.\n");
-		goto out;
-	}
-	/* PSK rollback index */
-	snprintf(temp, sizeof(int) + 1, "%d", AVB_ATX_PSK_VERSION_LOCATION);
-	strncat(buffer, temp, ROLLBACK_MAX_SIZE);
-	strncat(buffer, ":", 1);
-	snprintf(temp, sizeof(uint64_t) + 1, "%lld", stored_rollback_index);
-	strncat(buffer, temp, ROLLBACK_MAX_SIZE);
-	debug("%s\n", buffer);
-	avb_ops_user_free(ops);
-
-	return 0;
-out:
-	avb_ops_user_free(ops);
-
-	return -1;
-}
-
-int rk_avb_read_bootloader_locked_flag(uint8_t *flag)
-{
-#ifdef CONFIG_OPTEE_CLIENT
-	if (trusty_read_vbootkey_enable_flag(flag))
-		return -1;
-#endif
-	return 0;
-}
-
-#ifdef CONFIG_SUPPORT_EMMC_RPMB
-static int curr_device = -1;
-
-int rk_bootloader_rollback_index_read(uint32_t offset, uint32_t bytes,
-				      void *rb_index)
-{
-
-	struct mmc *mmc;
-	uint8_t rpmb_buf[256] = {0};
-	uint32_t n;
-	char original_part;
-
-	if ((offset + bytes) > 256)
-		return -1;
-
-	if (curr_device < 0) {
-		if (get_mmc_num() > 0)
-			curr_device = 0;
-		else {
-			avb_error("No MMC device available");
-			return -1;
-		}
-	}
-
-	mmc = find_mmc_device(curr_device);
-	/* Switch to the RPMB partition */
-#ifndef CONFIG_BLK
-	original_part = mmc->block_dev.hwpart;
-#else
-	original_part = mmc_get_blk_desc(mmc)->hwpart;
-#endif
-	if (blk_select_hwpart_devnum(IF_TYPE_MMC, curr_device, MMC_PART_RPMB) !=
-	    0)
-		return -1;
-
-	n =  mmc_rpmb_read(mmc, rpmb_buf, RPMB_BASE_ADDR, 1, NULL);
-	if (n != 1)
-		return -1;
-
-	/* Return to original partition */
-	if (blk_select_hwpart_devnum(IF_TYPE_MMC, curr_device, original_part) !=
-	    0)
-		return -1;
-
-	memcpy(rb_index, (void*)&rpmb_buf[offset], bytes);
-
-	return 0;
-}
-
-int rk_avb_get_bootloader_min_version(char *buffer)
-{
-	uint32_t rb_index;
-	char temp[ROLLBACK_MAX_SIZE] = {0};
-
-	if (rk_bootloader_rollback_index_read(UBOOT_RB_INDEX_OFFSET,
-					      sizeof(uint32_t), &rb_index)) {
-		avb_error("Can not read uboot rollback index");
-		return -1;
-	}
-	snprintf(temp, sizeof(int) + 1, "%d", 0);
-	strncat(buffer, temp, ROLLBACK_MAX_SIZE);
-	strncat(buffer, ":", 1);
-	snprintf(temp, sizeof(uint32_t) + 1, "%d", rb_index);
-	strncat(buffer, temp, ROLLBACK_MAX_SIZE);
-	strncat(buffer, ",", 1);
-
-	if (rk_bootloader_rollback_index_read(TRUST_RB_INDEX_OFFSET,
-					      sizeof(uint32_t), &rb_index)) {
-		avb_error("Can not read trust rollback index");
-		return -1;
-	}
-
-	snprintf(temp, sizeof(int) + 1, "%d", 1);
-	strncat(buffer, temp, ROLLBACK_MAX_SIZE);
-	strncat(buffer, ":", 1);
-	snprintf(temp, sizeof(uint32_t) + 1, "%d", rb_index);
-	strncat(buffer, temp, ROLLBACK_MAX_SIZE);
-
-	return 0;
-}
-#endif
-
-void rk_avb_get_at_vboot_state(char *buf)
-{
-	char temp_flag = 0;
-	char *lock_val = NULL;
-	char *unlock_dis_val = NULL;
-	char *perm_attr_flag = NULL;
-	char *bootloader_locked_flag = NULL;
-	char *rollback_indices;
-	char min_versions[ROLLBACK_MAX_SIZE + 1] = {0};
-	int n;
-
-	if (rk_avb_read_perm_attr_flag((uint8_t *)&temp_flag)) {
-		avb_error("Can not read perm_attr_flag!");
-		perm_attr_flag = "";
-	} else {
-		perm_attr_flag = temp_flag ? "1" : "0";
-	}
-
-	temp_flag = 0;
-	if (rk_avb_read_lock_state((uint8_t *)&temp_flag)) {
-		avb_error("Can not read lock state!");
-		lock_val = "";
-		unlock_dis_val = "";
-	} else {
-		lock_val = (temp_flag & LOCK_MASK) ? "0" : "1";
-		unlock_dis_val = (temp_flag & UNLOCK_DISABLE_MASK) ? "1" : "0";
-	}
-
-	temp_flag = 0;
-	if (rk_avb_read_bootloader_locked_flag((uint8_t *)&temp_flag)) {
-		avb_error("Can not read bootloader locked flag!");
-		bootloader_locked_flag = "";
-	} else {
-		bootloader_locked_flag = temp_flag ? "1" : "0";
-	}
-
-	rollback_indices = malloc(VBOOT_STATE_SIZE);
-	if (!rollback_indices) {
-		avb_error("No buff to malloc!");
-		return;
-	}
-
-	memset(rollback_indices, 0, VBOOT_STATE_SIZE);
-	if (rk_avb_read_all_rollback_index(rollback_indices))
-		avb_error("Can not read avb_min_ver!");
-#ifdef CONFIG_SUPPORT_EMMC_RPMB
-	/* bootloader-min-versions */
-	if (rk_avb_get_bootloader_min_version(min_versions))
-		avb_error("Call rk_avb_get_bootloader_min_version error!");
-#endif
-	n = snprintf(buf, VBOOT_STATE_SIZE - 1,
-		     "avb-perm-attr-set=%s\n"
-		     "avb-locked=%s\n"
-		     "avb-unlock-disabled=%s\n"
-		     "bootloader-locked=%s\n"
-		     "avb-min-versions=%s\n"
-		     "bootloader-min-versions=%s\n",
-		     perm_attr_flag,
-		     lock_val,
-		     unlock_dis_val,
-		     bootloader_locked_flag,
-		     rollback_indices,
-		     min_versions);
-	if (n >= VBOOT_STATE_SIZE) {
-		avb_error("The VBOOT_STATE buf is truncated\n");
-		buf[VBOOT_STATE_SIZE - 1] = 0;
-	}
-	debug("The vboot state buf is %s\n", buf);
-	free(rollback_indices);
-}
-
-int rk_avb_get_ab_info(AvbABData* ab_data)
-{
-	AvbOps* ops;
-	AvbIOResult io_ret = AVB_IO_RESULT_OK;
-	int ret = 0;
-
-	ops = avb_ops_user_new();
-	if (ops == NULL) {
-		printf("%s: avb_ops_user_new() failed!\n", __FILE__);
-		return -1;
-	}
-
-	io_ret = ops->ab_ops->read_ab_metadata(ops->ab_ops, ab_data);
-	if (io_ret != AVB_IO_RESULT_OK) {
-		avb_error("I/O error while loading A/B metadata.\n");
-		ret = -1;
-	}
-
-	avb_ops_user_free(ops);
-
-	return ret;
-}
-
-int rk_avb_get_part_has_slot_info(const char *base_name)
-{
-	char *part_name;
-	int part_num;
-	size_t part_name_len;
-	disk_partition_t part_info;
-	struct blk_desc *dev_desc;
-	const char *slot_suffix = "_a";
-
-	dev_desc = rockchip_get_bootdev();
-	if (!dev_desc) {
-		printf("%s: Could not find device!\n", __func__);
-		return -1;
-	}
-
-	if (base_name == NULL) {
-		printf("The base_name is NULL!\n");
-		return -1;
-	}
-
-	part_name_len = strlen(base_name) + 1;
-	part_name_len += strlen(slot_suffix);
-	part_name = malloc(part_name_len);
-	if (!part_name) {
-		printf("%s can not malloc a buffer!\n", __FILE__);
-		return -1;
-	}
-
-	memset(part_name, 0, part_name_len);
-	snprintf(part_name, part_name_len, "%s%s", base_name, slot_suffix);
-	part_num = part_get_info_by_name(dev_desc, part_name, &part_info);
-	if (part_num < 0) {
-		printf("Could not find partition \"%s\"\n", part_name);
-		part_num = -1;
-	}
-
-	free(part_name);
-	return part_num;
-}
-
-int rk_auth_unlock(void *buffer, char *out_is_trusted)
-{
-	AvbOps* ops;
-
-	ops = avb_ops_user_new();
-	if (ops == NULL) {
-		avb_error("avb_ops_user_new() failed!");
-		return -1;
-	}
-
-	if (avb_atx_validate_unlock_credential(ops->atx_ops,
-					   (AvbAtxUnlockCredential*)buffer,
-					   (bool*)out_is_trusted)) {
-		avb_ops_user_free(ops);
-		return -1;
-	}
-	avb_ops_user_free(ops);
-	if (*out_is_trusted == true)
-		return 0;
-	else
-		return -1;
-}
-
-int rk_generate_unlock_challenge(void *buffer, uint32_t *challenge_len)
-{
-	AvbOps* ops;
-	AvbIOResult result = AVB_IO_RESULT_OK;
-
-	ops = avb_ops_user_new();
-	if (ops == NULL) {
-		avb_error("avb_ops_user_new() failed!");
-		return -1;
-	}
-
-	result = avb_atx_generate_unlock_challenge(ops->atx_ops,
-						   (AvbAtxUnlockChallenge *)buffer);
-	avb_ops_user_free(ops);
-	*challenge_len = sizeof(AvbAtxUnlockChallenge);
-	if (result == AVB_IO_RESULT_OK)
-		return 0;
-	else
-		return -1;
-}
-
-int rk_avb_init_ab_metadata(void)
-{
-	AvbOps *ops;
-	AvbABData ab_data;
-
-	memset(&ab_data, 0, sizeof(AvbABData));
-	debug("sizeof(AvbABData) = %d\n", (int)(size_t)sizeof(AvbABData));
-
-	ops = avb_ops_user_new();
-	if (ops == NULL) {
-		printf("avb_ops_user_new() failed!\n");
-		return -1;
-	}
-
-	avb_ab_data_init(&ab_data);
-	if (ops->ab_ops->write_ab_metadata(ops->ab_ops, &ab_data) != 0) {
-		printf("do_avb_init_ab_metadata error!\n");
-		avb_ops_user_free(ops);
-		return -1;
-	}
-
-	printf("Initialize ab data to misc partition success.\n");
-	avb_ops_user_free(ops);
-
-	return 0;
-}
-
-#define AT_PERM_ATTR_FUSE		1
-#define AT_PERM_ATTR_CER_FUSE		2
-#define AT_LOCK_VBOOT			3
-
-int rk_avb_write_perm_attr(u16 id, void *pbuf, u16 size)
-{
-	uint8_t lock_state;
-#ifndef CONFIG_ROCKCHIP_PRELOADER_PUB_KEY
-	sha256_context ctx;
-	uint8_t digest[SHA256_SUM_LEN] = {0};
-	uint8_t digest_temp[SHA256_SUM_LEN] = {0};
-	uint8_t perm_attr_temp[PERM_ATTR_TOTAL_SIZE] = {0};
-	uint8_t flag = 0;
-#endif
-
-	switch (id) {
-	case AT_PERM_ATTR_FUSE:
-		if (size != PERM_ATTR_TOTAL_SIZE) {
-			debug("%s Permanent attribute size is not equal!\n", __func__);
-			return -EINVAL;
-		}
-
-#ifndef CONFIG_ROCKCHIP_PRELOADER_PUB_KEY
-		if (rk_avb_read_perm_attr_flag(&flag)) {
-			debug("%s rk_avb_read_perm_attr_flag error!\n", __func__);
-			return -EIO;
-		}
-
-		if (flag == PERM_ATTR_SUCCESS_FLAG) {
-			if (rk_avb_read_attribute_hash(digest_temp,
-						       SHA256_SUM_LEN)) {
-				debug("%s The efuse IO can not be used!\n", __func__);
-				return -EIO;
-			}
-
-			if (memcmp(digest, digest_temp, SHA256_SUM_LEN) != 0) {
-				if (rk_avb_read_permanent_attributes(perm_attr_temp,
-								     PERM_ATTR_TOTAL_SIZE)) {
-					debug("%s rk_avb_write_permanent_attributes error!\n", __func__);
-					return -EIO;
-				}
-
-				sha256_starts(&ctx);
-				sha256_update(&ctx,
-					      (const uint8_t *)perm_attr_temp,
-					      PERM_ATTR_TOTAL_SIZE);
-				sha256_finish(&ctx, digest);
-				if (memcmp(digest, digest_temp, SHA256_SUM_LEN) == 0) {
-					debug("%s The hash has been written!\n", __func__);
-					return 0;
-				}
-			}
-
-			if (rk_avb_write_perm_attr_flag(0)) {
-				debug("%s Perm attr flag write failure\n", __func__);
-				return -EIO;
-			}
-		}
-#endif
-		if (rk_avb_write_permanent_attributes((uint8_t *)
-						      pbuf,
-						      size)) {
-			if (rk_avb_write_perm_attr_flag(0)) {
-				debug("%s Perm attr flag write failure\n", __func__);
-				return -EIO;
-			}
-
-			debug("%s Perm attr write failed\n", __func__);
-			return -EIO;
-		}
-#ifndef CONFIG_ROCKCHIP_PRELOADER_PUB_KEY
-		memset(digest, 0, SHA256_SUM_LEN);
-		sha256_starts(&ctx);
-		sha256_update(&ctx, (const uint8_t *)pbuf,
-			      PERM_ATTR_TOTAL_SIZE);
-		sha256_finish(&ctx, digest);
-
-		if (rk_avb_write_attribute_hash((uint8_t *)digest,
-						SHA256_SUM_LEN)) {
-			if (rk_avb_read_attribute_hash(digest_temp,
-						       SHA256_SUM_LEN)) {
-				debug("%s The efuse IO can not be used!\n", __func__);
-				return -EIO;
-			}
-
-			if (memcmp(digest, digest_temp, SHA256_SUM_LEN) != 0) {
-				if (rk_avb_write_perm_attr_flag(0)) {
-					debug("%s Perm attr flag write failure\n", __func__);
-					return -EIO;
-				}
-				debug("%s The hash has been written, but is different!\n", __func__);
-				return -EIO;
-			}
-		}
-#endif
-		if (rk_avb_write_perm_attr_flag(PERM_ATTR_SUCCESS_FLAG)) {
-			debug("%s, Perm attr flag write failure\n", __func__);
-			return -EIO;
-		}
-
-		break;
-	case AT_PERM_ATTR_CER_FUSE:
-		if (size != 256) {
-			debug("%s Permanent attribute rsahash size is not equal!\n",
-			      __func__);
-			return -EINVAL;
-		}
-		if (rk_avb_set_perm_attr_cer((uint8_t *)pbuf, size)) {
-			debug("%s FAILSet perm attr cer fail!\n", __func__);
-			return -EIO;
-		}
-		break;
-	case AT_LOCK_VBOOT:
-		lock_state = 0;
-		if (rk_avb_write_lock_state(lock_state)) {
-			debug("%s FAILwrite lock state failed\n", __func__);
-			return -EIO;
-		} else {
-			debug("%s OKAY\n", __func__);
-		}
-		break;
-	}
-	return 0;
-}
-
-int rk_avb_read_perm_attr(u16 id, void *pbuf, u16 size)
-{
-	int ret = 0;
-	debug("%s %d\n", __func__, size);
-
-	switch (id) {
-	case AT_PERM_ATTR_FUSE:
-		size = PERM_ATTR_TOTAL_SIZE;
-		ret = rk_avb_read_permanent_attributes((uint8_t *)pbuf, PERM_ATTR_TOTAL_SIZE);
-		break;
-	case AT_PERM_ATTR_CER_FUSE:
-		size = PERM_ATTR_TOTAL_SIZE;
-		ret = rk_avb_get_perm_attr_cer((uint8_t *)pbuf, 256);
-		break;
-	case AT_LOCK_VBOOT:
-		break;
-	}
-
-	return ret;
-}
-
+version https://git-lfs.github.com/spec/v1
+oid sha256:29a36a8638faea76321ce6cbf6612c2c3a4cb59e17c990e4076da45843ec25e6
+size 18431
diff --git a/vendor/androidWork b/vendor/androidWork
index e3f1a2f124..ef2ecfdd6b 160000
--- a/vendor/androidWork
+++ b/vendor/androidWork
@@ -1 +1 @@
-Subproject commit e3f1a2f1240b196c435ba14c801e20c25a867564
+Subproject commit ef2ecfdd6bbb80263bbf66a717d79afabb16d668
